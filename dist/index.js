require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3109:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__nccwpck_require__(2186));
const processor_1 = __nccwpck_require__(2589);
const utils_1 = __nccwpck_require__(918);
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // read in path specification, resolve github workspace, and repo path
            const inputPath = core.getInput('path');
            const repositoryPath = (0, utils_1.retrieveRepositoryPath)(inputPath);
            // read in test exec config file if possible
            const testExecutionJsonInput = core.getInput('testExecutionJson');
            const testExecutionJson = (0, utils_1.resolveJson)(repositoryPath, testExecutionJsonInput);
            // read in test config file if possible
            const testJsonInput = core.getInput('testJson');
            const testJson = (0, utils_1.resolveJson)(repositoryPath, testJsonInput);
            // credentials for xray
            const cloud = core.getInput('xrayCloud') === 'true';
            const xrayBaseUrl = core.getInput('xrayBaseUrl');
            let baseUrl = undefined;
            if (xrayBaseUrl !== '') {
                try {
                    baseUrl = new URL(xrayBaseUrl);
                }
                catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                    core.setFailed(error.message);
                }
            }
            const xrayToken = core.getInput('xrayToken');
            const username = core.getInput('username');
            const password = core.getInput('password');
            if (!username && !xrayToken) {
                core.setFailed('The required `username` is missing');
                return;
            }
            else if (!password && !xrayToken) {
                core.setFailed('The required `password` is missing');
                return;
            }
            // params for xray
            const testPaths = core.getInput('testPaths');
            const testMerge = core.getInput('testMerge') === 'true';
            const testFormat = core.getInput('testFormat');
            const testExecKey = core.getInput('testExecKey');
            const projectKey = core.getInput('projectKey');
            const testPlanKey = core.getInput('testPlanKey');
            const testEnvironments = core.getInput('testEnvironments');
            const revision = core.getInput('revision');
            const fixVersion = core.getInput('fixVersion');
            // importConfigurations
            const combineInSingleTestExec = core.getInput('combineInSingleTestExec') === 'true';
            const failOnImportError = core.getInput('failOnImportError') === 'true';
            const continueOnImportError = core.getInput('continueOnImportError') === 'true';
            const importParallelism = Number(core.getInput('importParallelism')) || 2; // by default go to 2 parallelism
            yield new processor_1.Processor({
                cloud,
                baseUrl,
                username,
                password,
                token: xrayToken
            }, {
                testFormat,
                testPaths,
                testMerge,
                testExecKey,
                projectKey,
                testPlanKey,
                testEnvironments,
                revision,
                fixVersion,
                testExecutionJson,
                testJson
            }, {
                combineInSingleTestExec,
                failOnImportError,
                continueOnImportError,
                importParallelism
            }).process();
        }
        catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
            core.setFailed(error.message);
        }
    });
}
run();


/***/ }),

/***/ 2589:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Processor = void 0;
const core = __importStar(__nccwpck_require__(2186));
const promise_pool_1 = __nccwpck_require__(8941);
const fs = __importStar(__nccwpck_require__(7147));
const mime_types_1 = __nccwpck_require__(3583);
const utils_1 = __nccwpck_require__(918);
const xray_cloud_1 = __nccwpck_require__(4261);
const xray_server_1 = __nccwpck_require__(909);
class Processor {
    constructor(xrayOptions, xrayImportOptions, importOptions) {
        this.xrayOptions = xrayOptions;
        this.xrayImportOptions = xrayImportOptions;
        this.importOptions = importOptions;
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            core.startGroup(`ðŸš€ Connect to xray`);
            let xray;
            if (this.xrayOptions.cloud) {
                xray = new xray_cloud_1.XrayCloud(this.xrayOptions, this.xrayImportOptions);
                core.info('â„¹ï¸ Configured XrayCloud');
            }
            else {
                xray = new xray_server_1.XrayServer(this.xrayOptions, this.xrayImportOptions);
                core.info('â„¹ï¸ Configured XrayServer');
            }
            if (xray.requiresAuth) {
                core.info('â„¹ï¸ Start logging in procedure to xray');
                try {
                    yield xray.auth();
                    core.info('â„¹ï¸ Completed login and retrieved token');
                }
                catch (error) {
                    core.setFailed(`ðŸ”¥ Failed to authenticate with Xray: ${error}`);
                    return false;
                }
            }
            else {
                core.info('â„¹ï¸ No authentication required, using Basic Auth or provided token');
            }
            core.endGroup();
            core.startGroup(`ðŸ“ Import test reports`);
            const importOptions = this.importOptions;
            let completed = 0;
            let failed = 0;
            core.info(`â„¹ï¸ Importing from: ${this.xrayImportOptions.testPaths}`);
            core.info(`â„¹ï¸ Importing using format: ${this.xrayImportOptions.testFormat}`);
            // load the test files, this may merge the results into a single file
            const files = yield (0, utils_1.retrieveTestFiles)(this.xrayImportOptions.testMerge, this.xrayImportOptions.testFormat, this.xrayImportOptions.testPaths);
            try {
                /* does a import for a specific file */
                // eslint-disable-next-line no-inner-declarations
                function doImport(file) {
                    return __awaiter(this, void 0, void 0, function* () {
                        core.debug(`Try to import: ${file}`);
                        try {
                            // identify mimetype
                            const tmpMime = (0, mime_types_1.lookup)(file);
                            let mimeType;
                            if (tmpMime === false) {
                                mimeType = 'application/xml';
                            }
                            else {
                                mimeType = tmpMime;
                            }
                            // execute import
                            const result = yield xray.import(yield fs.promises.readFile(file), mimeType);
                            core.info(`â„¹ï¸ Imported: ${file} (${result})`);
                            completed++;
                            return result;
                        }
                        catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                            core.warning(`ðŸ”¥ Failed to import: ${file} (${error.message})`);
                            failed++;
                            if (!importOptions.continueOnImportError) {
                                throw error;
                            }
                        }
                        return '';
                    });
                }
                // all exec keys
                const execKeys = [];
                // if no test exec key was specified we wanna execute once and then update the testExec for the remaining imports
                if (files.length > 1 &&
                    !this.xrayImportOptions.testExecKey &&
                    this.importOptions.combineInSingleTestExec) {
                    core.debug(`Do import of first file to retrieve a new testExec`);
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const testExecKey = yield doImport(files.shift());
                    if (testExecKey) {
                        xray.updateTestExecKey(testExecKey);
                        execKeys.push(testExecKey);
                    }
                    else {
                        throw Error("Couldn't retrieve the test exec key by importing one test");
                    }
                }
                if (files.length > 0) {
                    // execute all remaining in parallel
                    const { results } = yield promise_pool_1.PromisePool.for(files)
                        .withConcurrency(this.importOptions.importParallelism)
                        .process((file) => __awaiter(this, void 0, void 0, function* () { return yield doImport(file); }));
                    execKeys.push(results);
                }
                core.setOutput('testExecKey', execKeys.join(','));
            }
            catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                core.warning(`ðŸ”¥ Stopped import (${error.message})`);
            }
            core.info(`â„¹ï¸ Processed ${completed} of ${files.length} elements. Failed to import: ${failed}`);
            core.setOutput('count', files.length);
            core.setOutput('completed', completed);
            core.setOutput('failed', failed);
            let success = true;
            if (failed > 0 && this.importOptions.failOnImportError) {
                core.setFailed(`ðŸ”¥ ${failed} failed imports detected`);
                success = false;
            }
            core.endGroup();
            return success;
        });
    }
}
exports.Processor = Processor;


/***/ }),

/***/ 918:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retrieveTestFiles = exports.doFormDataRequest = exports.resolveJson = exports.retrieveRepositoryPath = exports.tmpFile = void 0;
const core = __importStar(__nccwpck_require__(2186));
const path = __importStar(__nccwpck_require__(1017));
const fs = __importStar(__nccwpck_require__(7147));
const os_1 = __nccwpck_require__(2037);
const crypto_1 = __nccwpck_require__(6113);
const path_1 = __nccwpck_require__(1017);
const glob = __importStar(__nccwpck_require__(8090));
const junit_report_merger_1 = __nccwpck_require__(3081);
/**
 * Constructs a temporary file, with the given extension
 */
function tmpFile(ext) {
    return (0, path_1.join)((0, os_1.tmpdir)(), `tmp.${(0, crypto_1.randomBytes)(6).readUIntLE(0, 6).toString(36)}.${ext}`);
}
exports.tmpFile = tmpFile;
/**
 * Resolves the repository path, relatively to the GITHUB_WORKSPACE
 */
function retrieveRepositoryPath(providedPath) {
    let githubWorkspacePath = process.env['GITHUB_WORKSPACE'];
    if (!githubWorkspacePath) {
        throw new Error('GITHUB_WORKSPACE not defined');
    }
    githubWorkspacePath = path.resolve(githubWorkspacePath);
    core.debug(`GITHUB_WORKSPACE = '${githubWorkspacePath}'`);
    let repositoryPath = providedPath || '.';
    repositoryPath = path.resolve(githubWorkspacePath, repositoryPath);
    core.debug(`repositoryPath = '${repositoryPath}'`);
    return repositoryPath;
}
exports.retrieveRepositoryPath = retrieveRepositoryPath;
/**
 * Retrieves the json configuration specified
 */
function resolveJson(githubWorkspacePath, file) {
    if (file) {
        try {
            if (fs.existsSync(path.resolve(file))) {
                return JSON.parse(fs.readFileSync(path.resolve(file), 'utf8'));
            }
            else {
                return JSON.parse(fs.readFileSync(path.resolve(githubWorkspacePath, file), 'utf8'));
            }
        }
        catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
            core.error(`ðŸ”¥ The provided json file (${file}) could not be parsed: ${error.message}`);
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.resolveJson = resolveJson;
/**
 * Do a request with options provided.
 *
 * @param {Object} options
 * @param {Object} data
 * @return {Promise} a promise of request
 */
function doFormDataRequest(formData, params
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            formData.submit(params, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    res.setEncoding('utf8');
                    let responseBody = '';
                    res.on('data', chunk => {
                        responseBody += chunk;
                    });
                    res.on('end', () => {
                        try {
                            core.debug(`Server response: ${responseBody}`);
                            resolve(JSON.parse(responseBody));
                        }
                        catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                            core.warning(`ðŸ”¥ Server responded with error (${error.message}): ${responseBody}`);
                            reject(error);
                        }
                    });
                }
            });
        });
    });
}
exports.doFormDataRequest = doFormDataRequest;
/**
 * Retrieves the test result files given the provided globber.
 * Automatically merges supported test result formats into a single file.
 */
function retrieveTestFiles(testMerge, testFormat, testPaths) {
    return __awaiter(this, void 0, void 0, function* () {
        // match find the test files via the globber
        const globber = yield glob.create(testPaths, {
            followSymbolicLinks: false
        });
        const files = yield globber.glob();
        // merge together the test result files if requested, and more than 1 file is found
        if (files.length > 1 && testMerge) {
            // supported for junit
            if (testFormat === 'junit') {
                try {
                    const tmp = tmpFile('xml');
                    yield (0, junit_report_merger_1.mergeFiles)(tmp, [testPaths]);
                    core.info(`â„¹ï¸ Merged ${files.length} junit test reports into a single file: ${tmp}`);
                    return [tmp];
                }
                catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                    core.warning(`ðŸ”¥ Failed to merge junit test report files: ${error.message}`);
                }
            }
            else if (testFormat === 'cucumber') {
                try {
                    const tmp = tmpFile('json');
                    fs.writeFileSync(tmp, mergeJsonFiles(files));
                    core.info(`â„¹ï¸ Merged ${files.length} cucumber test reports into a single file: ${tmp}`);
                    return [tmp];
                }
                catch (error /* eslint-disable-line @typescript-eslint/no-explicit-any */) {
                    core.warning(`ðŸ”¥ Failed to merge cucumber test report files: ${error.message}`);
                }
            }
            else {
                core.info(`â„¹ï¸ ${testFormat} does currently not support test result merging`);
            }
        }
        return files;
    });
}
exports.retrieveTestFiles = retrieveTestFiles;
/**
 * Merges multiple json report files together.
 * This works for `cucumber` test reports.
 *
 * Credits to:
 * https://github.com/bitcoder/cucumber-json-merge/blob/master/lib/index.js#L41-L57
 *
 * Licensed as: Apache 2.0
 * https://github.com/bitcoder/cucumber-json-merge/blob/master/LICENSE
 */
function mergeJsonFiles(files) {
    const mergedResults = [];
    for (const file of files) {
        try {
            const rawdata = fs.readFileSync(file, 'utf8');
            const partialResults = JSON.parse(rawdata);
            mergedResults.push(partialResults);
        }
        catch (err) {
            if (err instanceof SyntaxError) {
                throw new Error('Invalid JSON content');
            }
            else {
                throw err;
            }
        }
    }
    return JSON.stringify(mergedResults.concat.apply([], mergedResults));
}


/***/ }),

/***/ 4261:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XrayCloud = void 0;
const got_1 = __importDefault(__nccwpck_require__(3061));
const core = __importStar(__nccwpck_require__(2186));
const form_data_1 = __importDefault(__nccwpck_require__(4334));
const utils_1 = __nccwpck_require__(918);
const xray_utils_1 = __nccwpck_require__(7249);
class XrayCloud {
    constructor(xrayOptions, xrayImportOptions) {
        this.xrayOptions = xrayOptions;
        this.xrayImportOptions = xrayImportOptions;
        this.xrayBaseUrl = new URL('https://xray.cloud.getxray.app');
        this.token = '';
        // XrayCloud requires to authenticate with the given credentials first
        this.requiresAuth = true;
        this.searchParams = (0, xray_utils_1.createSearchParams)(this.xrayImportOptions);
    }
    protocol() {
        if (this.xrayBaseUrl.protocol === 'http') {
            return 'http:';
        }
        else {
            return 'https:';
        }
    }
    auth() {
        return __awaiter(this, void 0, void 0, function* () {
            const authenticateResponse = yield got_1.default.post(`${this.xrayBaseUrl.href}/api/v2/authenticate`, {
                json: {
                    client_id: `${this.xrayOptions.username}`,
                    client_secret: `${this.xrayOptions.password}`
                },
                responseType: 'json',
                timeout: 30000,
                retry: 2,
                http2: true // try to allow http2 requests
            });
            this.token = authenticateResponse.body;
            core.setSecret(this.token);
        });
    }
    updateTestExecKey(testExecKey) {
        this.xrayImportOptions.testExecKey = testExecKey;
        this.searchParams = (0, xray_utils_1.createSearchParams)(this.xrayImportOptions);
    }
    import(data, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            // do import
            let format = this.xrayImportOptions.testFormat;
            if (format === 'xray') {
                format = ''; // xray format has no subpath
            }
            if (this.xrayImportOptions.testExecutionJson &&
                this.xrayImportOptions.testExecKey === '') {
                const form = new form_data_1.default();
                (0, xray_utils_1.updateTestExecJson)(this.xrayImportOptions, this.xrayImportOptions.testExecutionJson);
                (0, xray_utils_1.updateTestExecJsonCloud)(this.xrayImportOptions, this.xrayImportOptions.testExecutionJson);
                form.append('info', JSON.stringify(this.xrayImportOptions.testExecutionJson), {
                    contentType: 'application/json',
                    filename: 'info.json',
                    filepath: 'info.json'
                });
                const fileExtension = (0, xray_utils_1.retrieveFileExtension)(mimeType);
                form.append('results', data.toString('utf-8'), {
                    contentType: mimeType,
                    filename: `test.${fileExtension}`,
                    filepath: `test.${fileExtension}`
                });
                (0, xray_utils_1.updateTestJson)(this.xrayImportOptions, this.xrayImportOptions.testJson);
                if (this.xrayImportOptions.testJson) {
                    form.append('testInfo', JSON.stringify(this.xrayImportOptions.testJson), {
                        contentType: 'application/json',
                        filename: 'testInfo.json',
                        filepath: 'testInfo.json'
                    });
                }
                core.debug(`Using multipart endpoint: ${this.xrayBaseUrl.href}/api/v2/import/execution/${format}/multipart`);
                const importResponse = yield (0, utils_1.doFormDataRequest)(form, {
                    protocol: this.protocol(),
                    host: this.xrayBaseUrl.host,
                    path: `${this.xrayBaseUrl.pathname}/api/v2/import/execution/${format}/multipart`,
                    headers: { Authorization: `Bearer ${this.token}` }
                });
                try {
                    return importResponse.key;
                }
                catch (error) {
                    core.warning(`ðŸ”¥ Response did not match expected format: ${JSON.stringify(importResponse)}`);
                    return '';
                }
            }
            else {
                const endpoint = `${this.xrayBaseUrl.href}/api/v2/import/execution/${format}`;
                core.debug(`Using endpoint: ${endpoint}`);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const importResponse = yield got_1.default.post(endpoint, {
                    searchParams: this.searchParams,
                    headers: {
                        Authorization: `Bearer ${this.token}`,
                        'Content-Type': mimeType
                    },
                    body: data,
                    responseType: 'json',
                    timeout: 60000,
                    retry: 2,
                    http2: true // try to allow http2 requests
                });
                try {
                    return importResponse.body.key;
                }
                catch (error) {
                    core.warning(`ðŸ”¥ Response did not match expected format: ${JSON.stringify(importResponse.body || importResponse)}`);
                    return '';
                }
            }
        });
    }
}
exports.XrayCloud = XrayCloud;


/***/ }),

/***/ 909:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XrayServer = void 0;
const got_1 = __importDefault(__nccwpck_require__(3061));
const core = __importStar(__nccwpck_require__(2186));
const form_data_1 = __importDefault(__nccwpck_require__(4334));
const utils_1 = __nccwpck_require__(918);
const xray_utils_1 = __nccwpck_require__(7249);
class XrayServer {
    constructor(xrayOptions, xrayImportOptions) {
        this.xrayOptions = xrayOptions;
        this.xrayImportOptions = xrayImportOptions;
        this.token = '';
        // XrayServer does not require authentication (uses BasicAuth or Token)
        this.requiresAuth = false;
        this.xrayBaseUrl =
            this.xrayOptions.baseUrl || new URL('https://sandbox.xpand-it.com');
        this.searchParams = (0, xray_utils_1.createSearchParams)(this.xrayImportOptions);
    }
    protocol() {
        if (this.xrayBaseUrl.protocol === 'http') {
            return 'http:';
        }
        else {
            return 'https:';
        }
    }
    auth() {
        return __awaiter(this, void 0, void 0, function* () {
            // no auth needed
        });
    }
    updateTestExecKey(testExecKey) {
        this.xrayImportOptions.testExecKey = testExecKey;
        this.searchParams = (0, xray_utils_1.createSearchParams)(this.xrayImportOptions);
    }
    import(data, mimeType) {
        return __awaiter(this, void 0, void 0, function* () {
            // do import
            let format = this.xrayImportOptions.testFormat;
            if (format === 'xray') {
                format = ''; // xray format has no subpath
            }
            let authString = '';
            if (this.xrayOptions.token) {
                authString = `Bearer ${this.xrayOptions.token}`;
            }
            else {
                authString = `Basic ${Buffer.from(`${this.xrayOptions.username}:${this.xrayOptions.password}`).toString('base64')}`;
            }
            if (this.xrayImportOptions.testExecutionJson &&
                this.xrayImportOptions.testExecKey === '') {
                const form = new form_data_1.default();
                (0, xray_utils_1.updateTestExecJson)(this.xrayImportOptions, this.xrayImportOptions.testExecutionJson);
                form.append('info', JSON.stringify(this.xrayImportOptions.testExecutionJson), {
                    contentType: 'application/json',
                    filename: 'info.json',
                    filepath: 'info.json'
                });
                let apiPartName;
                if (format === 'cucumber') {
                    // workaround for cucumber, see for more details:
                    // https://github.com/Xray-App/xray-code-snippets/blob/649be6d73d3213a22ef31a52bf6e2ac7d557330d/use_cases/import_automation_results/java/xray-code-snippets/src/main/java/com/idera/xray/XrayResultsImporter.java#L205
                    apiPartName = 'result';
                }
                else {
                    apiPartName = 'file';
                }
                const fileExtension = (0, xray_utils_1.retrieveFileExtension)(mimeType);
                form.append(apiPartName, data.toString('utf-8'), {
                    contentType: mimeType,
                    filename: `report.${fileExtension}`,
                    filepath: `report.${fileExtension}`
                });
                (0, xray_utils_1.updateTestJson)(this.xrayImportOptions, this.xrayImportOptions.testJson);
                if (this.xrayImportOptions.testJson) {
                    form.append('testInfo', JSON.stringify(this.xrayImportOptions.testJson), {
                        contentType: 'application/json',
                        filename: 'testInfo.json',
                        filepath: 'testInfo.json'
                    });
                }
                core.debug(`Using multipart endpoint: ${this.xrayBaseUrl.href}/rest/raven/2.0/import/execution/${format}/multipart`);
                const importResponse = yield (0, utils_1.doFormDataRequest)(form, {
                    protocol: this.protocol(),
                    host: this.xrayBaseUrl.host,
                    headers: {
                        Authorization: authString
                    },
                    path: `${this.xrayBaseUrl.pathname}/rest/raven/2.0/import/execution/${format}/multipart`
                });
                try {
                    return importResponse.testExecIssue.key;
                }
                catch (error) {
                    core.warning(`ðŸ”¥ Response did not match expected format: ${JSON.stringify(importResponse)}`);
                    return '';
                }
            }
            else {
                if (mimeType === 'application/xml') {
                    const form = new form_data_1.default();
                    form.append('file', data.toString('utf-8'), {
                        contentType: mimeType,
                        filename: 'report.xml',
                        filepath: 'report.xml'
                    });
                    const importResponse = yield (0, utils_1.doFormDataRequest)(form, {
                        protocol: this.protocol(),
                        host: this.xrayBaseUrl.host,
                        headers: {
                            Authorization: authString
                        },
                        path: `${this.xrayBaseUrl.pathname}/rest/raven/2.0/import/execution/${format}?${this.searchParams.toString()}`
                    });
                    try {
                        return importResponse.testExecIssue.key;
                    }
                    catch (error) {
                        core.warning(`ðŸ”¥ Response did not match expected format: ${JSON.stringify(importResponse)}`);
                        return '';
                    }
                }
                else {
                    const endpoint = `${this.xrayBaseUrl.href}/rest/raven/2.0/import/execution/${format}`;
                    core.debug(`Using endpoint: ${endpoint}`);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const importResponse = yield got_1.default.post(endpoint, {
                        searchParams: this.searchParams,
                        headers: {
                            Authorization: authString,
                            'Content-Type': mimeType
                        },
                        body: data,
                        responseType: 'json',
                        timeout: 60000 // 60s timeout
                    });
                    try {
                        return importResponse.body.testExecIssue.key;
                    }
                    catch (error) {
                        core.warning(`ðŸ”¥ Response did not match expected format: ${JSON.stringify(importResponse.body || importResponse)}`);
                        return '';
                    }
                }
            }
        });
    }
}
exports.XrayServer = XrayServer;


/***/ }),

/***/ 7249:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retrieveFileExtension = exports.updateTestJson = exports.updateTestExecJsonCloud = exports.updateTestExecJson = exports.createSearchParams = void 0;
const core = __importStar(__nccwpck_require__(2186));
const mime_types_1 = __nccwpck_require__(3583);
/**
 *
 */
function createSearchParams(xrayImportOptions) {
    // prepare params
    const elements = [['projectKey', xrayImportOptions.projectKey]];
    if (xrayImportOptions.testExecKey) {
        elements.push(['testExecKey', xrayImportOptions.testExecKey]);
    }
    if (xrayImportOptions.testPlanKey) {
        elements.push(['testPlanKey', xrayImportOptions.testPlanKey]);
    }
    if (xrayImportOptions.testEnvironments) {
        elements.push(['testEnvironments', xrayImportOptions.testEnvironments]);
    }
    if (xrayImportOptions.revision) {
        elements.push(['revision', xrayImportOptions.revision]);
    }
    if (xrayImportOptions.fixVersion) {
        elements.push(['fixVersion', xrayImportOptions.fixVersion]);
    }
    return new URLSearchParams(elements);
}
exports.createSearchParams = createSearchParams;
/**
 *
 */
function updateTestExecJson(xrayImportOptions, testExecutionJson) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const testExecJson = testExecutionJson;
    if (!testExecJson['fields']) {
        testExecJson['fields'] = {};
    }
    if (!testExecJson['fields']['project']) {
        testExecJson['fields']['project'] = {};
    }
    if (xrayImportOptions.projectKey) {
        testExecJson['fields']['project']['key'] = xrayImportOptions.projectKey;
    }
    else {
        core.debug(`No "projectKey" passed via configuration. Using ${JSON.stringify(testExecJson['fields']['project'])}`);
    }
    xrayImportOptions.testExecutionJson = testExecJson;
}
exports.updateTestExecJson = updateTestExecJson;
/**
 * only the cloud API uses the `xrayFields` to define test exec key, test plan key, etc.
 *
 * CLOUD
 * https://docs.getxray.app/display/XRAYCLOUD/Import+Execution+Results+-+REST#ImportExecutionResultsREST-XrayJSONresultsMultipart
 *
 * SERVER
 * https://docs.getxray.app/display/XRAY/Import+Execution+Results+-+REST#ImportExecutionResultsREST-XrayJSONresultsMultipart
 */
function updateTestExecJsonCloud(xrayImportOptions, testExecutionJson) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const testExecJson = testExecutionJson;
    if (!testExecJson['xrayFields']) {
        testExecJson['xrayFields'] = {};
    }
    if (xrayImportOptions.testExecKey) {
        testExecJson['xrayFields']['testExecKey'] = xrayImportOptions.testExecKey;
    }
    if (xrayImportOptions.testPlanKey) {
        testExecJson['xrayFields']['testPlanKey'] = xrayImportOptions.testPlanKey;
    }
    if (xrayImportOptions.testEnvironments) {
        testExecJson['xrayFields']['testEnvironments'] =
            xrayImportOptions.testEnvironments;
    }
    if (xrayImportOptions.revision) {
        testExecJson['xrayFields']['revision'] = xrayImportOptions.revision;
    }
    if (xrayImportOptions.fixVersion) {
        testExecJson['xrayFields']['fixVersion'] = xrayImportOptions.fixVersion;
    }
    xrayImportOptions.testExecutionJson = testExecJson;
}
exports.updateTestExecJsonCloud = updateTestExecJsonCloud;
/**
 *
 */
function updateTestJson(xrayImportOptions, testJson) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let tJson;
    if (xrayImportOptions.projectKey ||
        (tJson &&
            tJson['fields'] &&
            tJson['fields']['project'] &&
            tJson['fields']['project']['key'])) {
        if (testJson === undefined) {
            tJson = {};
        }
        else {
            tJson = testJson;
        }
        if (!tJson['fields']) {
            tJson['fields'] = {};
        }
        if (!tJson['fields']['project']) {
            tJson['fields']['project'] = {};
        }
        if (xrayImportOptions.projectKey) {
            tJson['fields']['project']['key'] = xrayImportOptions.projectKey;
        }
        else {
            core.debug(`No "projectKey" passed via configuration. Using ${JSON.stringify(tJson['fields']['project'])}`);
        }
        xrayImportOptions.testJson = tJson;
    }
    else {
        core.debug(`No "projectKey" passed via configuration nor test json.`);
    }
}
exports.updateTestJson = updateTestJson;
/**
 * Resolves the file extension based on the mime type.
 * Falls back to xml if not identified.
 */
function retrieveFileExtension(mimeType) {
    return (0, mime_types_1.extension)(mimeType) || 'xml';
}
exports.retrieveFileExtension = retrieveFileExtension;


/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    return inputs;
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issueCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 8090:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashFiles = exports.create = void 0;
const internal_globber_1 = __nccwpck_require__(8298);
const internal_hash_files_1 = __nccwpck_require__(2448);
/**
 * Constructs a globber
 *
 * @param patterns  Patterns separated by newlines
 * @param options   Glob options
 */
function create(patterns, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
}
exports.create = create;
/**
 * Computes the sha256 hash of a glob
 *
 * @param patterns  Patterns separated by newlines
 * @param options   Glob options
 */
function hashFiles(patterns, options, verbose = false) {
    return __awaiter(this, void 0, void 0, function* () {
        let followSymbolicLinks = true;
        if (options && typeof options.followSymbolicLinks === 'boolean') {
            followSymbolicLinks = options.followSymbolicLinks;
        }
        const globber = yield create(patterns, { followSymbolicLinks });
        return internal_hash_files_1.hashFiles(globber, verbose);
    });
}
exports.hashFiles = hashFiles;
//# sourceMappingURL=glob.js.map

/***/ }),

/***/ 1026:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOptions = void 0;
const core = __importStar(__nccwpck_require__(2186));
/**
 * Returns a copy with defaults filled in.
 */
function getOptions(copy) {
    const result = {
        followSymbolicLinks: true,
        implicitDescendants: true,
        matchDirectories: true,
        omitBrokenSymbolicLinks: true
    };
    if (copy) {
        if (typeof copy.followSymbolicLinks === 'boolean') {
            result.followSymbolicLinks = copy.followSymbolicLinks;
            core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
        }
        if (typeof copy.implicitDescendants === 'boolean') {
            result.implicitDescendants = copy.implicitDescendants;
            core.debug(`implicitDescendants '${result.implicitDescendants}'`);
        }
        if (typeof copy.matchDirectories === 'boolean') {
            result.matchDirectories = copy.matchDirectories;
            core.debug(`matchDirectories '${result.matchDirectories}'`);
        }
        if (typeof copy.omitBrokenSymbolicLinks === 'boolean') {
            result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
            core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
        }
    }
    return result;
}
exports.getOptions = getOptions;
//# sourceMappingURL=internal-glob-options-helper.js.map

/***/ }),

/***/ 8298:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultGlobber = void 0;
const core = __importStar(__nccwpck_require__(2186));
const fs = __importStar(__nccwpck_require__(7147));
const globOptionsHelper = __importStar(__nccwpck_require__(1026));
const path = __importStar(__nccwpck_require__(1017));
const patternHelper = __importStar(__nccwpck_require__(9005));
const internal_match_kind_1 = __nccwpck_require__(1063);
const internal_pattern_1 = __nccwpck_require__(4536);
const internal_search_state_1 = __nccwpck_require__(9117);
const IS_WINDOWS = process.platform === 'win32';
class DefaultGlobber {
    constructor(options) {
        this.patterns = [];
        this.searchPaths = [];
        this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
        // Return a copy
        return this.searchPaths.slice();
    }
    glob() {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            const result = [];
            try {
                for (var _b = __asyncValues(this.globGenerator()), _c; _c = yield _b.next(), !_c.done;) {
                    const itemPath = _c.value;
                    result.push(itemPath);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        });
    }
    globGenerator() {
        return __asyncGenerator(this, arguments, function* globGenerator_1() {
            // Fill in defaults options
            const options = globOptionsHelper.getOptions(this.options);
            // Implicit descendants?
            const patterns = [];
            for (const pattern of this.patterns) {
                patterns.push(pattern);
                if (options.implicitDescendants &&
                    (pattern.trailingSeparator ||
                        pattern.segments[pattern.segments.length - 1] !== '**')) {
                    patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat('**')));
                }
            }
            // Push the search paths
            const stack = [];
            for (const searchPath of patternHelper.getSearchPaths(patterns)) {
                core.debug(`Search path '${searchPath}'`);
                // Exists?
                try {
                    // Intentionally using lstat. Detection for broken symlink
                    // will be performed later (if following symlinks).
                    yield __await(fs.promises.lstat(searchPath));
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        continue;
                    }
                    throw err;
                }
                stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
            }
            // Search
            const traversalChain = []; // used to detect cycles
            while (stack.length) {
                // Pop
                const item = stack.pop();
                // Match?
                const match = patternHelper.match(patterns, item.path);
                const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
                if (!match && !partialMatch) {
                    continue;
                }
                // Stat
                const stats = yield __await(DefaultGlobber.stat(item, options, traversalChain)
                // Broken symlink, or symlink cycle detected, or no longer exists
                );
                // Broken symlink, or symlink cycle detected, or no longer exists
                if (!stats) {
                    continue;
                }
                // Directory
                if (stats.isDirectory()) {
                    // Matched
                    if (match & internal_match_kind_1.MatchKind.Directory && options.matchDirectories) {
                        yield yield __await(item.path);
                    }
                    // Descend?
                    else if (!partialMatch) {
                        continue;
                    }
                    // Push the child items in reverse
                    const childLevel = item.level + 1;
                    const childItems = (yield __await(fs.promises.readdir(item.path))).map(x => new internal_search_state_1.SearchState(path.join(item.path, x), childLevel));
                    stack.push(...childItems.reverse());
                }
                // File
                else if (match & internal_match_kind_1.MatchKind.File) {
                    yield yield __await(item.path);
                }
            }
        });
    }
    /**
     * Constructs a DefaultGlobber
     */
    static create(patterns, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = new DefaultGlobber(options);
            if (IS_WINDOWS) {
                patterns = patterns.replace(/\r\n/g, '\n');
                patterns = patterns.replace(/\r/g, '\n');
            }
            const lines = patterns.split('\n').map(x => x.trim());
            for (const line of lines) {
                // Empty or comment
                if (!line || line.startsWith('#')) {
                    continue;
                }
                // Pattern
                else {
                    result.patterns.push(new internal_pattern_1.Pattern(line));
                }
            }
            result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
            return result;
        });
    }
    static stat(item, options, traversalChain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note:
            // `stat` returns info about the target of a symlink (or symlink chain)
            // `lstat` returns info about a symlink itself
            let stats;
            if (options.followSymbolicLinks) {
                try {
                    // Use `stat` (following symlinks)
                    stats = yield fs.promises.stat(item.path);
                }
                catch (err) {
                    if (err.code === 'ENOENT') {
                        if (options.omitBrokenSymbolicLinks) {
                            core.debug(`Broken symlink '${item.path}'`);
                            return undefined;
                        }
                        throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
                    }
                    throw err;
                }
            }
            else {
                // Use `lstat` (not following symlinks)
                stats = yield fs.promises.lstat(item.path);
            }
            // Note, isDirectory() returns false for the lstat of a symlink
            if (stats.isDirectory() && options.followSymbolicLinks) {
                // Get the realpath
                const realPath = yield fs.promises.realpath(item.path);
                // Fixup the traversal chain to match the item level
                while (traversalChain.length >= item.level) {
                    traversalChain.pop();
                }
                // Test for a cycle
                if (traversalChain.some((x) => x === realPath)) {
                    core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
                    return undefined;
                }
                // Update the traversal chain
                traversalChain.push(realPath);
            }
            return stats;
        });
    }
}
exports.DefaultGlobber = DefaultGlobber;
//# sourceMappingURL=internal-globber.js.map

/***/ }),

/***/ 2448:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashFiles = void 0;
const crypto = __importStar(__nccwpck_require__(6113));
const core = __importStar(__nccwpck_require__(2186));
const fs = __importStar(__nccwpck_require__(7147));
const stream = __importStar(__nccwpck_require__(2781));
const util = __importStar(__nccwpck_require__(3837));
const path = __importStar(__nccwpck_require__(1017));
function hashFiles(globber, verbose = false) {
    var e_1, _a;
    var _b;
    return __awaiter(this, void 0, void 0, function* () {
        const writeDelegate = verbose ? core.info : core.debug;
        let hasMatch = false;
        const githubWorkspace = (_b = process.env['GITHUB_WORKSPACE']) !== null && _b !== void 0 ? _b : process.cwd();
        const result = crypto.createHash('sha256');
        let count = 0;
        try {
            for (var _c = __asyncValues(globber.globGenerator()), _d; _d = yield _c.next(), !_d.done;) {
                const file = _d.value;
                writeDelegate(file);
                if (!file.startsWith(`${githubWorkspace}${path.sep}`)) {
                    writeDelegate(`Ignore '${file}' since it is not under GITHUB_WORKSPACE.`);
                    continue;
                }
                if (fs.statSync(file).isDirectory()) {
                    writeDelegate(`Skip directory '${file}'.`);
                    continue;
                }
                const hash = crypto.createHash('sha256');
                const pipeline = util.promisify(stream.pipeline);
                yield pipeline(fs.createReadStream(file), hash);
                result.write(hash.digest());
                count++;
                if (!hasMatch) {
                    hasMatch = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) yield _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        result.end();
        if (hasMatch) {
            writeDelegate(`Found ${count} files to hash.`);
            return result.digest('hex');
        }
        else {
            writeDelegate(`No matches found for glob`);
            return '';
        }
    });
}
exports.hashFiles = hashFiles;
//# sourceMappingURL=internal-hash-files.js.map

/***/ }),

/***/ 1063:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MatchKind = void 0;
/**
 * Indicates whether a pattern matches a path
 */
var MatchKind;
(function (MatchKind) {
    /** Not matched */
    MatchKind[MatchKind["None"] = 0] = "None";
    /** Matched if the path is a directory */
    MatchKind[MatchKind["Directory"] = 1] = "Directory";
    /** Matched if the path is a regular file */
    MatchKind[MatchKind["File"] = 2] = "File";
    /** Matched */
    MatchKind[MatchKind["All"] = 3] = "All";
})(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
//# sourceMappingURL=internal-match-kind.js.map

/***/ }),

/***/ 1849:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = void 0;
const path = __importStar(__nccwpck_require__(1017));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Similar to path.dirname except normalizes the path separators and slightly better handling for Windows UNC paths.
 *
 * For example, on Linux/macOS:
 * - `/               => /`
 * - `/hello          => /`
 *
 * For example, on Windows:
 * - `C:\             => C:\`
 * - `C:\hello        => C:\`
 * - `C:              => C:`
 * - `C:hello         => C:`
 * - `\               => \`
 * - `\hello          => \`
 * - `\\hello         => \\hello`
 * - `\\hello\world   => \\hello\world`
 */
function dirname(p) {
    // Normalize slashes and trim unnecessary trailing slash
    p = safeTrimTrailingSeparator(p);
    // Windows UNC root, e.g. \\hello or \\hello\world
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p)) {
        return p;
    }
    // Get dirname
    let result = path.dirname(p);
    // Trim trailing slash for Windows UNC root, e.g. \\hello\world\
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
        result = safeTrimTrailingSeparator(result);
    }
    return result;
}
exports.dirname = dirname;
/**
 * Roots the path if not already rooted. On Windows, relative roots like `\`
 * or `C:` are expanded based on the current working directory.
 */
function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Already rooted
    if (hasAbsoluteRoot(itemPath)) {
        return itemPath;
    }
    // Windows
    if (IS_WINDOWS) {
        // Check for itemPath like C: or C:foo
        if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
            let cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            // Drive letter matches cwd? Expand to cwd
            if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
                // Drive only, e.g. C:
                if (itemPath.length === 2) {
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}`;
                }
                // Drive + path, e.g. C:foo
                else {
                    if (!cwd.endsWith('\\')) {
                        cwd += '\\';
                    }
                    // Preserve specified drive letter case (upper or lower)
                    return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
                }
            }
            // Different drive
            else {
                return `${itemPath[0]}:\\${itemPath.substr(2)}`;
            }
        }
        // Check for itemPath like \ or \foo
        else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
            const cwd = process.cwd();
            assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
            return `${cwd[0]}:\\${itemPath.substr(1)}`;
        }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    // Otherwise ensure root ends with a separator
    if (root.endsWith('/') || (IS_WINDOWS && root.endsWith('\\'))) {
        // Intentionally empty
    }
    else {
        // Append separator
        root += path.sep;
    }
    return root + itemPath;
}
exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\\hello\share` and `C:\hello` (and using alternate separator).
 */
function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \\hello\share or C:\hello
        return itemPath.startsWith('\\\\') || /^[A-Z]:\\/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasAbsoluteRoot = hasAbsoluteRoot;
/**
 * On Linux/macOS, true if path starts with `/`. On Windows, true for paths like:
 * `\`, `\hello`, `\\hello\share`, `C:`, and `C:\hello` (and using alternate separator).
 */
function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    // Normalize separators
    itemPath = normalizeSeparators(itemPath);
    // Windows
    if (IS_WINDOWS) {
        // E.g. \ or \hello or \\hello
        // E.g. C: or C:\hello
        return itemPath.startsWith('\\') || /^[A-Z]:/i.test(itemPath);
    }
    // E.g. /hello
    return itemPath.startsWith('/');
}
exports.hasRoot = hasRoot;
/**
 * Removes redundant slashes and converts `/` to `\` on Windows
 */
function normalizeSeparators(p) {
    p = p || '';
    // Windows
    if (IS_WINDOWS) {
        // Convert slashes on Windows
        p = p.replace(/\//g, '\\');
        // Remove redundant slashes
        const isUnc = /^\\\\+[^\\]/.test(p); // e.g. \\hello
        return (isUnc ? '\\' : '') + p.replace(/\\\\+/g, '\\'); // preserve leading \\ for UNC
    }
    // Remove redundant slashes
    return p.replace(/\/\/+/g, '/');
}
exports.normalizeSeparators = normalizeSeparators;
/**
 * Normalizes the path separators and trims the trailing separator (when safe).
 * For example, `/foo/ => /foo` but `/ => /`
 */
function safeTrimTrailingSeparator(p) {
    // Short-circuit if empty
    if (!p) {
        return '';
    }
    // Normalize separators
    p = normalizeSeparators(p);
    // No trailing slash
    if (!p.endsWith(path.sep)) {
        return p;
    }
    // Check '/' on Linux/macOS and '\' on Windows
    if (p === path.sep) {
        return p;
    }
    // On Windows check if drive root. E.g. C:\
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p)) {
        return p;
    }
    // Otherwise trim trailing slash
    return p.substr(0, p.length - 1);
}
exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
//# sourceMappingURL=internal-path-helper.js.map

/***/ }),

/***/ 6836:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Path = void 0;
const path = __importStar(__nccwpck_require__(1017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const IS_WINDOWS = process.platform === 'win32';
/**
 * Helper class for parsing paths into segments
 */
class Path {
    /**
     * Constructs a Path
     * @param itemPath Path or array of segments
     */
    constructor(itemPath) {
        this.segments = [];
        // String
        if (typeof itemPath === 'string') {
            assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
            // Not rooted
            if (!pathHelper.hasRoot(itemPath)) {
                this.segments = itemPath.split(path.sep);
            }
            // Rooted
            else {
                // Add all segments, while not at the root
                let remaining = itemPath;
                let dir = pathHelper.dirname(remaining);
                while (dir !== remaining) {
                    // Add the segment
                    const basename = path.basename(remaining);
                    this.segments.unshift(basename);
                    // Truncate the last segment
                    remaining = dir;
                    dir = pathHelper.dirname(remaining);
                }
                // Remainder is the root
                this.segments.unshift(remaining);
            }
        }
        // Array
        else {
            // Must not be empty
            assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
            // Each segment
            for (let i = 0; i < itemPath.length; i++) {
                let segment = itemPath[i];
                // Must not be empty
                assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
                // Normalize slashes
                segment = pathHelper.normalizeSeparators(itemPath[i]);
                // Root segment
                if (i === 0 && pathHelper.hasRoot(segment)) {
                    segment = pathHelper.safeTrimTrailingSeparator(segment);
                    assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
                    this.segments.push(segment);
                }
                // All other segments
                else {
                    // Must not contain slash
                    assert_1.default(!segment.includes(path.sep), `Parameter 'itemPath' contains unexpected path separators`);
                    this.segments.push(segment);
                }
            }
        }
    }
    /**
     * Converts the path to it's string representation
     */
    toString() {
        // First segment
        let result = this.segments[0];
        // All others
        let skipSlash = result.endsWith(path.sep) || (IS_WINDOWS && /^[A-Z]:$/i.test(result));
        for (let i = 1; i < this.segments.length; i++) {
            if (skipSlash) {
                skipSlash = false;
            }
            else {
                result += path.sep;
            }
            result += this.segments[i];
        }
        return result;
    }
}
exports.Path = Path;
//# sourceMappingURL=internal-path.js.map

/***/ }),

/***/ 9005:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.partialMatch = exports.match = exports.getSearchPaths = void 0;
const pathHelper = __importStar(__nccwpck_require__(1849));
const internal_match_kind_1 = __nccwpck_require__(1063);
const IS_WINDOWS = process.platform === 'win32';
/**
 * Given an array of patterns, returns an array of paths to search.
 * Duplicates and paths under other included paths are filtered out.
 */
function getSearchPaths(patterns) {
    // Ignore negate patterns
    patterns = patterns.filter(x => !x.negate);
    // Create a map of all search paths
    const searchPathMap = {};
    for (const pattern of patterns) {
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        searchPathMap[key] = 'candidate';
    }
    const result = [];
    for (const pattern of patterns) {
        // Check if already included
        const key = IS_WINDOWS
            ? pattern.searchPath.toUpperCase()
            : pattern.searchPath;
        if (searchPathMap[key] === 'included') {
            continue;
        }
        // Check for an ancestor search path
        let foundAncestor = false;
        let tempKey = key;
        let parent = pathHelper.dirname(tempKey);
        while (parent !== tempKey) {
            if (searchPathMap[parent]) {
                foundAncestor = true;
                break;
            }
            tempKey = parent;
            parent = pathHelper.dirname(tempKey);
        }
        // Include the search pattern in the result
        if (!foundAncestor) {
            result.push(pattern.searchPath);
            searchPathMap[key] = 'included';
        }
    }
    return result;
}
exports.getSearchPaths = getSearchPaths;
/**
 * Matches the patterns against the path
 */
function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
        if (pattern.negate) {
            result &= ~pattern.match(itemPath);
        }
        else {
            result |= pattern.match(itemPath);
        }
    }
    return result;
}
exports.match = match;
/**
 * Checks whether to descend further into the directory
 */
function partialMatch(patterns, itemPath) {
    return patterns.some(x => !x.negate && x.partialMatch(itemPath));
}
exports.partialMatch = partialMatch;
//# sourceMappingURL=internal-pattern-helper.js.map

/***/ }),

/***/ 4536:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pattern = void 0;
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const pathHelper = __importStar(__nccwpck_require__(1849));
const assert_1 = __importDefault(__nccwpck_require__(9491));
const minimatch_1 = __nccwpck_require__(3973);
const internal_match_kind_1 = __nccwpck_require__(1063);
const internal_path_1 = __nccwpck_require__(6836);
const IS_WINDOWS = process.platform === 'win32';
class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
        /**
         * Indicates whether matches should be excluded from the result set
         */
        this.negate = false;
        // Pattern overload
        let pattern;
        if (typeof patternOrNegate === 'string') {
            pattern = patternOrNegate.trim();
        }
        // Segments overload
        else {
            // Convert to pattern
            segments = segments || [];
            assert_1.default(segments.length, `Parameter 'segments' must not empty`);
            const root = Pattern.getLiteral(segments[0]);
            assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
            pattern = new internal_path_1.Path(segments).toString().trim();
            if (patternOrNegate) {
                pattern = `!${pattern}`;
            }
        }
        // Negate
        while (pattern.startsWith('!')) {
            this.negate = !this.negate;
            pattern = pattern.substr(1).trim();
        }
        // Normalize slashes and ensures absolute root
        pattern = Pattern.fixupPattern(pattern, homedir);
        // Segments
        this.segments = new internal_path_1.Path(pattern).segments;
        // Trailing slash indicates the pattern should only match directories, not regular files
        this.trailingSeparator = pathHelper
            .normalizeSeparators(pattern)
            .endsWith(path.sep);
        pattern = pathHelper.safeTrimTrailingSeparator(pattern);
        // Search path (literal path prior to the first glob segment)
        let foundGlob = false;
        const searchSegments = this.segments
            .map(x => Pattern.getLiteral(x))
            .filter(x => !foundGlob && !(foundGlob = x === ''));
        this.searchPath = new internal_path_1.Path(searchSegments).toString();
        // Root RegExp (required when determining partial match)
        this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? 'i' : '');
        this.isImplicitPattern = isImplicitPattern;
        // Create minimatch
        const minimatchOptions = {
            dot: true,
            nobrace: true,
            nocase: IS_WINDOWS,
            nocomment: true,
            noext: true,
            nonegate: true
        };
        pattern = IS_WINDOWS ? pattern.replace(/\\/g, '/') : pattern;
        this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    /**
     * Matches the pattern against the specified path
     */
    match(itemPath) {
        // Last segment is globstar?
        if (this.segments[this.segments.length - 1] === '**') {
            // Normalize slashes
            itemPath = pathHelper.normalizeSeparators(itemPath);
            // Append a trailing slash. Otherwise Minimatch will not match the directory immediately
            // preceding the globstar. For example, given the pattern `/foo/**`, Minimatch returns
            // false for `/foo` but returns true for `/foo/`. Append a trailing slash to handle that quirk.
            if (!itemPath.endsWith(path.sep) && this.isImplicitPattern === false) {
                // Note, this is safe because the constructor ensures the pattern has an absolute root.
                // For example, formats like C: and C:foo on Windows are resolved to an absolute root.
                itemPath = `${itemPath}${path.sep}`;
            }
        }
        else {
            // Normalize slashes and trim unnecessary trailing slash
            itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        }
        // Match
        if (this.minimatch.match(itemPath)) {
            return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
        }
        return internal_match_kind_1.MatchKind.None;
    }
    /**
     * Indicates whether the pattern may match descendants of the specified path
     */
    partialMatch(itemPath) {
        // Normalize slashes and trim unnecessary trailing slash
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        // matchOne does not handle root path correctly
        if (pathHelper.dirname(itemPath) === itemPath) {
            return this.rootRegExp.test(itemPath);
        }
        return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    /**
     * Escapes glob patterns within a path
     */
    static globEscape(s) {
        return (IS_WINDOWS ? s : s.replace(/\\/g, '\\\\')) // escape '\' on Linux/macOS
            .replace(/(\[)(?=[^/]+\])/g, '[[]') // escape '[' when ']' follows within the path segment
            .replace(/\?/g, '[?]') // escape '?'
            .replace(/\*/g, '[*]'); // escape '*'
    }
    /**
     * Normalizes slashes and ensures absolute root
     */
    static fixupPattern(pattern, homedir) {
        // Empty
        assert_1.default(pattern, 'pattern cannot be empty');
        // Must not contain `.` segment, unless first segment
        // Must not contain `..` segment
        const literalSegments = new internal_path_1.Path(pattern).segments.map(x => Pattern.getLiteral(x));
        assert_1.default(literalSegments.every((x, i) => (x !== '.' || i === 0) && x !== '..'), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
        // Must not contain globs in root, e.g. Windows UNC path \\foo\b*r
        assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
        // Normalize slashes
        pattern = pathHelper.normalizeSeparators(pattern);
        // Replace leading `.` segment
        if (pattern === '.' || pattern.startsWith(`.${path.sep}`)) {
            pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
        }
        // Replace leading `~` segment
        else if (pattern === '~' || pattern.startsWith(`~${path.sep}`)) {
            homedir = homedir || os.homedir();
            assert_1.default(homedir, 'Unable to determine HOME directory');
            assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
            pattern = Pattern.globEscape(homedir) + pattern.substr(1);
        }
        // Replace relative drive root, e.g. pattern is C: or C:foo
        else if (IS_WINDOWS &&
            (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', pattern.substr(0, 2));
            if (pattern.length > 2 && !root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(2);
        }
        // Replace relative root, e.g. pattern is \ or \foo
        else if (IS_WINDOWS && (pattern === '\\' || pattern.match(/^\\[^\\]/))) {
            let root = pathHelper.ensureAbsoluteRoot('C:\\dummy-root', '\\');
            if (!root.endsWith('\\')) {
                root += '\\';
            }
            pattern = Pattern.globEscape(root) + pattern.substr(1);
        }
        // Otherwise ensure absolute root
        else {
            pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
        }
        return pathHelper.normalizeSeparators(pattern);
    }
    /**
     * Attempts to unescape a pattern segment to create a literal path segment.
     * Otherwise returns empty string.
     */
    static getLiteral(segment) {
        let literal = '';
        for (let i = 0; i < segment.length; i++) {
            const c = segment[i];
            // Escape
            if (c === '\\' && !IS_WINDOWS && i + 1 < segment.length) {
                literal += segment[++i];
                continue;
            }
            // Wildcard
            else if (c === '*' || c === '?') {
                return '';
            }
            // Character set
            else if (c === '[' && i + 1 < segment.length) {
                let set = '';
                let closed = -1;
                for (let i2 = i + 1; i2 < segment.length; i2++) {
                    const c2 = segment[i2];
                    // Escape
                    if (c2 === '\\' && !IS_WINDOWS && i2 + 1 < segment.length) {
                        set += segment[++i2];
                        continue;
                    }
                    // Closed
                    else if (c2 === ']') {
                        closed = i2;
                        break;
                    }
                    // Otherwise
                    else {
                        set += c2;
                    }
                }
                // Closed?
                if (closed >= 0) {
                    // Cannot convert
                    if (set.length > 1) {
                        return '';
                    }
                    // Convert to literal
                    if (set) {
                        literal += set;
                        i = closed;
                        continue;
                    }
                }
                // Otherwise fall thru
            }
            // Append
            literal += c;
        }
        return literal;
    }
    /**
     * Escapes regexp special characters
     * https://javascript.info/regexp-escaping
     */
    static regExpEscape(s) {
        return s.replace(/[[\\^$.|?*+()]/g, '\\$&');
    }
}
exports.Pattern = Pattern;
//# sourceMappingURL=internal-pattern.js.map

/***/ }),

/***/ 9117:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchState = void 0;
class SearchState {
    constructor(path, level) {
        this.path = path;
        this.level = level;
    }
}
exports.SearchState = SearchState;
//# sourceMappingURL=internal-search-state.js.map

/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 3803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(7147);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 8838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
if (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {
    throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),

/***/ 5667:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.scandirSync = exports.scandir = void 0;
const async = __nccwpck_require__(4507);
const sync = __nccwpck_require__(9560);
const settings_1 = __nccwpck_require__(8662);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 4507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(109);
const rpl = __nccwpck_require__(5288);
const constants_1 = __nccwpck_require__(8838);
const utils = __nccwpck_require__(6297);
const common = __nccwpck_require__(3847);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
    }
    readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
            callSuccessCallback(callback, entries);
            return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            done(null, entry);
            return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    done(statError);
                    return;
                }
                done(null, entry);
                return;
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            callFailureCallback(callback, readdirError);
            return;
        }
        const tasks = names.map((name) => {
            const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
            return (done) => {
                fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
                    if (error !== null) {
                        done(error);
                        return;
                    }
                    const entry = {
                        name,
                        path,
                        dirent: utils.fs.createDirentFromStats(name, stats)
                    };
                    if (settings.stats) {
                        entry.stats = stats;
                    }
                    done(null, entry);
                });
            };
        });
        rpl(tasks, (rplError, entries) => {
            if (rplError !== null) {
                callFailureCallback(callback, rplError);
                return;
            }
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 3847:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = void 0;
function joinPathSegments(a, b, separator) {
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 9560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
const fsStat = __nccwpck_require__(109);
const constants_1 = __nccwpck_require__(8838);
const utils = __nccwpck_require__(6297);
const common = __nccwpck_require__(3847);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),

/***/ 8662:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(1017);
const fsStat = __nccwpck_require__(109);
const fs = __nccwpck_require__(3803);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 883:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 6297:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fs = void 0;
const fs = __nccwpck_require__(883);
exports.fs = fs;


/***/ }),

/***/ 2987:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(7147);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),

/***/ 109:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statSync = exports.stat = exports.Settings = void 0;
const async = __nccwpck_require__(4147);
const sync = __nccwpck_require__(4527);
const settings_1 = __nccwpck_require__(2410);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 4147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            callFailureCallback(callback, lstatError);
            return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback(callback, lstat);
            return;
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    callFailureCallback(callback, statError);
                    return;
                }
                callSuccessCallback(callback, lstat);
                return;
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),

/***/ 4527:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.read = void 0;
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),

/***/ 2410:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __nccwpck_require__(2987);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 6026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
const async_1 = __nccwpck_require__(7523);
const stream_1 = __nccwpck_require__(6737);
const sync_1 = __nccwpck_require__(3068);
const settings_1 = __nccwpck_require__(141);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),

/***/ 7523:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __nccwpck_require__(5732);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.push(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
    }
}
exports["default"] = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),

/***/ 6737:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2781);
const async_1 = __nccwpck_require__(5732);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: () => {
                if (!this._reader.isDestroyed) {
                    this._reader.destroy();
                }
            }
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports["default"] = StreamProvider;


/***/ }),

/***/ 3068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(3595);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports["default"] = SyncProvider;


/***/ }),

/***/ 5732:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __nccwpck_require__(2361);
const fsScandir = __nccwpck_require__(5667);
const fastq = __nccwpck_require__(7340);
const common = __nccwpck_require__(7988);
const reader_1 = __nccwpck_require__(8311);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                done(error, undefined);
                return;
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports["default"] = AsyncReader;


/***/ }),

/***/ 7988:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[/\\]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    /**
     * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
     */
    if (a.endsWith(separator)) {
        return a + b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),

/***/ 8311:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __nccwpck_require__(7988);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports["default"] = Reader;


/***/ }),

/***/ 3595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __nccwpck_require__(5667);
const common = __nccwpck_require__(7988);
const reader_1 = __nccwpck_require__(8311);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.push(entry);
    }
}
exports["default"] = SyncReader;


/***/ }),

/***/ 141:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(1017);
const fsScandir = __nccwpck_require__(5667);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 2206:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventAlgorithm_1 = __nccwpck_require__(8217);
/**
 * Adds an algorithm to the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */
function abort_add(algorithm, signal) {
    /**
     * 1. If signalâ€™s aborted flag is set, then return.
     * 2. Append algorithm to signalâ€™s abort algorithms.
     */
    if (signal._abortedFlag)
        return;
    signal._abortAlgorithms.add(algorithm);
}
exports.abort_add = abort_add;
/**
 * Removes an algorithm from the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */
function abort_remove(algorithm, signal) {
    /**
     * To remove an algorithm algorithm from an AbortSignal signal, remove
     * algorithm from signalâ€™s abort algorithms.
     */
    signal._abortAlgorithms.delete(algorithm);
}
exports.abort_remove = abort_remove;
/**
 * Signals abort on the given abort signal.
 *
 * @param signal - abort signal
 */
function abort_signalAbort(signal) {
    var e_1, _a;
    /**
     * 1. If signalâ€™s aborted flag is set, then return.
     * 2. Set signalâ€™s aborted flag.
     * 3. For each algorithm in signalâ€™s abort algorithms: run algorithm.
     * 4. Empty signalâ€™s abort algorithms.
     * 5. Fire an event named abort at signal.
     */
    if (signal._abortedFlag)
        return;
    signal._abortedFlag = true;
    try {
        for (var _b = __values(signal._abortAlgorithms), _c = _b.next(); !_c.done; _c = _b.next()) {
            var algorithm = _c.value;
            algorithm.call(signal);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    signal._abortAlgorithms.clear();
    EventAlgorithm_1.event_fireAnEvent("abort", signal);
}
exports.abort_signalAbort = abort_signalAbort;
//# sourceMappingURL=AbortAlgorithm.js.map

/***/ }),

/***/ 4309:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ElementAlgorithm_1 = __nccwpck_require__(3220);
/**
 * Changes the value of an existing attribute.
 *
 * @param attribute - an attribute node
 * @param value - attribute value
 */
function attr_setAnExistingAttributeValue(attribute, value) {
    /**
     * 1. If attributeâ€™s element is null, then set attributeâ€™s value to value.
     * 2. Otherwise, change attribute from attributeâ€™s element to value.
     */
    if (attribute._element === null) {
        attribute._value = value;
    }
    else {
        ElementAlgorithm_1.element_change(attribute, attribute._element, value);
    }
}
exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue;
//# sourceMappingURL=AttrAlgorithm.js.map

/***/ }),

/***/ 1054:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
/**
 * Defines the position of a boundary point relative to another.
 *
 * @param bp - a boundary point
 * @param relativeTo - a boundary point to compare to
 */
function boundaryPoint_position(bp, relativeTo) {
    var nodeA = bp[0];
    var offsetA = bp[1];
    var nodeB = relativeTo[0];
    var offsetB = relativeTo[1];
    /**
     * 1. Assert: nodeA and nodeB have the same root.
     */
    console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), "Boundary points must share the same root node.");
    /**
     * 2. If nodeA is nodeB, then return equal if offsetA is offsetB, before
     * if offsetA is less than offsetB, and after if offsetA is greater than
     * offsetB.
     */
    if (nodeA === nodeB) {
        if (offsetA === offsetB) {
            return interfaces_1.BoundaryPosition.Equal;
        }
        else if (offsetA < offsetB) {
            return interfaces_1.BoundaryPosition.Before;
        }
        else {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 3. If nodeA is following nodeB, then if the position of (nodeB, offsetB)
     * relative to (nodeA, offsetA) is before, return after, and if it is after,
     * return before.
     */
    if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {
        var pos = boundaryPoint_position([nodeB, offsetB], [nodeA, offsetA]);
        if (pos === interfaces_1.BoundaryPosition.Before) {
            return interfaces_1.BoundaryPosition.After;
        }
        else if (pos === interfaces_1.BoundaryPosition.After) {
            return interfaces_1.BoundaryPosition.Before;
        }
    }
    /**
     * 4. If nodeA is an ancestor of nodeB:
     */
    if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {
        /**
         * 4.1. Let child be nodeB.
         * 4.2. While child is not a child of nodeA, set child to its parent.
         * 4.3. If childâ€™s index is less than offsetA, then return after.
         */
        var child = nodeB;
        while (!TreeAlgorithm_1.tree_isChildOf(nodeA, child)) {
            /* istanbul ignore else */
            if (child._parent !== null) {
                child = child._parent;
            }
        }
        if (TreeAlgorithm_1.tree_index(child) < offsetA) {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 5. Return before.
     */
    return interfaces_1.BoundaryPosition.Before;
}
exports.boundaryPoint_position = boundaryPoint_position;
//# sourceMappingURL=BoundaryPointAlgorithm.js.map

/***/ }),

/***/ 9461:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var DOMException_1 = __nccwpck_require__(3166);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var MutationObserverAlgorithm_1 = __nccwpck_require__(8157);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
/**
 * Replaces character data.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to replace
 * @param data - new data
 */
function characterData_replaceData(node, offset, count, data) {
    var e_1, _a;
    /**
     * 1. Let length be nodeâ€™s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, then set count to length
     * minus offset.
     */
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        count = length - offset;
    }
    /**
     * 4. Queue a mutation record of "characterData" for node with null, null,
     * nodeâ€™s data, Â« Â», Â« Â», null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueMutationRecord("characterData", node, null, null, node._data, [], [], null, null);
    }
    /**
     * 5. Insert data into nodeâ€™s data after offset code units.
     * 6. Let delete offset be offset + dataâ€™s length.
     * 7. Starting from delete offset code units, remove count code units from
     * nodeâ€™s data.
     */
    var newData = node._data.substring(0, offset) + data +
        node._data.substring(offset + count);
    node._data = newData;
    try {
        /**
         * 8. For each live range whose start node is node and start offset is
         * greater than offset but less than or equal to offset plus count, set its
         * start offset to offset.
         * 9. For each live range whose end node is node and end offset is greater
         * than offset but less than or equal to offset plus count, set its end
         * offset to offset.
         * 10. For each live range whose start node is node and start offset is
         * greater than offset plus count, increase its start offset by dataâ€™s
         * length and decrease it by count.
         * 11. For each live range whose end node is node and end offset is greater
         * than offset plus count, increase its end offset by dataâ€™s length and
         * decrease it by count.
         */
        for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
            var range = _c.value;
            if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
                range._start[1] = offset;
            }
            if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
                range._end[1] = offset;
            }
            if (range._start[0] === node && range._start[1] > offset + count) {
                range._start[1] += data.length - count;
            }
            if (range._end[0] === node && range._end[1] > offset + count) {
                range._end[1] += data.length - count;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 12. If node is a Text node and its parent is not null, run the child
     * text content change steps for nodeâ€™s parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node) && node._parent !== null) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node._parent);
        }
    }
}
exports.characterData_replaceData = characterData_replaceData;
/**
 * Returns `count` number of characters from `node`'s data starting at
 * the given `offset`.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to return
 */
function characterData_substringData(node, offset, count) {
    /**
     * 1. Let length be nodeâ€™s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, return a string whose
     * value is the code units from the offsetth code unit to the end of nodeâ€™s
     * data, and then return.
     * 4. Return a string whose value is the code units from the offsetth code
     * unit to the offset+countth code unit in nodeâ€™s data.
     */
    var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        return node._data.substr(offset);
    }
    else {
        return node._data.substr(offset, count);
    }
}
exports.characterData_substringData = characterData_substringData;
//# sourceMappingURL=CharacterDataAlgorithm.js.map

/***/ }),

/***/ 7339:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImplementationImpl_1 = __nccwpck_require__(2197);
var WindowImpl_1 = __nccwpck_require__(9067);
var XMLDocumentImpl_1 = __nccwpck_require__(1685);
var DocumentImpl_1 = __nccwpck_require__(4333);
var AbortControllerImpl_1 = __nccwpck_require__(6461);
var AbortSignalImpl_1 = __nccwpck_require__(22);
var DocumentTypeImpl_1 = __nccwpck_require__(3173);
var ElementImpl_1 = __nccwpck_require__(5975);
var DocumentFragmentImpl_1 = __nccwpck_require__(2585);
var ShadowRootImpl_1 = __nccwpck_require__(1911);
var AttrImpl_1 = __nccwpck_require__(7875);
var TextImpl_1 = __nccwpck_require__(2191);
var CDATASectionImpl_1 = __nccwpck_require__(3977);
var CommentImpl_1 = __nccwpck_require__(930);
var ProcessingInstructionImpl_1 = __nccwpck_require__(9430);
var HTMLCollectionImpl_1 = __nccwpck_require__(3969);
var NodeListImpl_1 = __nccwpck_require__(3728);
var NodeListStaticImpl_1 = __nccwpck_require__(5306);
var NamedNodeMapImpl_1 = __nccwpck_require__(7206);
var RangeImpl_1 = __nccwpck_require__(166);
var NodeIteratorImpl_1 = __nccwpck_require__(1997);
var TreeWalkerImpl_1 = __nccwpck_require__(9261);
var NodeFilterImpl_1 = __nccwpck_require__(2355);
var MutationRecordImpl_1 = __nccwpck_require__(6219);
var DOMTokenListImpl_1 = __nccwpck_require__(5096);
/**
 * Creates a `DOMImplementation`.
 *
 * @param document - associated document
 */
function create_domImplementation(document) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document);
}
exports.create_domImplementation = create_domImplementation;
/**
 * Creates a `Window` node.
 */
function create_window() {
    return WindowImpl_1.WindowImpl._create();
}
exports.create_window = create_window;
/**
 * Creates an `XMLDocument` node.
 */
function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl();
}
exports.create_xmlDocument = create_xmlDocument;
/**
 * Creates a `Document` node.
 */
function create_document() {
    return new DocumentImpl_1.DocumentImpl();
}
exports.create_document = create_document;
/**
 * Creates an `AbortController`.
 */
function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl();
}
exports.create_abortController = create_abortController;
/**
 * Creates an `AbortSignal`.
 */
function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
}
exports.create_abortSignal = create_abortSignal;
/**
 * Creates a `DocumentType` node.
 *
 * @param document - owner document
 * @param name - name of the node
 * @param publicId - `PUBLIC` identifier
 * @param systemId - `SYSTEM` identifier
 */
function create_documentType(document, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document, name, publicId, systemId);
}
exports.create_documentType = create_documentType;
/**
 * Creates a new `Element` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_element(document, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_element = create_element;
/**
 * Creates a new `HTMLElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_htmlElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlElement = create_htmlElement;
/**
 * Creates a new `HTMLUnknownElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */
function create_htmlUnknownElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlUnknownElement = create_htmlUnknownElement;
/**
 * Creates a new `DocumentFragment` node.
 *
 * @param document - owner document
 */
function create_documentFragment(document) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document);
}
exports.create_documentFragment = create_documentFragment;
/**
 * Creates a new `ShadowRoot` node.
 *
 * @param document - owner document
 * @param host - shadow root's host element node
 */
function create_shadowRoot(document, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document, host);
}
exports.create_shadowRoot = create_shadowRoot;
/**
 * Creates a new `Attr` node.
 *
 * @param document - owner document
 * @param localName - local name
 */
function create_attr(document, localName) {
    return AttrImpl_1.AttrImpl._create(document, localName);
}
exports.create_attr = create_attr;
/**
 * Creates a new `Text` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_text(document, data) {
    return TextImpl_1.TextImpl._create(document, data);
}
exports.create_text = create_text;
/**
 * Creates a new `CDATASection` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_cdataSection(document, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document, data);
}
exports.create_cdataSection = create_cdataSection;
/**
 * Creates a new `Comment` node.
 *
 * @param document - owner document
 * @param data - node contents
 */
function create_comment(document, data) {
    return CommentImpl_1.CommentImpl._create(document, data);
}
exports.create_comment = create_comment;
/**
 * Creates a new `ProcessingInstruction` node.
 *
 * @param document - owner document
 * @param target - instruction target
 * @param data - node contents
 */
function create_processingInstruction(document, target, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document, target, data);
}
exports.create_processingInstruction = create_processingInstruction;
/**
 * Creates a new `HTMLCollection`.
 *
 * @param root - root node
 * @param filter - node filter
 */
function create_htmlCollection(root, filter) {
    if (filter === void 0) { filter = (function () { return true; }); }
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
}
exports.create_htmlCollection = create_htmlCollection;
/**
 * Creates a new live `NodeList`.
 *
 * @param root - root node
 */
function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
}
exports.create_nodeList = create_nodeList;
/**
 * Creates a new static `NodeList`.
 *
 * @param root - root node
 * @param items - a list of items to initialize the list
 */
function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
}
exports.create_nodeListStatic = create_nodeListStatic;
/**
 * Creates a new `NamedNodeMap`.
 *
 * @param element - parent element
 */
function create_namedNodeMap(element) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
}
exports.create_namedNodeMap = create_namedNodeMap;
/**
 * Creates a new `Range`.
 *
 * @param start - start point
 * @param end - end point
 */
function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
}
exports.create_range = create_range;
/**
 * Creates a new `NodeIterator`.
 *
 * @param root - iterator's root node
 * @param reference - reference node
 * @param pointerBeforeReference - whether the iterator is before or after the
 * reference node
 */
function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
}
exports.create_nodeIterator = create_nodeIterator;
/**
 * Creates a new `TreeWalker`.
 *
 * @param root - iterator's root node
 * @param current - current node
 */
function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
}
exports.create_treeWalker = create_treeWalker;
/**
 * Creates a new `NodeFilter`.
 */
function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
}
exports.create_nodeFilter = create_nodeFilter;
/**
 * Creates a new `MutationRecord`.
 *
 * @param type - type of mutation: `"attributes"` for an attribute
 * mutation, `"characterData"` for a mutation to a CharacterData node
 * and `"childList"` for a mutation to the tree of nodes.
 * @param target - node affected by the mutation.
 * @param addedNodes - list of added nodes.
 * @param removedNodes - list of removed nodes.
 * @param previousSibling - previous sibling of added or removed nodes.
 * @param nextSibling - next sibling of added or removed nodes.
 * @param attributeName - local name of the changed attribute,
 * and `null` otherwise.
 * @param attributeNamespace - namespace of the changed attribute,
 * and `null` otherwise.
 * @param oldValue - value before mutation: attribute value for an attribute
 * mutation, node `data` for a mutation to a CharacterData node and `null`
 * for a mutation to the tree of nodes.
 */
function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
}
exports.create_mutationRecord = create_mutationRecord;
/**
 * Creates a new `DOMTokenList`.
 *
 * @param element - associated element
 * @param attribute - associated attribute
 */
function create_domTokenList(element, attribute) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);
}
exports.create_domTokenList = create_domTokenList;
//# sourceMappingURL=CreateAlgorithm.js.map

/***/ }),

/***/ 5648:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
var NamesWithHyphen = new Set(['annotation-xml', 'color-profile',
    'font-face', 'font-face-src', 'font-face-uri', 'font-face-format',
    'font-face-name', 'missing-glyph']);
var ElementNames = new Set(['article', 'aside', 'blockquote',
    'body', 'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'header', 'main', 'nav', 'p', 'section', 'span']);
var VoidElementNames = new Set(['area', 'base', 'basefont',
    'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
var ShadowHostNames = new Set(['article', 'aside', 'blockquote', 'body',
    'div', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'main',
    'nav', 'p', 'section', 'span']);
/**
 * Determines if the given string is a valid custom element name.
 *
 * @param name - a name string
 */
function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name))
        return false;
    if (NamesWithHyphen.has(name))
        return false;
    return true;
}
exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
/**
 * Determines if the given string is a valid element name.
 *
 * @param name - a name string
 */
function customElement_isValidElementName(name) {
    return (ElementNames.has(name));
}
exports.customElement_isValidElementName = customElement_isValidElementName;
/**
 * Determines if the given string is a void element name.
 *
 * @param name - a name string
 */
function customElement_isVoidElementName(name) {
    return (VoidElementNames.has(name));
}
exports.customElement_isVoidElementName = customElement_isVoidElementName;
/**
 * Determines if the given string is a valid shadow host element name.
 *
 * @param name - a name string
 */
function customElement_isValidShadowHostName(name) {
    return (ShadowHostNames.has(name));
}
exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
/**
 * Enqueues an upgrade reaction for a custom element.
 *
 * @param element - a custom element
 * @param definition - a custom element definition
 */
function customElement_enqueueACustomElementUpgradeReaction(element, definition) {
    // TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
/**
 * Enqueues a callback reaction for a custom element.
 *
 * @param element - a custom element
 * @param callbackName - name of the callback
 * @param args - callback arguments
 */
function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {
    // TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
/**
 * Upgrade a custom element.
 *
 * @param element - a custom element
 */
function customElement_upgrade(definition, element) {
    // TODO: Implement in HTML DOM
}
exports.customElement_upgrade = customElement_upgrade;
/**
 * Tries to upgrade a custom element.
 *
 * @param element - a custom element
 */
function customElement_tryToUpgrade(element) {
    // TODO: Implement in HTML DOM
}
exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
/**
 * Looks up a custom element definition.
 *
 * @param document - a document
 * @param namespace - element namespace
 * @param localName - element local name
 * @param is - an `is` value
 */
function customElement_lookUpACustomElementDefinition(document, namespace, localName, is) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition;
//# sourceMappingURL=CustomElementAlgorithm.js.map

/***/ }),

/***/ 9628:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var util_1 = __nccwpck_require__(5282);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(8733);
var supportedTokens = new Map();
/**
 * Runs removing steps for node.
 *
 * @param removedNode - removed node
 * @param oldParent - old parent node
 */
function dom_runRemovingSteps(removedNode, oldParent) {
    // No steps defined
}
exports.dom_runRemovingSteps = dom_runRemovingSteps;
/**
 * Runs cloning steps for node.
 *
 * @param copy - node clone
 * @param node - node
 * @param document - document to own the cloned node
 * @param cloneChildrenFlag - whether child nodes are cloned
 */
function dom_runCloningSteps(copy, node, document, cloneChildrenFlag) {
    // No steps defined
}
exports.dom_runCloningSteps = dom_runCloningSteps;
/**
 * Runs adopting steps for node.
 *
 * @param node - node
 * @param oldDocument - old document
 */
function dom_runAdoptingSteps(node, oldDocument) {
    // No steps defined
}
exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
/**
 * Runs attribute change steps for an element node.
 *
 * @param element - element node owning the attribute
 * @param localName - attribute's local name
 * @param oldValue - attribute's old value
 * @param value - attribute's new value
 * @param namespace - attribute's namespace
 */
function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
    var e_1, _a;
    // run default steps
    if (DOMImpl_1.dom.features.slots) {
        updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
        updateASlotsName.call(element, element, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element, element, localName, value, namespace);
    try {
        // run custom steps
        for (var _b = __values(element._attributeChangeSteps), _c = _b.next(); !_c.done; _c = _b.next()) {
            var step = _c.value;
            step.call(element, element, localName, oldValue, value, namespace);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
/**
 * Runs insertion steps for a node.
 *
 * @param insertedNode - inserted node
 */
function dom_runInsertionSteps(insertedNode) {
    // No steps defined
}
exports.dom_runInsertionSteps = dom_runInsertionSteps;
/**
 * Runs pre-removing steps for a node iterator and node.
 *
 * @param nodeIterator - a node iterator
 * @param toBeRemoved - node to be removed
 */
function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
}
exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
/**
 * Determines if there are any supported tokens defined for the given
 * attribute name.
 *
 * @param attributeName - an attribute name
 */
function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
}
exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
/**
 * Returns the set of supported tokens defined for the given attribute name.
 *
 * @param attributeName - an attribute name
 */
function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || new Set();
}
exports.dom_getSupportedTokens = dom_getSupportedTokens;
/**
 * Runs event construction steps.
 *
 * @param event - an event
 */
function dom_runEventConstructingSteps(event) {
    // No steps defined
}
exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
/**
 * Runs child text content change steps for a parent node.
 *
 * @param parent - parent node with text node child nodes
 */
function dom_runChildTextContentChangeSteps(parent) {
    // No steps defined
}
exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
/**
 * Defines pre-removing steps for a node iterator.
 */
function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    /**
     * 1. If toBeRemovedNode is not an inclusive ancestor of nodeIteratorâ€™s
     * reference, or toBeRemovedNode is nodeIteratorâ€™s root, then return.
     */
    if (toBeRemovedNode === nodeIterator._root ||
        !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {
        return;
    }
    /**
     * 2. If nodeIteratorâ€™s pointer before reference is true, then:
     */
    if (nodeIterator._pointerBeforeReference) {
        /**
         * 2.1. Let next be toBeRemovedNodeâ€™s first following node that is an
         * inclusive descendant of nodeIteratorâ€™s root and is not an inclusive
         * descendant of toBeRemovedNode, and null if there is no such node.
         */
        while (true) {
            var nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);
            if (nextNode !== null &&
                TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) &&
                !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {
                /**
                 * 2.2. If next is non-null, then set nodeIteratorâ€™s reference to next
                 * and return.
                 */
                nodeIterator._reference = nextNode;
                return;
            }
            else if (nextNode === null) {
                /**
                 * 2.3. Otherwise, set nodeIteratorâ€™s pointer before reference to false.
                 */
                nodeIterator._pointerBeforeReference = false;
                return;
            }
        }
    }
    /**
     * 3. Set nodeIteratorâ€™s reference to toBeRemovedNodeâ€™s parent, if
     * toBeRemovedNodeâ€™s previous sibling is null, and to the inclusive
     * descendant of toBeRemovedNodeâ€™s previous sibling that appears last in
     * tree order otherwise.
     */
    if (toBeRemovedNode._previousSibling === null) {
        if (toBeRemovedNode._parent !== null) {
            nodeIterator._reference = toBeRemovedNode._parent;
        }
    }
    else {
        var referenceNode = toBeRemovedNode._previousSibling;
        var childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);
        while (childNode !== null) {
            if (childNode !== null) {
                referenceNode = childNode;
            }
            // loop through to get the last descendant node
            childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);
        }
        nodeIterator._reference = referenceNode;
    }
}
/**
 * Defines attribute change steps to update a slotâ€™s name.
 */
function updateASlotsName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If element is a slot, localName is name, and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set elementâ€™s name to the
     * empty string.
     * 1.5. Otherwise, set elementâ€™s name to value.
     * 1.6. Run assign slotables for a tree with elementâ€™s root.
     */
    if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
        if (value === oldValue)
            return;
        if (value === null && oldValue === '')
            return;
        if (value === '' && oldValue === null)
            return;
        if ((value === null || value === '')) {
            element._name = '';
        }
        else {
            element._name = value;
        }
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element));
    }
}
/**
 * Defines attribute change steps to update a slotableâ€™s name.
 */
function updateASlotablesName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If localName is slot and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set elementâ€™s name to
     * the empty string.
     * 1.5. Otherwise, set elementâ€™s name to value.
     * 1.6. If element is assigned, then run assign slotables for elementâ€™s
     * assigned slot.
     * 1.7. Run assign a slot for element.
     */
    if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
        if (value === oldValue)
            return;
        if (value === null && oldValue === '')
            return;
        if (value === '' && oldValue === null)
            return;
        if ((value === null || value === '')) {
            element._name = '';
        }
        else {
            element._name = value;
        }
        if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element._assignedSlot);
        }
        ShadowTreeAlgorithm_1.shadowTree_assignASlot(element);
    }
}
/**
 * Defines attribute change steps to update an element's ID.
 */
function updateAnElementID(element, localName, value, namespace) {
    /**
     * 1. If localName is id, namespace is null, and value is null or the empty
     * string, then unset elementâ€™s ID.
     * 2. Otherwise, if localName is id, namespace is null, then set elementâ€™s
     * ID to value.
     */
    if (localName === "id" && namespace === null) {
        if (!value)
            element._uniqueIdentifier = undefined;
        else
            element._uniqueIdentifier = value;
    }
}
//# sourceMappingURL=DOMAlgorithm.js.map

/***/ }),

/***/ 3261:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var OrderedSetAlgorithm_1 = __nccwpck_require__(3670);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
var ElementAlgorithm_1 = __nccwpck_require__(3220);
/**
 * Validates a given token against the supported tokens defined for the given
 * token lists' associated attribute.
 *
 * @param tokenList - a token list
 * @param token - a token
 */
function tokenList_validationSteps(tokenList, token) {
    /**
     * 1. If the associated attributeâ€™s local name does not define supported
     * tokens, throw a TypeError.
     * 2. Let lowercase token be a copy of token, in ASCII lowercase.
     * 3. If lowercase token is present in supported tokens, return true.
     * 4. Return false.
     */
    if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {
        throw new TypeError("There are no supported tokens defined for attribute name: '" + tokenList._attribute._localName + "'.");
    }
    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());
}
exports.tokenList_validationSteps = tokenList_validationSteps;
/**
 * Updates the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */
function tokenList_updateSteps(tokenList) {
    /**
     * 1. If the associated element does not have an associated attribute and
     * token set is empty, then return.
     * 2. Set an attribute value for the associated element using associated
     * attributeâ€™s local name and the result of running the ordered set
     * serializer for token set.
     */
    if (!tokenList._element.hasAttribute(tokenList._attribute._localName) &&
        tokenList._tokenSet.size === 0) {
        return;
    }
    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));
}
exports.tokenList_updateSteps = tokenList_updateSteps;
/**
 * Gets the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */
function tokenList_serializeSteps(tokenList) {
    /**
     * A DOMTokenList objectâ€™s serialize steps are to return the result of
     * running get an attribute value given the associated element and the
     * associated attributeâ€™s local name.
     */
    return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);
}
exports.tokenList_serializeSteps = tokenList_serializeSteps;
//# sourceMappingURL=DOMTokenListAlgorithm.js.map

/***/ }),

/***/ 2793:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var util_2 = __nccwpck_require__(6195);
var ElementImpl_1 = __nccwpck_require__(5975);
var CustomElementAlgorithm_1 = __nccwpck_require__(5648);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var NamespaceAlgorithm_1 = __nccwpck_require__(5856);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
var ElementAlgorithm_1 = __nccwpck_require__(3220);
var MutationAlgorithm_1 = __nccwpck_require__(5463);
/**
 * Returns an element interface for the given name and namespace.
 *
 * @param name - element name
 * @param namespace - namespace
 */
function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
}
exports.document_elementInterface = document_elementInterface;
/**
 * Creates a new element node.
 * See: https://dom.spec.whatwg.org/#internal-createelementns-steps
 *
 * @param document - owner document
 * @param namespace - element namespace
 * @param qualifiedName - qualified name
 * @param options - element options
 */
function document_internalCreateElementNS(document, namespace, qualifiedName, options) {
    /**
     * 1. Let namespace, prefix, and localName be the result of passing
     * namespace and qualifiedName to validate and extract.
     * 2. Let is be null.
     * 3. If options is a dictionary and optionsâ€™s is is present, then set
     * is to it.
     * 4. Return the result of creating an element given document, localName,
     * namespace, prefix, is, and with the synchronous custom elements flag set.
     */
    var _a = __read(NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
    var is = null;
    if (options !== undefined) {
        if (util_2.isString(options)) {
            is = options;
        }
        else {
            is = options.is;
        }
    }
    return ElementAlgorithm_1.element_createAnElement(document, localName, ns, prefix, is, true);
}
exports.document_internalCreateElementNS = document_internalCreateElementNS;
/**
 * Removes `node` and its subtree from its document and changes
 * its owner document to `document` so that it can be inserted
 * into `document`.
 *
 * @param node - the node to move
 * @param document - document to receive the node and its subtree
 */
function document_adopt(node, document) {
    var e_1, _a;
    // Optimize for common case of inserting a fresh node
    if (node._nodeDocument === document && node._parent === null) {
        return;
    }
    /**
     * 1. Let oldDocument be nodeâ€™s node document.
     * 2. If nodeâ€™s parent is not null, remove node from its parent.
     */
    var oldDocument = node._nodeDocument;
    if (node._parent)
        MutationAlgorithm_1.mutation_remove(node, node._parent);
    /**
     * 3. If document is not oldDocument, then:
     */
    if (document !== oldDocument) {
        /**
         * 3.1. For each inclusiveDescendant in nodeâ€™s shadow-including inclusive
         * descendants:
         */
        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, true);
        while (inclusiveDescendant !== null) {
            /**
             * 3.1.1. Set inclusiveDescendantâ€™s node document to document.
             * 3.1.2. If inclusiveDescendant is an element, then set the node
             * document of each attribute in inclusiveDescendantâ€™s attribute list
             * to document.
             */
            inclusiveDescendant._nodeDocument = document;
            if (util_1.Guard.isElementNode(inclusiveDescendant)) {
                try {
                    for (var _b = (e_1 = void 0, __values(inclusiveDescendant._attributeList._asArray())), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var attr = _c.value;
                        attr._nodeDocument = document;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            /**
             * 3.2. For each inclusiveDescendant in node's shadow-including
             * inclusive descendants that is custom, enqueue a custom
             * element callback reaction with inclusiveDescendant,
             * callback name "adoptedCallback", and an argument list
             * containing oldDocument and document.
             */
            if (DOMImpl_1.dom.features.customElements) {
                if (util_1.Guard.isElementNode(inclusiveDescendant) &&
                    inclusiveDescendant._customElementState === "custom") {
                    CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "adoptedCallback", [oldDocument, document]);
                }
            }
            /**
             * 3.3. For each inclusiveDescendant in nodeâ€™s shadow-including
             * inclusive descendants, in shadow-including tree order, run the
             * adopting steps with inclusiveDescendant and oldDocument.
             */
            if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, inclusiveDescendant, true, true);
        }
    }
}
exports.document_adopt = document_adopt;
//# sourceMappingURL=DocumentAlgorithm.js.map

/***/ }),

/***/ 3220:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var infra_1 = __nccwpck_require__(4251);
var util_1 = __nccwpck_require__(5282);
var DOMException_1 = __nccwpck_require__(3166);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
var CustomElementAlgorithm_1 = __nccwpck_require__(5648);
var MutationObserverAlgorithm_1 = __nccwpck_require__(8157);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
var MutationAlgorithm_1 = __nccwpck_require__(5463);
var DocumentAlgorithm_1 = __nccwpck_require__(2793);
/**
 * Determines whether the element's attribute list contains the given
 * attribute.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 */
function element_has(attribute, element) {
    /**
     * An element has an attribute A if its attribute list contains A.
     */
    return element._attributeList._asArray().indexOf(attribute) !== -1;
}
exports.element_has = element_has;
/**
 * Changes the value of an attribute node.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 * @param value - attribute value
 */
function element_change(attribute, element, value) {
    /**
     * 1. Queue an attribute mutation record for element with attributeâ€™s
     * local name, attributeâ€™s namespace, and attributeâ€™s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attributeâ€™s local name, attributeâ€™s value, value, and
     * attributeâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, value, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attributeâ€™s local name,
     * attributeâ€™s value, value, and attributeâ€™s namespace.
     * 4. Set attributeâ€™s value to value.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, value, attribute._namespace);
    }
    attribute._value = value;
}
exports.element_change = element_change;
/**
 * Appends an attribute to an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */
function element_append(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attributeâ€™s
     * local name, attributeâ€™s namespace, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, null);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attributeâ€™s local name, null, attributeâ€™s value, and
     * attributeâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, null, attribute._value, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attributeâ€™s local name,
     * null, attributeâ€™s value, and attributeâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, null, attribute._value, attribute._namespace);
    }
    /**
     * 4. Append attribute to elementâ€™s attribute list.
     * 5. Set attributeâ€™s element to element.
     */
    element._attributeList._asArray().push(attribute);
    attribute._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null ||
        attribute._namespacePrefix !== null || attribute._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_append = element_append;
/**
 * Removes an attribute from an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */
function element_remove(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attributeâ€™s
     * local name, attributeâ€™s namespace, and attributeâ€™s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attributeâ€™s local name, attributeâ€™s value, null,
     * and attributeâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [attribute._localName, attribute._value, null, attribute._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attributeâ€™s local name,
     * attributeâ€™s value, null, and attributeâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, null, attribute._namespace);
    }
    /**
     * 3. Remove attribute from elementâ€™s attribute list.
     * 5. Set attributeâ€™s element to null.
     */
    var index = element._attributeList._asArray().indexOf(attribute);
    element._attributeList._asArray().splice(index, 1);
    attribute._element = null;
}
exports.element_remove = element_remove;
/**
 * Replaces an attribute with another of an element node.
 *
 * @param oldAttr - old attribute
 * @param newAttr - new attribute
 * @param element - an element to receive the attribute
 */
function element_replace(oldAttr, newAttr, element) {
    /**
     * 1. Queue an attribute mutation record for element with oldAttrâ€™s
     * local name, oldAttrâ€™s namespace, and oldAttrâ€™s value.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing oldAttrâ€™s local name, oldAttrâ€™s value, newAttrâ€™s value,
     * and oldAttrâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, oldAttrâ€™s local name,
     * oldAttrâ€™s value, newAttrâ€™s value, and oldAttrâ€™s namespace.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    /**
     * 4. Replace oldAttr by newAttr in elementâ€™s attribute list.
     * 5. Set oldAttrâ€™s element to null.
     * 6. Set newAttrâ€™s element to element.
     */
    var index = element._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
        element._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null ||
        newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_replace = element_replace;
/**
 * Retrieves an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */
function element_getAnAttributeByName(qualifiedName, element) {
    /**
     * 1. If element is in the HTML namespace and its node document is an HTML
     * document, then set qualifiedName to qualifiedName in ASCII lowercase.
     * 2. Return the first attribute in elementâ€™s attribute list whose qualified
     * name is qualifiedName, and null otherwise.
     */
    if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
    }
    return element._attributeList._asArray().find(function (attr) { return attr._qualifiedName === qualifiedName; }) || null;
}
exports.element_getAnAttributeByName = element_getAnAttributeByName;
/**
 * Retrieves an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */
function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Return the attribute in elementâ€™s attribute list whose namespace is
     * namespace and local name is localName, if any, and null otherwise.
     */
    var ns = namespace || null;
    return element._attributeList._asArray().find(function (attr) { return attr._namespace === ns && attr._localName === localName; }) || null;
}
exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
/**
 * Retrieves an attribute's value with the given name namespace and local
 * name from an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param namespace - an attribute namespace
 */
function element_getAnAttributeValue(element, localName, namespace) {
    if (namespace === void 0) { namespace = ''; }
    /**
     * 1. Let attr be the result of getting an attribute given namespace,
     * localName, and element.
     * 2. If attr is null, then return the empty string.
     * 3. Return attrâ€™s value.
     */
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr === null)
        return '';
    else
        return attr._value;
}
exports.element_getAnAttributeValue = element_getAnAttributeValue;
/**
 * Sets an attribute of an element node.
 *
 * @param attr - an attribute
 * @param element - an element to receive the attribute
 */
function element_setAnAttribute(attr, element) {
    /**
     * 1. If attrâ€™s element is neither null nor element, throw an
     * "InUseAttributeError" DOMException.
     * 2. Let oldAttr be the result of getting an attribute given attrâ€™s
     * namespace, attrâ€™s local name, and element.
     * 3. If oldAttr is attr, return attr.
     * 4. If oldAttr is non-null, replace it by attr in element.
     * 5. Otherwise, append attr to element.
     * 6. Return oldAttr.
     */
    if (attr._element !== null && attr._element !== element)
        throw new DOMException_1.InUseAttributeError("This attribute already exists in the document: " + attr._qualifiedName + " as a child of " + attr._element._qualifiedName + ".");
    var oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || '', attr._localName, element);
    if (oldAttr === attr)
        return attr;
    if (oldAttr !== null) {
        element_replace(oldAttr, attr, element);
    }
    else {
        element_append(attr, element);
    }
    return oldAttr;
}
exports.element_setAnAttribute = element_setAnAttribute;
/**
 * Sets an attribute's value of an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param value - an attribute value
 * @param prefix - an attribute prefix
 * @param namespace - an attribute namespace
 */
function element_setAnAttributeValue(element, localName, value, prefix, namespace) {
    if (prefix === void 0) { prefix = null; }
    if (namespace === void 0) { namespace = null; }
    /**
     * 1. If prefix is not given, set it to null.
     * 2. If namespace is not given, set it to null.
     * 3. Let attribute be the result of getting an attribute given namespace,
     * localName, and element.
     * 4. If attribute is null, create an attribute whose namespace is
     * namespace, namespace prefix is prefix, local name is localName, value
     * is value, and node document is elementâ€™s node document, then append this
     * attribute to element, and then return.
     * 5. Change attribute from element to value.
     */
    var attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, element);
    if (attribute === null) {
        var newAttr = CreateAlgorithm_1.create_attr(element._nodeDocument, localName);
        newAttr._namespace = namespace;
        newAttr._namespacePrefix = prefix;
        newAttr._value = value;
        element_append(newAttr, element);
        return;
    }
    element_change(attribute, element, value);
}
exports.element_setAnAttributeValue = element_setAnAttributeValue;
/**
 * Removes an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */
function element_removeAnAttributeByName(qualifiedName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given qualifiedName
     * and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */
    var attr = element_getAnAttributeByName(qualifiedName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
/**
 * Removes an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */
function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given namespace, localName, and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */
    var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
/**
 * Creates an element node.
 * See: https://dom.spec.whatwg.org/#concept-create-element.
 *
 * @param document - the document owning the element
 * @param localName - local name
 * @param namespace - element namespace
 * @param prefix - namespace prefix
 * @param is - the "is" value
 * @param synchronousCustomElementsFlag - synchronous custom elements flag
 */
function element_createAnElement(document, localName, namespace, prefix, is, synchronousCustomElementsFlag) {
    if (prefix === void 0) { prefix = null; }
    if (is === void 0) { is = null; }
    if (synchronousCustomElementsFlag === void 0) { synchronousCustomElementsFlag = false; }
    /**
     * 1. If prefix was not given, let prefix be null.
     * 2. If is was not given, let is be null.
     * 3. Let result be null.
     */
    var result = null;
    if (!DOMImpl_1.dom.features.customElements) {
        result = CreateAlgorithm_1.create_element(document, localName, namespace, prefix);
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        return result;
    }
    /**
     * 4. Let definition be the result of looking up a custom element definition
     * given document, namespace, localName, and is.
     */
    var definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
        /**
        * 5. If definition is non-null, and definitionâ€™s name is not equal to
        * its local name (i.e., definition represents a customized built-in
        * element), then:
          * 5.1. Let interface be the element interface for localName and the HTML
          * namespace.
          * 5.2. Set result to a new element that implements interface, with no
          * attributes, namespace set to the HTML namespace, namespace prefix
          * set to prefix, local name set to localName, custom element state set
          * to "undefined", custom element definition set to null, is value set
          * to is, and node document set to document.
          * 5.3. If the synchronous custom elements flag is set, upgrade element
          * using definition.
          * 5.4. Otherwise, enqueue a custom element upgrade reaction given result
          * and definition.
          */
        var elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);
        result = new elemenInterface();
        result._localName = localName;
        result._namespace = infra_1.namespace.HTML;
        result._namespacePrefix = prefix;
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        if (synchronousCustomElementsFlag) {
            CustomElementAlgorithm_1.customElement_upgrade(definition, result);
        }
        else {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    }
    else if (definition !== null) {
        /**
         * 6. Otherwise, if definition is non-null, then:
         */
        if (synchronousCustomElementsFlag) {
            /**
             * 6.1. If the synchronous custom elements flag is set, then run these
             * steps while catching any exceptions:
             */
            try {
                /**
                 * 6.1.1. Let C be definitionâ€™s constructor.
                 * 6.1.2. Set result to the result of constructing C, with no arguments.
                 * 6.1.3. Assert: resultâ€™s custom element state and custom element definition
                 * are initialized.
                 * 6.1.4. Assert: resultâ€™s namespace is the HTML namespace.
                 * _Note:_ IDL enforces that result is an HTMLElement object, which all
                 * use the HTML namespace.
                 */
                var C = definition.constructor;
                var result_1 = new C();
                console.assert(result_1._customElementState !== undefined);
                console.assert(result_1._customElementDefinition !== undefined);
                console.assert(result_1._namespace === infra_1.namespace.HTML);
                /**
                 * 6.1.5. If resultâ€™s attribute list is not empty, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.6. If result has children, then throw a "NotSupportedError"
                 * DOMException.
                 * 6.1.7. If resultâ€™s parent is not null, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.8. If resultâ€™s node document is not document, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.9. If resultâ€™s local name is not equal to localName, then throw
                 * a "NotSupportedError" DOMException.
                 */
                if (result_1._attributeList.length !== 0)
                    throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
                if (result_1._children.size !== 0)
                    throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
                if (result_1._parent !== null)
                    throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
                if (result_1._nodeDocument !== document)
                    throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
                if (result_1._localName !== localName)
                    throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
                /**
                 * 6.1.10. Set resultâ€™s namespace prefix to prefix.
                 * 6.1.11. Set resultâ€™s is value to null.
                 */
                result_1._namespacePrefix = prefix;
                result_1._is = null;
            }
            catch (e) {
                /**
                 * If any of these steps threw an exception, then:
                 * - Report the exception.
                 * - Set result to a new element that implements the HTMLUnknownElement
                 * interface, with no attributes, namespace set to the HTML namespace,
                 * namespace prefix set to prefix, local name set to localName, custom
                 * element state set to "failed", custom element definition set to null,
                 * is value set to null, and node document set to document.
                 */
                // TODO: Report the exception
                result = CreateAlgorithm_1.create_htmlUnknownElement(document, localName, infra_1.namespace.HTML, prefix);
                result._customElementState = "failed";
                result._customElementDefinition = null;
                result._is = null;
            }
        }
        else {
            /**
             * 6.2. Otherwise:
             * 6.2.1. Set result to a new element that implements the HTMLElement
             * interface, with no attributes, namespace set to the HTML namespace,
             * namespace prefix set to prefix, local name set to localName, custom
             * element state set to "undefined", custom element definition set to
             * null, is value set to null, and node document set to document.
             * 6.2.2. Enqueue a custom element upgrade reaction given result and
             * definition.
             */
            result = CreateAlgorithm_1.create_htmlElement(document, localName, infra_1.namespace.HTML, prefix);
            result._customElementState = "undefined";
            result._customElementDefinition = null;
            result._is = null;
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    }
    else {
        /**
         * 7. Otherwise:
         * 7.1. Let interface be the element interface for localName and
         * namespace.
         * 7.2. Set result to a new element that implements interface, with no
         * attributes, namespace set to namespace, namespace prefix set to prefix,
         * local name set to localName, custom element state set to
         * "uncustomized", custom element definition set to null, is value set to
         * is, and node document set to document.
         */
        var elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);
        result = new elementInterface();
        result._localName = localName;
        result._namespace = namespace;
        result._namespacePrefix = prefix;
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        /**
         * 7.3. If namespace is the HTML namespace, and either localName is a
         * valid custom element name or is is non-null, then set resultâ€™s
         * custom element state to "undefined".
         */
        if (namespace === infra_1.namespace.HTML && (is !== null ||
            CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {
            result._customElementState = "undefined";
        }
    }
    /* istanbul ignore next */
    if (result === null) {
        throw new Error("Unable to create element.");
    }
    /**
     * 8. Returns result
     */
    return result;
}
exports.element_createAnElement = element_createAnElement;
/**
 * Inserts a new node adjacent to this element.
 *
 * @param element - a reference element
 * @param where - a string defining where to insert the element node.
 *   - `beforebegin` before this element itself.
 *   - `afterbegin` before the first child.
 *   - `beforeend` after the last child.
 *   - `afterend` after this element itself.
 * @param node - node to insert
 */
function element_insertAdjacent(element, where, node) {
    /**
     * - "beforebegin"
     * If elementâ€™s parent is null, return null.
     * Return the result of pre-inserting node into elementâ€™s parent before
     * element.
     * - "afterbegin"
     * Return the result of pre-inserting node into element before elementâ€™s
     * first child.
     * - "beforeend"
     * Return the result of pre-inserting node into element before null.
     * - "afterend"
     * If elementâ€™s parent is null, return null.
     * Return the result of pre-inserting node into elementâ€™s parent before elementâ€™s next sibling.
     * - Otherwise
     * Throw a "SyntaxError" DOMException.
     */
    switch (where.toLowerCase()) {
        case 'beforebegin':
            if (element._parent === null)
                return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element);
        case 'afterbegin':
            return MutationAlgorithm_1.mutation_preInsert(node, element, element._firstChild);
        case 'beforeend':
            return MutationAlgorithm_1.mutation_preInsert(node, element, null);
        case 'afterend':
            if (element._parent === null)
                return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element._nextSibling);
        default:
            throw new DOMException_1.SyntaxError("Invalid 'where' argument. \"beforebegin\", \"afterbegin\", \"beforeend\" or \"afterend\" expected");
    }
}
exports.element_insertAdjacent = element_insertAdjacent;
//# sourceMappingURL=ElementAlgorithm.js.map

/***/ }),

/***/ 8217:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var interfaces_1 = __nccwpck_require__(7305);
var util_1 = __nccwpck_require__(5282);
var CustomEventImpl_1 = __nccwpck_require__(9857);
var EventImpl_1 = __nccwpck_require__(8245);
var DOMException_1 = __nccwpck_require__(3166);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(8733);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
/**
 * Sets the canceled flag of an event.
 *
 * @param event - an event
 */
function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
        event._canceledFlag = true;
    }
}
exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
/**
 * Initializes the value of an event.
 *
 * @param event - an event to initialize
 * @param type - the type of event
 * @param bubbles - whether the event propagates in reverse
 * @param cancelable - whether the event can be cancelled
 */
function event_initialize(event, type, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
}
exports.event_initialize = event_initialize;
/**
 * Creates a new event.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 */
function event_createAnEvent(eventInterface, realm) {
    if (realm === void 0) { realm = undefined; }
    /**
     * 1. If realm is not given, then set it to null.
     * 2. Let dictionary be the result of converting the JavaScript value
     * undefined to the dictionary type accepted by eventInterfaceâ€™s
     * constructor. (This dictionary type will either be EventInit or a
     * dictionary that inherits from it.)
     * 3. Let event be the result of running the inner event creation steps with
     * eventInterface, realm, the time of the occurrence that the event is
     * signaling, and dictionary.
     * 4. Initialize eventâ€™s isTrusted attribute to true.
     * 5. Return event.
     */
    if (realm === undefined)
        realm = null;
    var dictionary = {};
    var event = event_innerEventCreationSteps(eventInterface, realm, new Date(), dictionary);
    event._isTrusted = true;
    return event;
}
exports.event_createAnEvent = event_createAnEvent;
/**
 * Performs event creation steps.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 * @param time - time of occurrance
 * @param dictionary - event attributes
 *
 */
function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    /**
     * 1. Let event be the result of creating a new object using eventInterface.
     * TODO: Implement realms
     * If realm is non-null, then use that Realm; otherwise, use the default
     * behavior defined in Web IDL.
     */
    var event = new eventInterface("");
    /**
     * 2. Set eventâ€™s initialized flag.
     * 3. Initialize eventâ€™s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to time.
     * 4. For each member â†’ value in dictionary, if event has an attribute
     * whose identifier is member, then initialize that attribute to value.
     * 5. Run the event constructing steps with event.
     * 6. Return event.
     */
    event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runEventConstructingSteps(event);
    }
    return event;
}
exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
/**
 * Dispatches an event to an event target.
 *
 * @param event - the event to dispatch
 * @param target - event target
 * @param legacyTargetOverrideFlag - legacy target override flag
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_dispatch(event, target, legacyTargetOverrideFlag, legacyOutputDidListenersThrowFlag) {
    var e_1, _a, e_2, _b;
    if (legacyTargetOverrideFlag === void 0) { legacyTargetOverrideFlag = false; }
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    var clearTargets = false;
    /**
     * 1. Set event's dispatch flag.
     */
    event._dispatchFlag = true;
    /**
     * 2. Let targetOverride be target, if legacy target override flag is not
     * given, and target's associated Document otherwise.
     *
     * _Note:_ legacy target override flag is only used by HTML and only when
     * target is a Window object.
     */
    var targetOverride = target;
    if (legacyTargetOverrideFlag) {
        var doc = target._associatedDocument;
        if (util_1.Guard.isDocumentNode(doc)) {
            targetOverride = doc;
        }
    }
    /**
     * 3. Let activationTarget be null.
     * 4. Let relatedTarget be the result of retargeting event's relatedTarget
     * against target.
     * 5. If target is not relatedTarget or target is event's relatedTarget,
     * then:
    */
    var activationTarget = null;
    var relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target);
    if (target !== relatedTarget || target === event._relatedTarget) {
        /**
         * 5.1. Let touchTargets be a new list.
         * 5.2. For each touchTarget of event's touch target list, append the
         * result of retargeting touchTarget against target to touchTargets.
         * 5.3. Append to an event path with event, target, targetOverride,
         * relatedTarget, touchTargets, and false.
         * 5.4. Let isActivationEvent be true, if event is a MouseEvent object
         * and event's type attribute is "click", and false otherwise.
         * 5.5. If isActivationEvent is true and target has activation behavior,
         * then set activationTarget to target.
         * 5.6. Let slotable be target, if target is a slotable and is assigned,
         * and null otherwise.
         * 5.7. Let slot-in-closed-tree be false.
         * 5.8. Let parent be the result of invoking target's get the parent with
         * event.
         */
        var touchTargets = [];
        try {
            for (var _c = __values(event._touchTargetList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var touchTarget = _d.value;
                touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
        var isActivationEvent = (util_1.Guard.isMouseEvent(event) && event._type === "click");
        if (isActivationEvent && target._activationBehavior !== undefined) {
            activationTarget = target;
        }
        var slotable = (util_1.Guard.isSlotable(target) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target)) ?
            target : null;
        var slotInClosedTree = false;
        var parent = target._getTheParent(event);
        /**
         * 5.9. While parent is non-null:
         */
        while (parent !== null && util_1.Guard.isNode(parent)) {
            /**
             * 5.9.1 If slotable is non-null:
             * 5.9.1.1. Assert: parent is a slot.
             * 5.9.1.2. Set slotable to null.
             * 5.9.1.3. If parent's root is a shadow root whose mode is "closed",
             * then set slot-in-closed-tree to true.
             */
            if (slotable !== null) {
                if (!util_1.Guard.isSlot(parent)) {
                    throw new Error("Parent node of a slotable should be a slot.");
                }
                slotable = null;
                var root = TreeAlgorithm_1.tree_rootNode(parent, true);
                if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
                    slotInClosedTree = true;
                }
            }
            /**
             * 5.9.2 If parent is a slotable and is assigned, then set slotable to
             * parent.
             * 5.9.3. Let relatedTarget be the result of retargeting event's
             * relatedTarget against parent.
             * 5.9.4. Let touchTargets be a new list.
             * 5.9.4. For each touchTarget of event's touch target list, append the
             * result of retargeting touchTarget against parent to touchTargets.
             */
            if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {
                slotable = parent;
            }
            relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);
            touchTargets = [];
            try {
                for (var _e = (e_2 = void 0, __values(event._touchTargetList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var touchTarget = _f.value;
                    touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            /**
             * 5.9.6. If parent is a Window object, or parent is a node and target's
             * root is a shadow-including inclusive ancestor of parent, then:
             */
            if (util_1.Guard.isWindow(parent) || (util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) &&
                TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target, true), parent, true, true))) {
                /**
                 * 5.9.6.1. If isActivationEvent is true, event's bubbles attribute
                 * is true, activationTarget is null, and parent has activation
                 * behavior, then set activationTarget to parent.
                 * 5.9.6.2. Append to an event path with event, parent, null,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */
                if (isActivationEvent && event._bubbles && activationTarget === null &&
                    parent._activationBehavior) {
                    activationTarget = parent;
                }
                event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
            }
            else if (parent === relatedTarget) {
                /**
                 * 5.9.7. Otherwise, if parent is relatedTarget,
                 * then set parent to null.
                 */
                parent = null;
            }
            else {
                /**
                 * 5.9.8. Otherwise, set target to parent and then:
                 * 5.9.8.1. If isActivationEvent is true, activationTarget is null,
                 * and target has activation behavior, then set activationTarget
                 * to target.
                 * 5.9.8.2. Append to an event path with event, parent, target,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */
                target = parent;
                if (isActivationEvent && activationTarget === null &&
                    target._activationBehavior) {
                    activationTarget = target;
                }
                event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
            }
            /**
             * 5.9.9. If parent is non-null, then set parent to the result of
             * invoking parent's get the parent with event.
             * 5.9.10. Set slot-in-closed-tree to false.
             */
            if (parent !== null) {
                parent = parent._getTheParent(event);
            }
            slotInClosedTree = false;
        }
        /**
         * 5.10. Let clearTargetsStruct be the last struct in event's path whose
         * shadow-adjusted target is non-null.
         */
        var clearTargetsStruct = null;
        var path = event._path;
        for (var i = path.length - 1; i >= 0; i--) {
            var struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
                clearTargetsStruct = struct;
                break;
            }
        }
        /**
         * 5.11. Let clearTargets be true if clearTargetsStruct's shadow-adjusted
         * target, clearTargetsStruct's relatedTarget, or an EventTarget object
         * in clearTargetsStruct's touch target list is a node and its root is
         * a shadow root, and false otherwise.
         */
        if (clearTargetsStruct !== null) {
            if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) &&
                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {
                clearTargets = true;
            }
            else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) &&
                util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {
                clearTargets = true;
            }
            else {
                for (var j = 0; j < clearTargetsStruct.touchTargetList.length; j++) {
                    var struct = clearTargetsStruct.touchTargetList[j];
                    if (util_1.Guard.isNode(struct) &&
                        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {
                        clearTargets = true;
                        break;
                    }
                }
            }
        }
        /**
         * 5.12. If activationTarget is non-null and activationTarget has
         * legacy-pre-activation behavior, then run activationTarget's
         * legacy-pre-activation behavior.
         */
        if (activationTarget !== null &&
            activationTarget._legacyPreActivationBehavior !== undefined) {
            activationTarget._legacyPreActivationBehavior(event);
        }
        /**
         * 5.13. For each struct in event's path, in reverse order:
         */
        for (var i = path.length - 1; i >= 0; i--) {
            var struct = path[i];
            /**
             * 5.13.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.13.2. Otherwise, set event's eventPhase attribute to
             * CAPTURING_PHASE.
             * 5.13.3. Invoke with struct, event, "capturing", and
             * legacyOutputDidListenersThrowFlag if given.
             */
            if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            }
            else {
                event._eventPhase = interfaces_1.EventPhase.Capturing;
            }
            event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
        }
        /**
         * 5.14. For each struct in event's path
         */
        for (var i = 0; i < path.length; i++) {
            var struct = path[i];
            /**
             * 5.14.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.14.2. Otherwise:
             * 5.14.2.1. If event's bubbles attribute is false, then continue.
             * 5.14.2.2. Set event's eventPhase attribute to BUBBLING_PHASE.
             * 5.14.3. Invoke with struct, event, "bubbling", and
             * legacyOutputDidListenersThrowFlag if given.
             */
            if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            }
            else {
                if (!event._bubbles)
                    continue;
                event._eventPhase = interfaces_1.EventPhase.Bubbling;
            }
            event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
        }
    }
    /**
     * 6. Set event's eventPhase attribute to NONE.
     * 7. Set event's currentTarget attribute to null.
     * 8. Set event's path to the empty list.
     * 9. Unset event's dispatch flag, stop propagation flag, and stop
     * immediate propagation flag.
     */
    event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    /**
     * 10. If clearTargets, then:
     * 10.1. Set event's target to null.
     * 10.2. Set event's relatedTarget to null.
     * 10.3. Set event's touch target list to the empty list.
     */
    if (clearTargets) {
        event._target = null;
        event._relatedTarget = null;
        event._touchTargetList = [];
    }
    /**
     * 11. If activationTarget is non-null, then:
     * 11.1. If event's canceled flag is unset, then run activationTarget's
     * activation behavior with event.
     * 11.2. Otherwise, if activationTarget has legacy-canceled-activation
     * behavior, then run activationTarget's legacy-canceled-activation
     * behavior.
     */
    if (activationTarget !== null) {
        if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {
            activationTarget._activationBehavior(event);
        }
        else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {
            activationTarget._legacyCanceledActivationBehavior(event);
        }
    }
    /**
     * 12. Return false if event's canceled flag is set, and true otherwise.
     */
    return !event._canceledFlag;
}
exports.event_dispatch = event_dispatch;
/**
 * Appends a new struct to an event's path.
 *
 * @param event - an event
 * @param invocationTarget - the target of the invocation
 * @param shadowAdjustedTarget - shadow-root adjusted event target
 * @param relatedTarget - related event target
 * @param touchTargets - a list of touch targets
 * @param slotInClosedTree - if the target's parent is a closed shadow root
 */
function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    /**
     * 1. Let invocationTargetInShadowTree be false.
     * 2. If invocationTarget is a node and its root is a shadow root, then
     * set invocationTargetInShadowTree to true.
     */
    var invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) &&
        util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {
        invocationTargetInShadowTree = true;
    }
    /**
     * 3. Let root-of-closed-tree be false.
     * 4. If invocationTarget is a shadow root whose mode is "closed", then
     * set root-of-closed-tree to true.
     */
    var rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) &&
        invocationTarget._mode === "closed") {
        rootOfClosedTree = true;
    }
    /**
     * 5. Append a new struct to event's path whose invocation target is
     * invocationTarget, invocation-target-in-shadow-tree is
     * invocationTargetInShadowTree, shadow-adjusted target is
     * shadowAdjustedTarget, relatedTarget is relatedTarget,
     * touch target list is touchTargets, root-of-closed-tree is
     * root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
     */
    event._path.push({
        invocationTarget: invocationTarget,
        invocationTargetInShadowTree: invocationTargetInShadowTree,
        shadowAdjustedTarget: shadowAdjustedTarget,
        relatedTarget: relatedTarget,
        touchTargetList: touchTargets,
        rootOfClosedTree: rootOfClosedTree,
        slotInClosedTree: slotInClosedTree
    });
}
exports.event_appendToAnEventPath = event_appendToAnEventPath;
/**
 * Invokes an event.
 *
 * @param struct - a struct defining event's path
 * @param event - the event to invoke
 * @param phase - event phase
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    /**
     * 1. Set event's target to the shadow-adjusted target of the last struct
     * in event's path, that is either struct or preceding struct, whose
     * shadow-adjusted target is non-null.
     */
    var path = event._path;
    var index = -1;
    for (var i = 0; i < path.length; i++) {
        if (path[i] === struct) {
            index = i;
            break;
        }
    }
    if (index !== -1) {
        var item = path[index];
        if (item.shadowAdjustedTarget !== null) {
            event._target = item.shadowAdjustedTarget;
        }
        else if (index > 0) {
            item = path[index - 1];
            if (item.shadowAdjustedTarget !== null) {
                event._target = item.shadowAdjustedTarget;
            }
        }
    }
    /**
     * 2. Set event's relatedTarget to struct's relatedTarget.
     * 3. Set event's touch target list to struct's touch target list.
     * 4. If event's stop propagation flag is set, then return.
     * 5. Initialize event's currentTarget attribute to struct's invocation
     * target.
     * 6. Let listeners be a clone of event's currentTarget attribute value's
     * event listener list.
     *
     * _Note:_ This avoids event listeners added after this point from being
     * run. Note that removal still has an effect due to the removed field.
     */
    event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag)
        return;
    event._currentTarget = struct.invocationTarget;
    var currentTarget = event._currentTarget;
    var targetListeners = currentTarget._eventListenerList;
    var listeners = new (Array.bind.apply(Array, __spread([void 0], targetListeners)))();
    /**
     * 7. Let found be the result of running inner invoke with event, listeners,
     * phase, and legacyOutputDidListenersThrowFlag if given.
     */
    var found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    /**
     * 8. If found is false and event's isTrusted attribute is true, then:
     */
    if (!found && event._isTrusted) {
        /**
         * 8.1. Let originalEventType be event's type attribute value.
         * 8.2. If event's type attribute value is a match for any of the strings
         * in the first column in the following table, set event's type attribute
         * value to the string in the second column on the same row as the matching
         * string, and return otherwise.
         *
         * Event type           | Legacy event type
         * -------------------------------------------------
         * "animationend"       | "webkitAnimationEnd"
         * "animationiteration" | "webkitAnimationIteration"
         * "animationstart"     | "webkitAnimationStart"
         * "transitionend"      | "webkitTransitionEnd"
         */
        var originalEventType = event._type;
        if (originalEventType === "animationend") {
            event._type = "webkitAnimationEnd";
        }
        else if (originalEventType === "animationiteration") {
            event._type = "webkitAnimationIteration";
        }
        else if (originalEventType === "animationstart") {
            event._type = "webkitAnimationStart";
        }
        else if (originalEventType === "transitionend") {
            event._type = "webkitTransitionEnd";
        }
        /**
         * 8.3. Inner invoke with event, listeners, phase, and
         * legacyOutputDidListenersThrowFlag if given.
         * 8.4. Set event's type attribute value to originalEventType.
         */
        event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
        event._type = originalEventType;
    }
}
exports.event_invoke = event_invoke;
/**
 * Invokes an event.
 *
 * @param event - the event to invoke
 * @param listeners - event listeners
 * @param phase - event phase
 * @param struct - a struct defining event's path
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */
function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) { legacyOutputDidListenersThrowFlag = { value: false }; }
    /**
     * 1. Let found be false.
     * 2. For each listener in listeners, whose removed is false:
     */
    var found = false;
    for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        if (!listener.removed) {
            /**
             * 2.1. If event's type attribute value is not listener's type, then
             * continue.
             * 2.2. Set found to true.
             * 2.3. If phase is "capturing" and listener's capture is false, then
             * continue.
             * 2.4. If phase is "bubbling" and listener's capture is true, then
             * continue.
             */
            if (event._type !== listener.type)
                continue;
            found = true;
            if (phase === "capturing" && !listener.capture)
                continue;
            if (phase === "bubbling" && listener.capture)
                continue;
            /**
             * 2.5. If listener's once is true, then remove listener from event's
             * currentTarget attribute value's event listener list.
             */
            if (listener.once && event._currentTarget !== null) {
                var impl = event._currentTarget;
                var index = -1;
                for (var i_1 = 0; i_1 < impl._eventListenerList.length; i_1++) {
                    if (impl._eventListenerList[i_1] === listener) {
                        index = i_1;
                        break;
                    }
                }
                if (index !== -1) {
                    impl._eventListenerList.splice(index, 1);
                }
            }
            /**
             * TODO: Implement realms
             *
             * 2.6. Let global be listener callback's associated Realm's global
             * object.
             */
            var globalObject = undefined;
            /**
             * 2.7. Let currentEvent be undefined.
             * 2.8. If global is a Window object, then:
             * 2.8.1. Set currentEvent to global's current event.
             * 2.8.2. If struct's invocation-target-in-shadow-tree is false, then
             * set global's current event to event.
             */
            var currentEvent = undefined;
            if (util_1.Guard.isWindow(globalObject)) {
                currentEvent = globalObject._currentEvent;
                if (struct.invocationTargetInShadowTree === false) {
                    globalObject._currentEvent = event;
                }
            }
            /**
             * 2.9. If listener's passive is true, then set event's in passive
             * listener flag.
             * 2.10. Call a user object's operation with listener's callback,
             * "handleEvent", Â« event Â», and event's currentTarget attribute value.
             */
            if (listener.passive)
                event._inPassiveListenerFlag = true;
            try {
                listener.callback.handleEvent.call(event._currentTarget, event);
            }
            catch (err) {
                /**
                 * If this throws an exception, then:
                 * 2.10.1. Report the exception.
                 * 2.10.2. Set legacyOutputDidListenersThrowFlag if given.
                 *
                 * _Note:_ The legacyOutputDidListenersThrowFlag is only used by
                 * Indexed Database API.
                 * TODO: Report the exception
                 * See: https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors-in-documents
                 */
                legacyOutputDidListenersThrowFlag.value = true;
            }
            /**
             * 2.11. Unset event's in passive listener flag.
             */
            if (listener.passive)
                event._inPassiveListenerFlag = false;
            /**
             * 2.12. If global is a Window object, then set global's current event
             * to currentEvent.
             */
            if (util_1.Guard.isWindow(globalObject)) {
                globalObject._currentEvent = currentEvent;
            }
            /**
             * 2.13. If event's stop immediate propagation flag is set, then return
             * found.
             */
            if (event._stopImmediatePropagationFlag)
                return found;
        }
    }
    /**
     * 3. Return found.
     */
    return found;
}
exports.event_innerInvoke = event_innerInvoke;
/**
 * Fires an event at target.
 * @param e - event name
 * @param target - event target
 * @param eventConstructor - an event constructor, with a description of how
 * IDL attributes are to be initialized
 * @param idlAttributes - a dictionary describing how IDL attributes are
 * to be initialized
 * @param legacyTargetOverrideFlag - legacy target override flag
 */
function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    /**
     * 1. If eventConstructor is not given, then let eventConstructor be Event.
     */
    if (eventConstructor === undefined) {
        eventConstructor = EventImpl_1.EventImpl;
    }
    /**
     * 2. Let event be the result of creating an event given eventConstructor,
     * in the relevant Realm of target.
     */
    var event = event_createAnEvent(eventConstructor);
    /**
     * 3. Initialize eventâ€™s type attribute to e.
     */
    event._type = e;
    /**
     * 4. Initialize any other IDL attributes of event as described in the
     * invocation of this algorithm.
     * _Note:_ This also allows for the isTrusted attribute to be set to false.
     */
    if (idlAttributes) {
        for (var key in idlAttributes) {
            var idlObj = event;
            idlObj[key] = idlAttributes[key];
        }
    }
    /**
     * 5. Return the result of dispatching event at target, with legacy target
     * override flag set if set.
     */
    return event_dispatch(event, target, legacyTargetOverrideFlag);
}
exports.event_fireAnEvent = event_fireAnEvent;
/**
 * Creates an event.
 *
 * @param eventInterface - the name of the event interface
 */
function event_createLegacyEvent(eventInterface) {
    /**
     * 1. Let constructor be null.
     */
    var constructor = null;
    /**
     * TODO: Implement in HTML DOM
     * 2. If interface is an ASCII case-insensitive match for any of the strings
     * in the first column in the following table, then set constructor to the
     * interface in the second column on the same row as the matching string:
     *
     * String | Interface
     * -------|----------
     * "beforeunloadevent" | BeforeUnloadEvent
     * "compositionevent" | CompositionEvent
     * "customevent" | CustomEvent
     * "devicemotionevent" | DeviceMotionEvent
     * "deviceorientationevent" | DeviceOrientationEvent
     * "dragevent" | DragEvent
     * "event" | Event
     * "events" | Event
     * "focusevent" | FocusEvent
     * "hashchangeevent" | HashChangeEvent
     * "htmlevents" | Event
     * "keyboardevent" | KeyboardEvent
     * "messageevent" | MessageEvent
     * "mouseevent" | MouseEvent
     * "mouseevents" |
     * "storageevent" | StorageEvent
     * "svgevents" | Event
     * "textevent" | CompositionEvent
     * "touchevent" | TouchEvent
     * "uievent" | UIEvent
     * "uievents" | UIEvent
     */
    switch (eventInterface.toLowerCase()) {
        case "beforeunloadevent":
            break;
        case "compositionevent":
            break;
        case "customevent":
            constructor = CustomEventImpl_1.CustomEventImpl;
            break;
        case "devicemotionevent":
            break;
        case "deviceorientationevent":
            break;
        case "dragevent":
            break;
        case "event":
        case "events":
            constructor = EventImpl_1.EventImpl;
            break;
        case "focusevent":
            break;
        case "hashchangeevent":
            break;
        case "htmlevents":
            break;
        case "keyboardevent":
            break;
        case "messageevent":
            break;
        case "mouseevent":
            break;
        case "mouseevents":
            break;
        case "storageevent":
            break;
        case "svgevents":
            break;
        case "textevent":
            break;
        case "touchevent":
            break;
        case "uievent":
            break;
        case "uievents":
            break;
    }
    /**
     * 3. If constructor is null, then throw a "NotSupportedError" DOMException.
     */
    if (constructor === null) {
        throw new DOMException_1.NotSupportedError("Event constructor not found for interface " + eventInterface + ".");
    }
    /**
     * 4. If the interface indicated by constructor is not exposed on the
     * relevant global object of the context object, then throw a
     * "NotSupportedError" DOMException.
     * _Note:_ Typically user agents disable support for touch events in some
     * configurations, in which case this clause would be triggered for the
     * interface TouchEvent.
     */
    // TODO: Implement realms
    /**
     * 5. Let event be the result of creating an event given constructor.
     * 6. Initialize eventâ€™s type attribute to the empty string.
     * 7. Initialize eventâ€™s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to now.
     * 8. Initialize eventâ€™s isTrusted attribute to false.
     * 9. Unset eventâ€™s initialized flag.
     */
    var event = new constructor("");
    event._type = "";
    event._timeStamp = new Date().getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    /**
     * 10. Return event.
     */
    return event;
}
exports.event_createLegacyEvent = event_createLegacyEvent;
/**
 * Getter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_getterEventHandlerIDLAttribute(thisObj, name) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return null.
     * 3. Return the result of getting the current value of the event handler
     * given eventTarget and name.
     */
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
        return null;
    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
}
exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
/**
 * Setter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 * @param value - event handler
 */
function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return.
     * 3. If the given value is null, then deactivate an event handler given
     * eventTarget and name.
     * 4. Otherwise:
     * 4.1. Let handlerMap be eventTarget's event handler map.
     * 4.2. Let eventHandler be handlerMap[name].
     * 4.3. Set eventHandler's value to the given value.
     * 4.4. Activate an event handler given eventTarget and name.
     */
    var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null)
        return;
    if (value === null) {
        event_deactivateAnEventHandler(eventTarget, name);
    }
    else {
        var handlerMap = eventTarget._eventHandlerMap;
        var eventHandler = handlerMap["onabort"];
        if (eventHandler !== undefined) {
            eventHandler.value = value;
        }
        event_activateAnEventHandler(eventTarget, name);
    }
}
exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
/**
 * Determines the target of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
/**
 * Gets the current value of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
/**
 * Activates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_activateAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
}
exports.event_activateAnEventHandler = event_activateAnEventHandler;
/**
 * Deactivates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */
function event_deactivateAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
}
exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler;
//# sourceMappingURL=EventAlgorithm.js.map

/***/ }),

/***/ 1312:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */
function eventTarget_flatten(options) {
    /**
     * 1. If options is a boolean, then return options.
     * 2. Return optionsâ€™s capture.
     */
    if (util_1.isBoolean(options)) {
        return options;
    }
    else {
        return options.capture || false;
    }
}
exports.eventTarget_flatten = eventTarget_flatten;
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */
function eventTarget_flattenMore(options) {
    /**
     * 1. Let capture be the result of flattening options.
     * 2. Let once and passive be false.
     * 3. If options is a dictionary, then set passive to optionsâ€™s passive and
     * once to optionsâ€™s once.
     * 4. Return capture, passive, and once.
     */
    var capture = eventTarget_flatten(options);
    var once = false;
    var passive = false;
    if (!util_1.isBoolean(options)) {
        once = options.once || false;
        passive = options.passive || false;
    }
    return [capture, passive, once];
}
exports.eventTarget_flattenMore = eventTarget_flattenMore;
/**
 * Adds a new event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */
function eventTarget_addEventListener(eventTarget, listener) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object, its service
     * workerâ€™s script resourceâ€™s has ever been evaluated flag is set, and
     * listenerâ€™s type matches the type attribute value of any of the service
     * worker events, then report a warning to the console that this might not
     * give the expected results. [SERVICE-WORKERS]
     */
    // TODO: service worker
    /**
     * 2. If listenerâ€™s callback is null, then return.
     */
    if (listener.callback === null)
        return;
    /**
     * 3. If eventTargetâ€™s event listener list does not contain an event listener
     * whose type is listenerâ€™s type, callback is listenerâ€™s callback, and capture
     * is listenerâ€™s capture, then append listener to eventTargetâ€™s event listener
     * list.
     */
    for (var i = 0; i < eventTarget._eventListenerList.length; i++) {
        var entry = eventTarget._eventListenerList[i];
        if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent
            && entry.capture === listener.capture) {
            return;
        }
    }
    eventTarget._eventListenerList.push(listener);
}
exports.eventTarget_addEventListener = eventTarget_addEventListener;
/**
 * Removes an event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */
function eventTarget_removeEventListener(eventTarget, listener, index) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object and its service
     * workerâ€™s set of event types to handle contains type, then report a
     * warning to the console that this might not give the expected results.
     * [SERVICE-WORKERS]
     */
    // TODO: service worker
    /**
     * 2. Set listenerâ€™s removed to true and remove listener from eventTargetâ€™s
     * event listener list.
     */
    listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
}
exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
/**
 * Removes all event listeners.
 *
 * @param eventTarget - event target
 */
function eventTarget_removeAllEventListeners(eventTarget) {
    /**
     * To remove all event listeners, given an EventTarget object eventTarget,
     * for each listener of eventTargetâ€™s event listener list, remove an event
     * listener with eventTarget and listener.
     */
    var e_1, _a;
    try {
        for (var _b = __values(eventTarget._eventListenerList), _c = _b.next(); !_c.done; _c = _b.next()) {
            var e = _c.value;
            e.removed = true;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    eventTarget._eventListenerList.length = 0;
}
exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners;
//# sourceMappingURL=EventTargetAlgorithm.js.map

/***/ }),

/***/ 5463:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var DOMException_1 = __nccwpck_require__(3166);
var interfaces_1 = __nccwpck_require__(7305);
var util_1 = __nccwpck_require__(5282);
var util_2 = __nccwpck_require__(6195);
var infra_1 = __nccwpck_require__(4251);
var CustomElementAlgorithm_1 = __nccwpck_require__(5648);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var NodeIteratorAlgorithm_1 = __nccwpck_require__(9989);
var ShadowTreeAlgorithm_1 = __nccwpck_require__(8733);
var MutationObserverAlgorithm_1 = __nccwpck_require__(8157);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
var DocumentAlgorithm_1 = __nccwpck_require__(2793);
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */
function mutation_ensurePreInsertionValidity(node, parent, child) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var parentNodeType = parent._nodeType;
    var nodeNodeType = node._nodeType;
    var childNodeType = child ? child._nodeType : null;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */
    if (parentNodeType !== interfaces_1.NodeType.Document &&
        parentNodeType !== interfaces_1.NodeType.DocumentFragment &&
        parentNodeType !== interfaces_1.NodeType.Element)
        throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
        throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If child is not null and its parent is not parent, then throw a
     * "NotFoundError" DOMException.
     */
    if (child !== null && child._parent !== parent)
        throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment &&
        nodeNodeType !== interfaces_1.NodeType.DocumentType &&
        nodeNodeType !== interfaces_1.NodeType.Element &&
        nodeNodeType !== interfaces_1.NodeType.Text &&
        nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction &&
        nodeNodeType !== interfaces_1.NodeType.CData &&
        nodeNodeType !== interfaces_1.NodeType.Comment)
        throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (nodeNodeType === interfaces_1.NodeType.Text &&
        parentNodeType === interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (nodeNodeType === interfaces_1.NodeType.DocumentType &&
        parentNodeType !== interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child, child is a doctype, or child is not null and a doctype is
     * following child.
     * - element
     * parent has an element child, child is a doctype, or child is not null and
     * a doctype is following child.
     * - doctype
     * parent has a doctype child, child is non-null and an element is preceding
     * child, or child is null and parent has an element child.
     */
    if (parentNodeType === interfaces_1.NodeType.Document) {
        if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element)
                        eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            }
            else if (eleCount === 1) {
                try {
                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element)
                            throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (child) {
                    if (childNodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    var doctypeChild = child._nextSibling;
                    while (doctypeChild) {
                        if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                            throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                        doctypeChild = doctypeChild._nextSibling;
                    }
                }
            }
        }
        else if (nodeNodeType === interfaces_1.NodeType.Element) {
            try {
                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (child) {
                if (childNodeType === interfaces_1.NodeType.DocumentType)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                var doctypeChild = child._nextSibling;
                while (doctypeChild) {
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        }
        else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_4) throw e_4.error; }
            }
            if (child) {
                var elementChild = child._previousSibling;
                while (elementChild) {
                    if (elementChild._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._previousSibling;
                }
            }
            else {
                var elementChild = parent._firstChild;
                while (elementChild) {
                    if (elementChild._nodeType === interfaces_1.NodeType.Element)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._nextSibling;
                }
            }
        }
    }
}
exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child, then adopts the node to the tree and inserts it.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */
function mutation_preInsert(node, parent, child) {
    /**
     * 1. Ensure pre-insertion validity of node into parent before child.
     * 2. Let reference child be child.
     * 3. If reference child is node, set it to nodeâ€™s next sibling.
     * 4. Adopt node into parentâ€™s node document.
     * 5. Insert node into parent before reference child.
     * 6. Return node.
     */
    mutation_ensurePreInsertionValidity(node, parent, child);
    var referenceChild = child;
    if (referenceChild === node)
        referenceChild = node._nextSibling;
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    mutation_insert(node, parent, referenceChild);
    return node;
}
exports.mutation_preInsert = mutation_preInsert;
/**
 * Inserts a node into a parent node before the given child node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 * @param suppressObservers - whether to notify observers
 */
function mutation_insert(node, parent, child, suppressObservers) {
    var e_5, _a;
    // Optimized common case
    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
        mutation_insert_single(node, parent, suppressObservers);
        return;
    }
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     */
    var count = (node._nodeType === interfaces_1.NodeType.DocumentFragment ?
        node._children.size : 1);
    /**
     * 2. If child is non-null, then:
     */
    if (child !== null) {
        /**
         * 2.1. For each live range whose start node is parent and start
         * offset is greater than child's index, increase its start
         * offset by count.
         * 2.2. For each live range whose end node is parent and end
         * offset is greater than child's index, increase its end
         * offset by count.
         */
        if (DOMImpl_1.dom.rangeList.size !== 0) {
            var index_1 = TreeAlgorithm_1.tree_index(child);
            try {
                for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var range = _c.value;
                    if (range._start[0] === parent && range._start[1] > index_1) {
                        range._start[1] += count;
                    }
                    if (range._end[0] === parent && range._end[1] > index_1) {
                        range._end[1] += count;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    }
    /**
     * 3. Let nodes be nodeâ€™s children, if node is a DocumentFragment node;
     * otherwise Â« node Â».
     */
    var nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new (Array.bind.apply(Array, __spread([void 0], node._children)))() : [node];
    /**
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     */
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        while (node._firstChild) {
            mutation_remove(node._firstChild, node, true);
        }
    }
    /**
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with Â« Â», nodes, null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node, [], nodes, null, null);
        }
    }
    /**
     * 6. Let previousSibling be childâ€™s previous sibling or parentâ€™s last
     * child if child is null.
     */
    var previousSibling = (child ? child._previousSibling : parent._lastChild);
    var index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);
    /**
     * 7. For each node in nodes, in tree order:
     */
    for (var i = 0; i < nodes.length; i++) {
        var node_1 = nodes[i];
        if (util_1.Guard.isElementNode(node_1)) {
            // set document element node
            if (util_1.Guard.isDocumentNode(parent)) {
                parent._documentElement = node_1;
            }
            // mark that the document has namespaces
            if (!node_1._nodeDocument._hasNamespaces && (node_1._namespace !== null ||
                node_1._namespacePrefix !== null)) {
                node_1._nodeDocument._hasNamespaces = true;
            }
        }
        /**
         * 7.1. If child is null, then append node to parentâ€™s children.
         * 7.2. Otherwise, insert node into parentâ€™s children before childâ€™s
         * index.
         */
        node_1._parent = parent;
        if (child === null) {
            infra_1.set.append(parent._children, node_1);
        }
        else {
            infra_1.set.insert(parent._children, node_1, index);
            index++;
        }
        // assign siblings and children for quick lookups
        if (parent._firstChild === null) {
            node_1._previousSibling = null;
            node_1._nextSibling = null;
            parent._firstChild = node_1;
            parent._lastChild = node_1;
        }
        else {
            var prev = (child ? child._previousSibling : parent._lastChild);
            var next = (child ? child : null);
            node_1._previousSibling = prev;
            node_1._nextSibling = next;
            if (prev)
                prev._nextSibling = node_1;
            if (next)
                next._previousSibling = node_1;
            if (!prev)
                parent._firstChild = node_1;
            if (!next)
                parent._lastChild = node_1;
        }
        /**
         * 7.3. If parent is a shadow host and node is a slotable, then
         * assign a slot for node.
         */
        if (DOMImpl_1.dom.features.slots) {
            if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node_1)) {
                ShadowTreeAlgorithm_1.shadowTree_assignASlot(node_1);
            }
        }
        /**
         * 7.4. If node is a Text node, run the child text content change
         * steps for parent.
         */
        if (DOMImpl_1.dom.features.steps) {
            if (util_1.Guard.isTextNode(node_1)) {
                DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
            }
        }
        /**
         * 7.5. If parent's root is a shadow root, and parent is a slot
         * whose assigned nodes is the empty list, then run signal
         * a slot change for parent.
         */
        if (DOMImpl_1.dom.features.slots) {
            if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
                util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
                ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
            }
        }
        /**
         * 7.6. Run assign slotables for a tree with node's root.
         */
        if (DOMImpl_1.dom.features.slots) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node_1));
        }
        /**
         * 7.7. For each shadow-including inclusive descendant
         * inclusiveDescendant of node, in shadow-including tree
         * order:
         */
        var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node_1, true, true);
        while (inclusiveDescendant !== null) {
            /**
             * 7.7.1. Run the insertion steps with inclusiveDescendant.
             */
            if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);
            }
            if (DOMImpl_1.dom.features.customElements) {
                /**
                 * 7.7.2. If inclusiveDescendant is connected, then:
                 */
                if (util_1.Guard.isElementNode(inclusiveDescendant) &&
                    ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {
                    if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
                        /**
                         * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                         * element callback reaction with inclusiveDescendant, callback name
                         * "connectedCallback", and an empty argument list.
                         */
                        CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "connectedCallback", []);
                    }
                    else {
                        /**
                         * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                         */
                        CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);
                    }
                }
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node_1, inclusiveDescendant, true, true);
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, Â« Â», previousSibling, and child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, [], previousSibling, child);
        }
    }
}
exports.mutation_insert = mutation_insert;
/**
 * Inserts a node into a parent node. Optimized routine for the common case where
 * node is not a document fragment node and it has no child nodes.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param suppressObservers - whether to notify observers
 */
function mutation_insert_single(node, parent, suppressObservers) {
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     * 2. If child is non-null, then:
     * 2.1. For each live range whose start node is parent and start
     * offset is greater than child's index, increase its start
     * offset by count.
     * 2.2. For each live range whose end node is parent and end
     * offset is greater than child's index, increase its end
     * offset by count.
     * 3. Let nodes be nodeâ€™s children, if node is a DocumentFragment node;
     * otherwise Â« node Â».
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with Â« Â», nodes, null, and null.
     */
    /**
     * 6. Let previousSibling be childâ€™s previous sibling or parentâ€™s last
     * child if child is null.
     */
    var previousSibling = parent._lastChild;
    // set document element node
    if (util_1.Guard.isElementNode(node)) {
        // set document element node
        if (util_1.Guard.isDocumentNode(parent)) {
            parent._documentElement = node;
        }
        // mark that the document has namespaces
        if (!node._nodeDocument._hasNamespaces && (node._namespace !== null ||
            node._namespacePrefix !== null)) {
            node._nodeDocument._hasNamespaces = true;
        }
    }
    /**
     * 7. For each node in nodes, in tree order:
     * 7.1. If child is null, then append node to parentâ€™s children.
     * 7.2. Otherwise, insert node into parentâ€™s children before childâ€™s
     * index.
     */
    node._parent = parent;
    parent._children.add(node);
    // assign siblings and children for quick lookups
    if (parent._firstChild === null) {
        node._previousSibling = null;
        node._nextSibling = null;
        parent._firstChild = node;
        parent._lastChild = node;
    }
    else {
        var prev = parent._lastChild;
        node._previousSibling = prev;
        node._nextSibling = null;
        if (prev)
            prev._nextSibling = node;
        if (!prev)
            parent._firstChild = node;
        parent._lastChild = node;
    }
    /**
     * 7.3. If parent is a shadow host and node is a slotable, then
     * assign a slot for node.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignASlot(node);
        }
    }
    /**
     * 7.4. If node is a Text node, run the child text content change
     * steps for parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
    /**
     * 7.5. If parent's root is a shadow root, and parent is a slot
     * whose assigned nodes is the empty list, then run signal
     * a slot change for parent.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 7.6. Run assign slotables for a tree with node's root.
     */
    if (DOMImpl_1.dom.features.slots) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node));
    }
    /**
     * 7.7. For each shadow-including inclusive descendant
     * inclusiveDescendant of node, in shadow-including tree
     * order:
     * 7.7.1. Run the insertion steps with inclusiveDescendant.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runInsertionSteps(node);
    }
    if (DOMImpl_1.dom.features.customElements) {
        /**
         * 7.7.2. If inclusiveDescendant is connected, then:
         */
        if (util_1.Guard.isElementNode(node) &&
            ShadowTreeAlgorithm_1.shadowTree_isConnected(node)) {
            if (util_1.Guard.isCustomElementNode(node)) {
                /**
                 * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                 * element callback reaction with inclusiveDescendant, callback name
                 * "connectedCallback", and an empty argument list.
                 */
                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "connectedCallback", []);
            }
            else {
                /**
                 * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                 */
                CustomElementAlgorithm_1.customElement_tryToUpgrade(node);
            }
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, Â« Â», previousSibling, and child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [node], [], previousSibling, null);
        }
    }
}
/**
 * Appends a node to the children of a parent node.
 *
 * @param node - a node
 * @param parent - the parent to receive node
 */
function mutation_append(node, parent) {
    /**
     * To append a node to a parent, pre-insert node into parent before null.
     */
    return mutation_preInsert(node, parent, null);
}
exports.mutation_append = mutation_append;
/**
 * Replaces a node with another node.
 *
 * @param child - child node to remove
 * @param node - node to insert
 * @param parent - parent node to receive node
 */
function mutation_replace(child, node, parent) {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */
    if (parent._nodeType !== interfaces_1.NodeType.Document &&
        parent._nodeType !== interfaces_1.NodeType.DocumentFragment &&
        parent._nodeType !== interfaces_1.NodeType.Element)
        throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */
    if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true))
        throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If childâ€™s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     */
    if (child._parent !== parent)
        throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (node._nodeType !== interfaces_1.NodeType.DocumentFragment &&
        node._nodeType !== interfaces_1.NodeType.DocumentType &&
        node._nodeType !== interfaces_1.NodeType.Element &&
        node._nodeType !== interfaces_1.NodeType.Text &&
        node._nodeType !== interfaces_1.NodeType.ProcessingInstruction &&
        node._nodeType !== interfaces_1.NodeType.CData &&
        node._nodeType !== interfaces_1.NodeType.Comment)
        throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */
    if (node._nodeType === interfaces_1.NodeType.Text &&
        parent._nodeType === interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (node._nodeType === interfaces_1.NodeType.DocumentType &&
        parent._nodeType !== interfaces_1.NodeType.Document)
        throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child that is not child or a doctype is following child.
     * - element
     * parent has an element child that is not child or a doctype is
     * following child.
     * - doctype
     * parent has a doctype child that is not child, or an element is
     * preceding child.
     */
    if (parent._nodeType === interfaces_1.NodeType.Document) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element)
                        eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            }
            else if (eleCount === 1) {
                try {
                    for (var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                            throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                var doctypeChild = child._nextSibling;
                while (doctypeChild) {
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                        throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        }
        else if (node._nodeType === interfaces_1.NodeType.Element) {
            try {
                for (var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_8) throw e_8.error; }
            }
            var doctypeChild = child._nextSibling;
            while (doctypeChild) {
                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                doctypeChild = doctypeChild._nextSibling;
            }
        }
        else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for (var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child)
                        throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_9) throw e_9.error; }
            }
            var elementChild = child._previousSibling;
            while (elementChild) {
                if (elementChild._nodeType === interfaces_1.NodeType.Element)
                    throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                elementChild = elementChild._previousSibling;
            }
        }
    }
    /**
     * 7. Let reference child be childâ€™s next sibling.
     * 8. If reference child is node, set it to nodeâ€™s next sibling.
     * 8. Let previousSibling be childâ€™s previous sibling.
     */
    var referenceChild = child._nextSibling;
    if (referenceChild === node)
        referenceChild = node._nextSibling;
    var previousSibling = child._previousSibling;
    /**
     * 10. Adopt node into parentâ€™s node document.
     * 11. Let removedNodes be the empty list.
     */
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    var removedNodes = [];
    /**
     * 12. If childâ€™s parent is not null, then:
     */
    if (child._parent !== null) {
        /**
         * 12.1. Set removedNodes to [child].
         * 12.2. Remove child from its parent with the suppress observers flag
         * set.
         */
        removedNodes.push(child);
        mutation_remove(child, child._parent, true);
    }
    /**
     * 13. Let nodes be nodeâ€™s children if node is a DocumentFragment node;
     * otherwise [node].
     */
    var nodes = [];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        nodes = Array.from(node._children);
    }
    else {
        nodes.push(node);
    }
    /**
     * 14. Insert node into parent before reference child with the suppress
     * observers flag set.
     */
    mutation_insert(node, parent, referenceChild, true);
    /**
     * 15. Queue a tree mutation record for parent with nodes, removedNodes,
     * previousSibling, and reference child.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, removedNodes, previousSibling, referenceChild);
    }
    /**
     * 16. Return child.
     */
    return child;
}
exports.mutation_replace = mutation_replace;
/**
 * Replaces all nodes of a parent with the given node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 */
function mutation_replaceAll(node, parent) {
    var e_10, _a;
    /**
     * 1. If node is not null, adopt node into parentâ€™s node document.
     */
    if (node !== null) {
        DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    }
    /**
     * 2. Let removedNodes be parentâ€™s children.
     */
    var removedNodes = Array.from(parent._children);
    /**
     * 3. Let addedNodes be the empty list.
     * 4. If node is DocumentFragment node, then set addedNodes to nodeâ€™s
     * children.
     * 5. Otherwise, if node is non-null, set addedNodes to [node].
     */
    var addedNodes = [];
    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        addedNodes = Array.from(node._children);
    }
    else if (node !== null) {
        addedNodes.push(node);
    }
    try {
        /**
         * 6. Remove all parentâ€™s children, in tree order, with the suppress
         * observers flag set.
         */
        for (var removedNodes_1 = __values(removedNodes), removedNodes_1_1 = removedNodes_1.next(); !removedNodes_1_1.done; removedNodes_1_1 = removedNodes_1.next()) {
            var childNode = removedNodes_1_1.value;
            mutation_remove(childNode, parent, true);
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (removedNodes_1_1 && !removedNodes_1_1.done && (_a = removedNodes_1.return)) _a.call(removedNodes_1);
        }
        finally { if (e_10) throw e_10.error; }
    }
    /**
     * 7. If node is not null, then insert node into parent before null with the
     * suppress observers flag set.
     */
    if (node !== null) {
        mutation_insert(node, parent, null, true);
    }
    /**
     * 8. Queue a tree mutation record for parent with addedNodes, removedNodes,
     * null, and null.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);
    }
}
exports.mutation_replaceAll = mutation_replaceAll;
/**
 * Ensures pre-removal validity of a child node from a parent, then
 * removes it.
 *
 * @param child - child node to remove
 * @param parent - parent node
 */
function mutation_preRemove(child, parent) {
    /**
     * 1. If childâ€™s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     * 2. Remove child from parent.
     * 3. Return child.
     */
    if (child._parent !== parent)
        throw new DOMException_1.NotFoundError("The child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    mutation_remove(child, parent);
    return child;
}
exports.mutation_preRemove = mutation_preRemove;
/**
 * Removes a child node from its parent.
 *
 * @param node - node to remove
 * @param parent - parent node
 * @param suppressObservers - whether to notify observers
 */
function mutation_remove(node, parent, suppressObservers) {
    var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
    if (DOMImpl_1.dom.rangeList.size !== 0) {
        /**
         * 1. Let index be nodeâ€™s index.
         */
        var index = TreeAlgorithm_1.tree_index(node);
        try {
            /**
             * 2. For each live range whose start node is an inclusive descendant of
             * node, set its start to (parent, index).
             * 3. For each live range whose end node is an inclusive descendant of
             * node, set its end to (parent, index).
             */
            for (var _e = __values(DOMImpl_1.dom.rangeList), _f = _e.next(); !_f.done; _f = _e.next()) {
                var range = _f.value;
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._start[0], true)) {
                    range._start = [parent, index];
                }
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._end[0], true)) {
                    range._end = [parent, index];
                }
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1]--;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1]--;
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_11) throw e_11.error; }
        }
        try {
            /**
             * 4. For each live range whose start node is parent and start offset is
             * greater than index, decrease its start offset by 1.
             * 5. For each live range whose end node is parent and end offset is greater
             * than index, decrease its end offset by 1.
             */
            for (var _g = __values(DOMImpl_1.dom.rangeList), _h = _g.next(); !_h.done; _h = _g.next()) {
                var range = _h.value;
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1] -= 1;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1] -= 1;
                }
            }
        }
        catch (e_12_1) { e_12 = { error: e_12_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_12) throw e_12.error; }
        }
    }
    /**
     * 6. For each NodeIterator object iterator whose rootâ€™s node document is
     * nodeâ€™s node document, run the NodeIterator pre-removing steps given node
     * and iterator.
     */
    if (DOMImpl_1.dom.features.steps) {
        try {
            for (var _j = __values(NodeIteratorAlgorithm_1.nodeIterator_iteratorList()), _k = _j.next(); !_k.done; _k = _j.next()) {
                var iterator = _k.value;
                if (iterator._root._nodeDocument === node._nodeDocument) {
                    DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node);
                }
            }
        }
        catch (e_13_1) { e_13 = { error: e_13_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            }
            finally { if (e_13) throw e_13.error; }
        }
    }
    /**
     * 7. Let oldPreviousSibling be nodeâ€™s previous sibling.
     * 8. Let oldNextSibling be nodeâ€™s next sibling.
     */
    var oldPreviousSibling = node._previousSibling;
    var oldNextSibling = node._nextSibling;
    // set document element node
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
        parent._documentElement = null;
    }
    /**
     * 9. Remove node from its parentâ€™s children.
     */
    node._parent = null;
    parent._children.delete(node);
    // assign siblings and children for quick lookups
    var prev = node._previousSibling;
    var next = node._nextSibling;
    node._previousSibling = null;
    node._nextSibling = null;
    if (prev)
        prev._nextSibling = next;
    if (next)
        next._previousSibling = prev;
    if (!prev)
        parent._firstChild = next;
    if (!next)
        parent._lastChild = prev;
    /**
     * 10. If node is assigned, then run assign slotables for nodeâ€™s assigned
     * slot.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node._assignedSlot);
        }
    }
    /**
     * 11. If parentâ€™s root is a shadow root, and parent is a slot whose
     * assigned nodes is the empty list, then run signal a slot change for
     * parent.
     */
    if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) &&
            util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 12. If node has an inclusive descendant that is a slot, then:
     * 12.1. Run assign slotables for a tree with parent's root.
     * 12.2. Run assign slotables for a tree with node.
     */
    if (DOMImpl_1.dom.features.slots) {
        var descendant_1 = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, false, function (e) { return util_1.Guard.isSlot(e); });
        if (descendant_1 !== null) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node);
        }
    }
    /**
     * 13. Run the removing steps with node and parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runRemovingSteps(node, parent);
    }
    /**
     * 14. If node is custom, then enqueue a custom element callback
     * reaction with node, callback name "disconnectedCallback",
     * and an empty argument list.
     */
    if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(node)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "disconnectedCallback", []);
        }
    }
    /**
     * 15. For each shadow-including descendant descendant of node,
     * in shadow-including tree order, then:
     */
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, true);
    while (descendant !== null) {
        /**
         * 15.1. Run the removing steps with descendant.
         */
        if (DOMImpl_1.dom.features.steps) {
            DOMAlgorithm_1.dom_runRemovingSteps(descendant, node);
        }
        /**
         * 15.2. If descendant is custom, then enqueue a custom element
         * callback reaction with descendant, callback name
         * "disconnectedCallback", and an empty argument list.
         */
        if (DOMImpl_1.dom.features.customElements) {
            if (util_1.Guard.isCustomElementNode(descendant)) {
                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, "disconnectedCallback", []);
            }
        }
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, descendant, false, true);
    }
    /**
     * 16. For each inclusive ancestor inclusiveAncestor of parent, and
     * then for each registered of inclusiveAncestor's registered
     * observer list, if registered's options's subtree is true,
     * then append a new transient registered observer whose
     * observer is registered's observer, options is registered's
     * options, and source is registered to node's registered
     * observer list.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        var inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);
        while (inclusiveAncestor !== null) {
            try {
                for (var _l = (e_14 = void 0, __values(inclusiveAncestor._registeredObserverList)), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var registered = _m.value;
                    if (registered.options.subtree) {
                        node._registeredObserverList.push({
                            observer: registered.observer,
                            options: registered.options,
                            source: registered
                        });
                    }
                }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_14) throw e_14.error; }
            }
            inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);
        }
    }
    /**
     * 17. If suppress observers flag is unset, then queue a tree mutation
     * record for parent with Â« Â», Â« node Â», oldPreviousSibling, and
     * oldNextSibling.
     */
    if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [node], oldPreviousSibling, oldNextSibling);
        }
    }
    /**
     * 18. If node is a Text node, then run the child text content change steps
     * for parent.
     */
    if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
}
exports.mutation_remove = mutation_remove;
//# sourceMappingURL=MutationAlgorithm.js.map

/***/ }),

/***/ 8157:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var infra_1 = __nccwpck_require__(4251);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var EventAlgorithm_1 = __nccwpck_require__(8217);
/**
 * Queues a mutation observer microtask to the surrounding agentâ€™s mutation
 * observers.
 */
function observer_queueAMutationObserverMicrotask() {
    /**
     * 1. If the surrounding agentâ€™s mutation observer microtask queued is true,
     * then return.
     * 2. Set the surrounding agentâ€™s mutation observer microtask queued to true.
     * 3. Queue a microtask to notify mutation observers.
     */
    var window = DOMImpl_1.dom.window;
    if (window._mutationObserverMicrotaskQueued)
        return;
    window._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(function () { observer_notifyMutationObservers(); });
}
exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
/**
 * Notifies the surrounding agentâ€™s mutation observers.
 */
function observer_notifyMutationObservers() {
    var e_1, _a, e_2, _b;
    /**
     * 1. Set the surrounding agentâ€™s mutation observer microtask queued to false.
     * 2. Let notifySet be a clone of the surrounding agentâ€™s mutation observers.
     * 3. Let signalSet be a clone of the surrounding agentâ€™s signal slots.
     * 4. Empty the surrounding agentâ€™s signal slots.
     */
    var window = DOMImpl_1.dom.window;
    window._mutationObserverMicrotaskQueued = false;
    var notifySet = infra_1.set.clone(window._mutationObservers);
    var signalSet = infra_1.set.clone(window._signalSlots);
    infra_1.set.empty(window._signalSlots);
    var _loop_1 = function (mo) {
        /**
         * 5.1. Let records be a clone of moâ€™s record queue.
         * 5.2. Empty moâ€™s record queue.
         */
        var records = infra_1.list.clone(mo._recordQueue);
        infra_1.list.empty(mo._recordQueue);
        /**
         * 5.3. For each node of moâ€™s node list, remove all transient registered
         * observers whose observer is mo from nodeâ€™s registered observer list.
         */
        for (var i = 0; i < mo._nodeList.length; i++) {
            var node = mo._nodeList[i];
            infra_1.list.remove(node._registeredObserverList, function (observer) {
                return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
            });
        }
        /**
         * 5.4. If records is not empty, then invoke moâ€™s callback with Â« records,
         * mo Â», and mo. If this throws an exception, then report the exception.
         */
        if (!infra_1.list.isEmpty(records)) {
            try {
                mo._callback.call(mo, records, mo);
            }
            catch (err) {
                // TODO: Report the exception
            }
        }
    };
    try {
        /**
         * 5. For each mo of notifySet:
         */
        for (var notifySet_1 = __values(notifySet), notifySet_1_1 = notifySet_1.next(); !notifySet_1_1.done; notifySet_1_1 = notifySet_1.next()) {
            var mo = notifySet_1_1.value;
            _loop_1(mo);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (notifySet_1_1 && !notifySet_1_1.done && (_a = notifySet_1.return)) _a.call(notifySet_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 6. For each slot of signalSet, fire an event named slotchange, with its
     * bubbles attribute set to true, at slot.
     */
    if (DOMImpl_1.dom.features.slots) {
        try {
            for (var signalSet_1 = __values(signalSet), signalSet_1_1 = signalSet_1.next(); !signalSet_1_1.done; signalSet_1_1 = signalSet_1.next()) {
                var slot = signalSet_1_1.value;
                EventAlgorithm_1.event_fireAnEvent("slotchange", slot, undefined, { bubbles: true });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (signalSet_1_1 && !signalSet_1_1.done && (_b = signalSet_1.return)) _b.call(signalSet_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
/**
 * Queues a mutation record of the given type for target.
 *
 * @param type - mutation record type
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */
function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    var e_3, _a;
    /**
     * 1. Let interestedObservers be an empty map.
     * 2. Let nodes be the inclusive ancestors of target.
     * 3. For each node in nodes, and then for each registered of nodeâ€™s
     * registered observer list:
     */
    var interestedObservers = new Map();
    var node = TreeAlgorithm_1.tree_getFirstAncestorNode(target, true);
    while (node !== null) {
        for (var i = 0; i < node._registeredObserverList.length; i++) {
            var registered = node._registeredObserverList[i];
            /**
             * 3.1. Let options be registeredâ€™s options.
             * 3.2. If none of the following are true
             * - node is not target and optionsâ€™s subtree is false
             * - type is "attributes" and optionsâ€™s attributes is not true
             * - type is "attributes", optionsâ€™s attributeFilter is present, and
             * optionsâ€™s attributeFilter does not contain name or namespace is
             * non-null
             * - type is "characterData" and optionsâ€™s characterData is not true
             * - type is "childList" and optionsâ€™s childList is false
             */
            var options = registered.options;
            if (node !== target && !options.subtree)
                continue;
            if (type === "attributes" && !options.attributes)
                continue;
            if (type === "attributes" && options.attributeFilter &&
                (!options.attributeFilter.indexOf(name || '') || namespace !== null))
                continue;
            if (type === "characterData" && !options.characterData)
                continue;
            if (type === "childList" && !options.childList)
                continue;
            /**
             * then:
             * 3.2.1. Let mo be registeredâ€™s observer.
             * 3.2.2. If interestedObservers[mo] does not exist, then set
             * interestedObservers[mo] to null.
             * 3.2.3. If either type is "attributes" and optionsâ€™s attributeOldValue
             * is true, or type is "characterData" and optionsâ€™s
             * characterDataOldValue is true, then set interestedObservers[mo]
             * to oldValue.
             */
            var mo = registered.observer;
            if (!interestedObservers.has(mo)) {
                interestedObservers.set(mo, null);
            }
            if ((type === "attributes" && options.attributeOldValue) ||
                (type === "characterData" && options.characterDataOldValue)) {
                interestedObservers.set(mo, oldValue);
            }
        }
        node = TreeAlgorithm_1.tree_getNextAncestorNode(target, node, true);
    }
    try {
        /**
         * 4. For each observer â†’ mappedOldValue of interestedObservers:
         */
        for (var interestedObservers_1 = __values(interestedObservers), interestedObservers_1_1 = interestedObservers_1.next(); !interestedObservers_1_1.done; interestedObservers_1_1 = interestedObservers_1.next()) {
            var _b = __read(interestedObservers_1_1.value, 2), observer = _b[0], mappedOldValue = _b[1];
            /**
             * 4.1. Let record be a new MutationRecord object with its type set to
             * type, target set to target, attributeName set to name,
             * attributeNamespace set to namespace, oldValue set to mappedOldValue,
             * addedNodes set to addedNodes, removedNodes set to removedNodes,
             * previousSibling set to previousSibling, and nextSibling set to
             * nextSibling.
             * 4.2. Enqueue record to observerâ€™s record queue.
             */
            var record = CreateAlgorithm_1.create_mutationRecord(type, target, CreateAlgorithm_1.create_nodeListStatic(target, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
            var queue = observer._recordQueue;
            queue.push(record);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (interestedObservers_1_1 && !interestedObservers_1_1.done && (_a = interestedObservers_1.return)) _a.call(interestedObservers_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    /**
     * 5. Queue a mutation observer microtask.
     */
    observer_queueAMutationObserverMicrotask();
}
exports.observer_queueMutationRecord = observer_queueMutationRecord;
/**
 * Queues a tree mutation record for target.
 *
 * @param target - target node
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */
function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
    /**
     * To queue a tree mutation record for target with addedNodes, removedNodes,
     * previousSibling, and nextSibling, queue a mutation record of "childList"
     * for target with null, null, null, addedNodes, removedNodes,
     * previousSibling, and nextSibling.
     */
    observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
}
exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
/**
 * Queues an attribute mutation record for target.
 *
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 */
function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
    /**
     * To queue an attribute mutation record for target with name, namespace,
     * and oldValue, queue a mutation record of "attributes" for target with
     * name, namespace, oldValue, Â« Â», Â« Â», null, and null.
     */
    observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
}
exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord;
//# sourceMappingURL=MutationObserverAlgorithm.js.map

/***/ }),

/***/ 5856:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(3166);
var infra_1 = __nccwpck_require__(4251);
var XMLAlgorithm_1 = __nccwpck_require__(7030);
/**
 * Validates the given qualified name.
 *
 * @param qualifiedName - qualified name
 */
function namespace_validate(qualifiedName) {
    /**
     * To validate a qualifiedName, throw an "InvalidCharacterError"
     * DOMException if qualifiedName does not match the Name or QName
     * production.
     */
    if (!XMLAlgorithm_1.xml_isName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError("Invalid XML name: " + qualifiedName);
    if (!XMLAlgorithm_1.xml_isQName(qualifiedName))
        throw new DOMException_1.InvalidCharacterError("Invalid XML qualified name: " + qualifiedName + ".");
}
exports.namespace_validate = namespace_validate;
/**
 * Validates and extracts a namespace, prefix and localName from the
 * given namespace and qualified name.
 * See: https://dom.spec.whatwg.org/#validate-and-extract.
 *
 * @param namespace - namespace
 * @param qualifiedName - qualified name
 *
 * @returns a tuple with `namespace`, `prefix` and `localName`.
 */
function namespace_validateAndExtract(namespace, qualifiedName) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Validate qualifiedName.
     * 3. Let prefix be null.
     * 4. Let localName be qualifiedName.
     * 5. If qualifiedName contains a ":" (U+003E), then split the string on it
     * and set prefix to the part before and localName to the part after.
     * 6. If prefix is non-null and namespace is null, then throw a
     * "NamespaceError" DOMException.
     * 7. If prefix is "xml" and namespace is not the XML namespace, then throw
     * a "NamespaceError" DOMException.
     * 8. If either qualifiedName or prefix is "xmlns" and namespace is not the
     * XMLNS namespace, then throw a "NamespaceError" DOMException.
     * 9. If namespace is the XMLNS namespace and neither qualifiedName nor
     * prefix is "xmlns", then throw a "NamespaceError" DOMException.
     * 10. Return namespace, prefix, and localName.
     */
    if (!namespace)
        namespace = null;
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(':');
    var prefix = (parts.length === 2 ? parts[0] : null);
    var localName = (parts.length === 2 ? parts[1] : qualifiedName);
    if (prefix && namespace === null)
        throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML)
        throw new DOMException_1.NamespaceError("Qualified name includes the \"xml\" prefix but the namespace is not the XML namespace.");
    if (namespace !== infra_1.namespace.XMLNS &&
        (prefix === "xmlns" || qualifiedName === "xmlns"))
        throw new DOMException_1.NamespaceError("Qualified name includes the \"xmlns\" prefix but the namespace is not the XMLNS namespace.");
    if (namespace === infra_1.namespace.XMLNS &&
        (prefix !== "xmlns" && qualifiedName !== "xmlns"))
        throw new DOMException_1.NamespaceError("Qualified name does not include the \"xmlns\" prefix but the namespace is the XMLNS namespace.");
    return [namespace, prefix, localName];
}
exports.namespace_validateAndExtract = namespace_validateAndExtract;
/**
 * Extracts a prefix and localName from the given qualified name.
 *
 * @param qualifiedName - qualified name
 *
 * @returns an tuple with `prefix` and `localName`.
 */
function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(':');
    var prefix = (parts.length === 2 ? parts[0] : null);
    var localName = (parts.length === 2 ? parts[1] : qualifiedName);
    return [prefix, localName];
}
exports.namespace_extractQName = namespace_extractQName;
//# sourceMappingURL=NamespaceAlgorithm.js.map

/***/ }),

/***/ 4924:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var infra_1 = __nccwpck_require__(4251);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
var OrderedSetAlgorithm_1 = __nccwpck_require__(3670);
var DOMAlgorithm_1 = __nccwpck_require__(9628);
var MutationAlgorithm_1 = __nccwpck_require__(5463);
var ElementAlgorithm_1 = __nccwpck_require__(3220);
/**
 * Replaces the contents of the given node with a single text node.
 *
 * @param string - node contents
 * @param parent - a node
 */
function node_stringReplaceAll(str, parent) {
    /**
     * 1. Let node be null.
     * 2. If string is not the empty string, then set node to a new Text node
     * whose data is string and node document is parentâ€™s node document.
     * 3. Replace all with node within parent.
     */
    var node = null;
    if (str !== '') {
        node = CreateAlgorithm_1.create_text(parent._nodeDocument, str);
    }
    MutationAlgorithm_1.mutation_replaceAll(node, parent);
}
exports.node_stringReplaceAll = node_stringReplaceAll;
/**
 * Clones a node.
 *
 * @param node - a node to clone
 * @param document - the document to own the cloned node
 * @param cloneChildrenFlag - whether to clone node's children
 */
function node_clone(node, document, cloneChildrenFlag) {
    var e_1, _a, e_2, _b;
    if (document === void 0) { document = null; }
    if (cloneChildrenFlag === void 0) { cloneChildrenFlag = false; }
    /**
     * 1. If document is not given, let document be nodeâ€™s node document.
     */
    if (document === null)
        document = node._nodeDocument;
    var copy;
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 2. If node is an element, then:
         * 2.1. Let copy be the result of creating an element, given document,
         * nodeâ€™s local name, nodeâ€™s namespace, nodeâ€™s namespace prefix,
         * and nodeâ€™s is value, with the synchronous custom elements flag unset.
         * 2.2. For each attribute in nodeâ€™s attribute list:
         * 2.2.1. Let copyAttribute be a clone of attribute.
         * 2.2.2. Append copyAttribute to copy.
         */
        copy = ElementAlgorithm_1.element_createAnElement(document, node._localName, node._namespace, node._namespacePrefix, node._is, false);
        try {
            for (var _c = __values(node._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attribute = _d.value;
                var copyAttribute = node_clone(attribute, document);
                ElementAlgorithm_1.element_append(copyAttribute, copy);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    else {
        /**
         * 3. Otherwise, let copy be a node that implements the same interfaces as
         * node, and fulfills these additional requirements, switching on node:
         * - Document
         * Set copyâ€™s encoding, content type, URL, origin, type, and mode, to those
         * of node.
         * - DocumentType
         * Set copyâ€™s name, public ID, and system ID, to those of node.
         * - Attr
         * Set copyâ€™s namespace, namespace prefix, local name, and value, to
         * those of node.
         * - Text
         * - Comment
         * Set copyâ€™s data, to that of node.
         * - ProcessingInstruction
         * Set copyâ€™s target and data to those of node.
         * - Any other node
         */
        if (util_1.Guard.isDocumentNode(node)) {
            var doc = CreateAlgorithm_1.create_document();
            doc._encoding = node._encoding;
            doc._contentType = node._contentType;
            doc._URL = node._URL;
            doc._origin = node._origin;
            doc._type = node._type;
            doc._mode = node._mode;
            copy = doc;
        }
        else if (util_1.Guard.isDocumentTypeNode(node)) {
            var doctype = CreateAlgorithm_1.create_documentType(document, node._name, node._publicId, node._systemId);
            copy = doctype;
        }
        else if (util_1.Guard.isAttrNode(node)) {
            var attr = CreateAlgorithm_1.create_attr(document, node.localName);
            attr._namespace = node._namespace;
            attr._namespacePrefix = node._namespacePrefix;
            attr._value = node._value;
            copy = attr;
        }
        else if (util_1.Guard.isExclusiveTextNode(node)) {
            copy = CreateAlgorithm_1.create_text(document, node._data);
        }
        else if (util_1.Guard.isCDATASectionNode(node)) {
            copy = CreateAlgorithm_1.create_cdataSection(document, node._data);
        }
        else if (util_1.Guard.isCommentNode(node)) {
            copy = CreateAlgorithm_1.create_comment(document, node._data);
        }
        else if (util_1.Guard.isProcessingInstructionNode(node)) {
            copy = CreateAlgorithm_1.create_processingInstruction(document, node._target, node._data);
        }
        else if (util_1.Guard.isDocumentFragmentNode(node)) {
            copy = CreateAlgorithm_1.create_documentFragment(document);
        }
        else {
            copy = Object.create(node);
        }
    }
    /**
     * 4. Set copyâ€™s node document and document to copy, if copy is a document,
     * and set copyâ€™s node document to document otherwise.
     */
    if (util_1.Guard.isDocumentNode(copy)) {
        copy._nodeDocument = copy;
        document = copy;
    }
    else {
        copy._nodeDocument = document;
    }
    /**
     * 5. Run any cloning steps defined for node in other applicable
     * specifications and pass copy, node, document and the clone children flag
     * if set, as parameters.
     */
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runCloningSteps(copy, node, document, cloneChildrenFlag);
    }
    /**
     * 6. If the clone children flag is set, clone all the children of node and
     * append them to copy, with document as specified and the clone children
     * flag being set.
     */
    if (cloneChildrenFlag) {
        try {
            for (var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()) {
                var child = _f.value;
                var childCopy = node_clone(child, document, true);
                MutationAlgorithm_1.mutation_append(childCopy, copy);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    /**
     * 7. Return copy.
     */
    return copy;
}
exports.node_clone = node_clone;
/**
 * Determines if two nodes can be considered equal.
 *
 * @param a - node to compare
 * @param b - node to compare
 */
function node_equals(a, b) {
    var e_3, _a, e_4, _b;
    /**
     * 1. A and Bâ€™s nodeType attribute value is identical.
     */
    if (a._nodeType !== b._nodeType)
        return false;
    /**
     * 2. The following are also equal, depending on A:
     * - DocumentType
     * Its name, public ID, and system ID.
     * - Element
     * Its namespace, namespace prefix, local name, and its attribute listâ€™s size.
     * - Attr
     * Its namespace, local name, and value.
     * - ProcessingInstruction
     * Its target and data.
     * - Text
     * - Comment
     * Its data.
     */
    if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
        if (a._name !== b._name || a._publicId !== b._publicId ||
            a._systemId !== b._systemId)
            return false;
    }
    else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix ||
            a._localName !== b._localName ||
            a._attributeList.length !== b._attributeList.length)
            return false;
    }
    else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
        if (a._namespace !== b._namespace || a._localName !== b._localName ||
            a._value !== b._value)
            return false;
    }
    else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
        if (a._target !== b._target || a._data !== b._data)
            return false;
    }
    else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
        if (a._data !== b._data)
            return false;
    }
    /**
     * 3. If A is an element, each attribute in its attribute list has an attribute
     * that equals an attribute in Bâ€™s attribute list.
     */
    if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        var attrMap = {};
        try {
            for (var _c = __values(a._attributeList), _d = _c.next(); !_d.done; _d = _c.next()) {
                var attrA = _d.value;
                attrMap[attrA._localName] = attrA;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _e = __values(b._attributeList), _f = _e.next(); !_f.done; _f = _e.next()) {
                var attrB = _f.value;
                var attrA = attrMap[attrB._localName];
                if (!attrA)
                    return false;
                if (!node_equals(attrA, attrB))
                    return false;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    /**
     * 4. A and B have the same number of children.
     * 5. Each child of A equals the child of B at the identical index.
     */
    if (a._children.size !== b._children.size)
        return false;
    var itA = a._children[Symbol.iterator]();
    var itB = b._children[Symbol.iterator]();
    var resultA = itA.next();
    var resultB = itB.next();
    while (!resultA.done && !resultB.done) {
        var child1 = resultA.value;
        var child2 = resultB.value;
        if (!node_equals(child1, child2))
            return false;
        resultA = itA.next();
        resultB = itB.next();
    }
    return true;
}
exports.node_equals = node_equals;
/**
 * Returns a collection of elements with the given qualified name which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagname
 *
 * @param qualifiedName - qualified name
 * @param root - root node
 */
function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    /**
     * 1. If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at
     * root, whose filter matches only descendant elements.
     * 2. Otherwise, if rootâ€™s node document is an HTML document, return a
     * HTMLCollection rooted at root, whose filter matches the following
     * descendant elements:
     * 2.1. Whose namespace is the HTML namespace and whose qualified name is
     * qualifiedName, in ASCII lowercase.
     * 2.2. Whose namespace is not the HTML namespace and whose qualified name
     * is qualifiedName.
     * 3. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose qualified name is qualifiedName.
     */
    if (qualifiedName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    }
    else if (root._nodeDocument._type === "html") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            if (ele._namespace === infra_1.namespace.HTML &&
                ele._qualifiedName === qualifiedName.toLowerCase()) {
                return true;
            }
            else if (ele._namespace !== infra_1.namespace.HTML &&
                ele._qualifiedName === qualifiedName) {
                return true;
            }
            else {
                return false;
            }
        });
    }
    else {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._qualifiedName === qualifiedName);
        });
    }
}
exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
/**
 * Returns a collection of elements with the given namespace which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagnamens
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */
function node_listOfElementsWithNamespace(namespace, localName, root) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. If both namespace and localName are "*" (U+002A), return a
     * HTMLCollection rooted at root, whose filter matches descendant elements.
     * 3. Otherwise, if namespace is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose local
     * name is localName.
     * 4. Otherwise, if localName is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose
     * namespace is namespace.
     * 5. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose namespace is namespace and local
     * name is localName.
     */
    if (namespace === '')
        namespace = null;
    if (namespace === "*" && localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    }
    else if (namespace === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._localName === localName);
        });
    }
    else if (localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._namespace === namespace);
        });
    }
    else {
        return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
            return (ele._localName === localName && ele._namespace === namespace);
        });
    }
}
exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
/**
 * Returns a collection of elements with the given class names which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbyclassname
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */
function node_listOfElementsWithClassNames(classNames, root) {
    /**
     * 1. Let classes be the result of running the ordered set parser
     * on classNames.
     * 2. If classes is the empty set, return an empty HTMLCollection.
     * 3. Return a HTMLCollection rooted at root, whose filter matches
     * descendant elements that have all their classes in classes.
     * The comparisons for the classes must be done in an ASCII case-insensitive
     * manner if rootâ€™s node documentâ€™s mode is "quirks", and in a
     * case-sensitive manner otherwise.
     */
    var classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);
    if (classes.size === 0) {
        return CreateAlgorithm_1.create_htmlCollection(root, function () { return false; });
    }
    var caseSensitive = (root._nodeDocument._mode !== "quirks");
    return CreateAlgorithm_1.create_htmlCollection(root, function (ele) {
        var eleClasses = ele.classList;
        return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);
    });
}
exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
/**
 * Searches for a namespace prefix associated with the given namespace
 * starting from the given element through its ancestors.
 *
 * @param element - an element node to start searching at
 * @param namespace - namespace to search for
 */
function node_locateANamespacePrefix(element, namespace) {
    /**
     * 1. If elementâ€™s namespace is namespace and its namespace prefix is not
     * null, then return its namespace prefix.
     */
    if (element._namespace === namespace && element._namespacePrefix !== null) {
        return element._namespacePrefix;
    }
    /**
     * 2. If element has an attribute whose namespace prefix is "xmlns" and
     * value is namespace, then return elementâ€™s first such attributeâ€™s
     * local name.
     */
    for (var i = 0; i < element._attributeList.length; i++) {
        var attr = element._attributeList[i];
        if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
            return attr._localName;
        }
    }
    /**
     * 3. If elementâ€™s parent element is not null, then return the result of
     * running locate a namespace prefix on that element using namespace.
     */
    if (element._parent && util_1.Guard.isElementNode(element._parent)) {
        return node_locateANamespacePrefix(element._parent, namespace);
    }
    /**
     * 4. Return null.
     */
    return null;
}
exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
/**
 * Searches for a namespace associated with the given namespace prefix
 * starting from the given node through its ancestors.
 *
 * @param node - a node to start searching at
 * @param prefix - namespace prefix to search for
 */
function node_locateANamespace(node, prefix) {
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 1. If its namespace is not null and its namespace prefix is prefix,
         * then return namespace.
         */
        if (node._namespace !== null && node._namespacePrefix === prefix) {
            return node._namespace;
        }
        /**
         * 2. If it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is "xmlns", and local name is prefix, or if prefix
         * is null and it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is null, and local name is "xmlns", then return its
         * value if it is not the empty string, and null otherwise.
         */
        for (var i = 0; i < node._attributeList.length; i++) {
            var attr = node._attributeList[i];
            if (attr._namespace === infra_1.namespace.XMLNS &&
                attr._namespacePrefix === "xmlns" &&
                attr._localName === prefix) {
                return attr._value || null;
            }
            if (prefix === null && attr._namespace === infra_1.namespace.XMLNS &&
                attr._namespacePrefix === null && attr._localName === "xmlns") {
                return attr._value || null;
            }
        }
        /**
         * 3. If its parent element is null, then return null.
         */
        if (node.parentElement === null)
            return null;
        /**
         * 4. Return the result of running locate a namespace on its parent
         * element using prefix.
         */
        return node_locateANamespace(node.parentElement, prefix);
    }
    else if (util_1.Guard.isDocumentNode(node)) {
        /**
         * 1. If its document element is null, then return null.
         * 2. Return the result of running locate a namespace on its document
         * element using prefix.
         */
        if (node.documentElement === null)
            return null;
        return node_locateANamespace(node.documentElement, prefix);
    }
    else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
        return null;
    }
    else if (util_1.Guard.isAttrNode(node)) {
        /**
         * 1. If its element is null, then return null.
         * 2. Return the result of running locate a namespace on its element
         * using prefix.
         */
        if (node._element === null)
            return null;
        return node_locateANamespace(node._element, prefix);
    }
    else {
        /**
         * 1. If its parent element is null, then return null.
         * 2. Return the result of running locate a namespace on its parent
         * element using prefix.
         */
        if (!node._parent || !util_1.Guard.isElementNode(node._parent))
            return null;
        return node_locateANamespace(node._parent, prefix);
    }
}
exports.node_locateANamespace = node_locateANamespace;
//# sourceMappingURL=NodeAlgorithm.js.map

/***/ }),

/***/ 9989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var interfaces_1 = __nccwpck_require__(7305);
var TraversalAlgorithm_1 = __nccwpck_require__(998);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
/**
 * Returns the next or previous node in the subtree, or `null` if
 * there are none.
 *
 * @param iterator - the `NodeIterator` instance
 * @param forward- `true` to return the next node, or `false` to
 * return the previous node.
 */
function nodeIterator_traverse(iterator, forward) {
    /**
     * 1. Let node be iteratorâ€™s reference.
     * 2. Let beforeNode be iteratorâ€™s pointer before reference.
     */
    var node = iterator._reference;
    var beforeNode = iterator._pointerBeforeReference;
    /**
     * 3. While true:
     */
    while (true) {
        /**
         * 3.1. Branch on direction:
         */
        if (forward) {
            /**
             * - next
             */
            if (!beforeNode) {
                /**
                 * If beforeNode is false, then set node to the first node following
                 * node in iteratorâ€™s iterator collection. If there is no such node,
                 * then return null.
                 */
                var nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node);
                if (nextNode) {
                    node = nextNode;
                }
                else {
                    return null;
                }
            }
            else {
                /**
                 * If beforeNode is true, then set it to false.
                 */
                beforeNode = false;
            }
        }
        else {
            /**
             * - previous
             */
            if (beforeNode) {
                /**
                 * If beforeNode is true, then set node to the first node preceding
                 * node in iteratorâ€™s iterator collection. If there is no such node,
                 * then return null.
                 */
                var prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node);
                if (prevNode) {
                    node = prevNode;
                }
                else {
                    return null;
                }
            }
            else {
                /**
                 * If beforeNode is false, then set it to true.
                 */
                beforeNode = true;
            }
        }
        /**
         * 3.2. Let result be the result of filtering node within iterator.
         * 3.3. If result is FILTER_ACCEPT, then break.
         */
        var result = TraversalAlgorithm_1.traversal_filter(iterator, node);
        if (result === interfaces_1.FilterResult.Accept) {
            break;
        }
    }
    /**
     * 4. Set iteratorâ€™s reference to node.
     * 5. Set iteratorâ€™s pointer before reference to beforeNode.
     * 6. Return node.
     */
    iterator._reference = node;
    iterator._pointerBeforeReference = beforeNode;
    return node;
}
exports.nodeIterator_traverse = nodeIterator_traverse;
/**
 * Gets the global iterator list.
 */
function nodeIterator_iteratorList() {
    return DOMImpl_1.dom.window._iteratorList;
}
exports.nodeIterator_iteratorList = nodeIterator_iteratorList;
//# sourceMappingURL=NodeIteratorAlgorithm.js.map

/***/ }),

/***/ 3670:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var infra_1 = __nccwpck_require__(4251);
/**
 * Converts a whitespace separated string into an array of tokens.
 *
 * @param value - a string of whitespace separated tokens
 */
function orderedSet_parse(value) {
    /**
     * 1. Let inputTokens be the result of splitting input on ASCII whitespace.
     * 2. Let tokens be a new ordered set.
     * 3. For each token in inputTokens, append token to tokens.
     * 4. Return tokens.
     */
    var inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
}
exports.orderedSet_parse = orderedSet_parse;
/**
 * Converts an array of tokens into a space separated string.
 *
 * @param tokens - an array of token strings
 */
function orderedSet_serialize(tokens) {
    /**
     * The ordered set serializer takes a set and returns the concatenation of
     * set using U+0020 SPACE.
     */
    return __spread(tokens).join(' ');
}
exports.orderedSet_serialize = orderedSet_serialize;
/**
 * Removes duplicate tokens and convert all whitespace characters
 * to space.
 *
 * @param value - a string of whitespace separated tokens
 */
function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
}
exports.orderedSet_sanitize = orderedSet_sanitize;
/**
 * Determines whether a set contains the other.
 *
 * @param set1 - a set
 * @param set1 - a set that is contained in set1
 * @param caseSensitive - whether matches are case-sensitive
 */
function orderedSet_contains(set1, set2, caseSensitive) {
    var e_1, _a, e_2, _b;
    try {
        for (var set2_1 = __values(set2), set2_1_1 = set2_1.next(); !set2_1_1.done; set2_1_1 = set2_1.next()) {
            var val2 = set2_1_1.value;
            var found = false;
            try {
                for (var set1_1 = (e_2 = void 0, __values(set1)), set1_1_1 = set1_1.next(); !set1_1_1.done; set1_1_1 = set1_1.next()) {
                    var val1 = set1_1_1.value;
                    if (caseSensitive) {
                        if (val1 === val2) {
                            found = true;
                            break;
                        }
                    }
                    else {
                        if (val1.toUpperCase() === val2.toUpperCase()) {
                            found = true;
                            break;
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (set1_1_1 && !set1_1_1.done && (_b = set1_1.return)) _b.call(set1_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (!found)
                return false;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (set2_1_1 && !set2_1_1.done && (_a = set2_1.return)) _a.call(set2_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return true;
}
exports.orderedSet_contains = orderedSet_contains;
//# sourceMappingURL=OrderedSetAlgorithm.js.map

/***/ }),

/***/ 2328:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
/**
 * Converts the given nodes or strings into a node (if `nodes` has
 * only one element) or a document fragment.
 *
 * @param nodes - the array of nodes or strings,
 * @param document - owner document
 */
function parentNode_convertNodesIntoANode(nodes, document) {
    var e_1, _a;
    /**
     * 1. Let node be null.
     * 2. Replace each string in nodes with a new Text node whose data is the
     * string and node document is document.
     */
    var node = null;
    for (var i = 0; i < nodes.length; i++) {
        var item = nodes[i];
        if (util_1.isString(item)) {
            var text = CreateAlgorithm_1.create_text(document, item);
            nodes[i] = text;
        }
    }
    /**
     * 3. If nodes contains one node, set node to that node.
     * 4. Otherwise, set node to a new DocumentFragment whose node document is
     * document, and then append each node in nodes, if any, to it.
     */
    if (nodes.length === 1) {
        node = nodes[0];
    }
    else {
        node = CreateAlgorithm_1.create_documentFragment(document);
        var ns = node;
        try {
            for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {
                var item = nodes_1_1.value;
                ns.appendChild(item);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 5. Return node.
     */
    return node;
}
exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode;
//# sourceMappingURL=ParentNodeAlgorithm.js.map

/***/ }),

/***/ 457:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var DOMException_1 = __nccwpck_require__(3166);
var util_1 = __nccwpck_require__(5282);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var BoundaryPointAlgorithm_1 = __nccwpck_require__(1054);
var CharacterDataAlgorithm_1 = __nccwpck_require__(9461);
var NodeAlgorithm_1 = __nccwpck_require__(4924);
var MutationAlgorithm_1 = __nccwpck_require__(5463);
var TextAlgorithm_1 = __nccwpck_require__(3512);
/**
 * Determines if the node's start boundary point is at its end boundary
 * point.
 *
 * @param range - a range
 */
function range_collapsed(range) {
    /**
     * A range is collapsed if its start node is its end node and its start offset is its end offset.
     */
    return (range._startNode === range._endNode && range._startOffset === range._endOffset);
}
exports.range_collapsed = range_collapsed;
/**
 * Gets the root node of a range.
 *
 * @param range - a range
 */
function range_root(range) {
    /**
     * The root of a live range is the root of its start node.
     */
    return TreeAlgorithm_1.tree_rootNode(range._startNode);
}
exports.range_root = range_root;
/**
 * Determines if a node is fully contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */
function range_isContained(node, range) {
    /**
     * A node node is contained in a live range range if nodeâ€™s root is rangeâ€™s
     * root, and (node, 0) is after rangeâ€™s start, and (node, nodeâ€™s length) is
     * before rangeâ€™s end.
     */
    return (TreeAlgorithm_1.tree_rootNode(node) === range_root(range) &&
        BoundaryPointAlgorithm_1.boundaryPoint_position([node, 0], range._start) === interfaces_1.BoundaryPosition.After &&
        BoundaryPointAlgorithm_1.boundaryPoint_position([node, TreeAlgorithm_1.tree_nodeLength(node)], range._end) === interfaces_1.BoundaryPosition.Before);
}
exports.range_isContained = range_isContained;
/**
 * Determines if a node is partially contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */
function range_isPartiallyContained(node, range) {
    /**
     * A node is partially contained in a live range if itâ€™s an inclusive
     * ancestor of the live rangeâ€™s start node but not its end node,
     * or vice versa.
     */
    var startCheck = TreeAlgorithm_1.tree_isAncestorOf(range._startNode, node, true);
    var endCheck = TreeAlgorithm_1.tree_isAncestorOf(range._endNode, node, true);
    return (startCheck && !endCheck) || (!startCheck && endCheck);
}
exports.range_isPartiallyContained = range_isPartiallyContained;
/**
 * Sets the start boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */
function range_setTheStart(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than nodeâ€™s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the start"
     * 4.1. If bp is after the rangeâ€™s end, or if rangeâ€™s root is not equal to
     * nodeâ€™s root, set rangeâ€™s end to bp.
     * 4.2. Set rangeâ€™s start to bp.
     */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||
        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._end) === interfaces_1.BoundaryPosition.After) {
        range._end = bp;
    }
    range._start = bp;
}
exports.range_setTheStart = range_setTheStart;
/**
 * Sets the end boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */
function range_setTheEnd(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than nodeâ€™s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the end"
     * 4.1. If bp is before the rangeâ€™s start, or if rangeâ€™s root is not equal
     * to nodeâ€™s root, set rangeâ€™s start to bp.
     * 4.2. Set rangeâ€™s end to bp.
     */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [node, offset];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) ||
        BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
        range._start = bp;
    }
    range._end = bp;
}
exports.range_setTheEnd = range_setTheEnd;
/**
 * Selects a node.
 *
 * @param range - a range
 * @param node - a node
 */
function range_select(node, range) {
    /**
     * 1. Let parent be nodeâ€™s parent.
     * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
     */
    var parent = node._parent;
    if (parent === null)
        throw new DOMException_1.InvalidNodeTypeError();
    /**
     * 3. Let index be nodeâ€™s index.
     * 4. Set rangeâ€™s start to boundary point (parent, index).
     * 5. Set rangeâ€™s end to boundary point (parent, index plus 1).
     */
    var index = TreeAlgorithm_1.tree_index(node);
    range._start = [parent, index];
    range._end = [parent, index + 1];
}
exports.range_select = range_select;
/**
 * EXtracts the contents of range as a document fragment.
 *
 * @param range - a range
 */
function range_extract(range) {
    var e_1, _a, e_2, _b, e_3, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document is
     * rangeâ€™s start nodeâ€™s node document.
     * 2. If range is collapsed, then return fragment.
     */
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
        return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be rangeâ€™s start node, start offset, end node,
     * and end offset, respectively.
     */
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    /**
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.4. Replace data with node original start node, offset original start
     * offset, count original end offset minus original start offset, and data
     * the empty string.
     * 4.5. Return fragment.
     */
    if (originalStartNode === originalEndNode &&
        util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');
        return fragment;
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for (var i = children.length - 1; i > 0; i--) {
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */
    var containedChildren = [];
    try {
        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var newNode;
    var newOffset;
    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        /**
         * 13. If original start node is an inclusive ancestor of original end node,
         * set new node to original start node and new offset to original start
         * offset.
         */
        newNode = originalStartNode;
        newOffset = originalStartOffset;
    }
    else {
        /**
         * 14. Otherwise:
         * 14.1. Let reference node equal original start node.
         * 14.2. While reference nodeâ€™s parent is not null and is not an inclusive
         * ancestor of original end node, set reference node to its parent.
         * 14.3. Set new node to the parent of reference node, and new offset to
         * one plus reference nodeâ€™s index.
         */
        var referenceNode = originalStartNode;
        while (referenceNode._parent !== null &&
            !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)) {
            referenceNode = referenceNode._parent;
        }
        /* istanbul ignore next */
        if (referenceNode._parent === null) {
            /**
             * If reference nodeâ€™s parent is null, it would be the root of range,
             * so would be an inclusive ancestor of original end node, and we could
             * not reach this point.
             */
            throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 15. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 15.1. Let clone be a clone of original start node.
         * 15.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start nodeâ€™s length minus original start offset.
         * 15.3. Append clone to fragment.
         * 15.4. Replace data with node original start node, offset original
         * start offset, count original start nodeâ€™s length minus original start
         * offset, and data the empty string.
         */
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');
    }
    else if (firstPartiallyContainedChild !== null) {
        /**
         * 16. Otherwise, if first partially contained child is not null:
         * 16.1. Let clone be a clone of first partially contained child.
         * 16.2. Append clone to fragment.
         * 16.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained childâ€™s length).
         * 16.4. Let subfragment be the result of extracting subrange.
         * 16.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 17. For each contained child in contained children, append contained
         * child to fragment.
         */
        for (var containedChildren_1 = __values(containedChildren), containedChildren_1_1 = containedChildren_1.next(); !containedChildren_1_1.done; containedChildren_1_1 = containedChildren_1.next()) {
            var child = containedChildren_1_1.value;
            MutationAlgorithm_1.mutation_append(child, fragment);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (containedChildren_1_1 && !containedChildren_1_1.done && (_c = containedChildren_1.return)) _c.call(containedChildren_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 18. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 18.1. Let clone be a clone of original end node.
         * 18.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 18.3. Append clone to fragment.
         * 18.4. Replace data with node original end node, offset 0, count
         * original end offset, and data the empty string.
         */
        var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');
    }
    else if (lastPartiallyContainedChild !== null) {
        /**
         * 19. Otherwise, if last partially contained child is not null:
         * 19.1. Let clone be a clone of last partially contained child.
         * 19.2. Append clone to fragment.
         * 19.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 19.4. Let subfragment be the result of extracting subrange.
         * 19.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 20. Set rangeâ€™s start and end to (new node, new offset).
     */
    range._start = [newNode, newOffset];
    range._end = [newNode, newOffset];
    /**
     * 21. Return fragment.
     */
    return fragment;
}
exports.range_extract = range_extract;
/**
 * Clones the contents of range as a document fragment.
 *
 * @param range - a range
 */
function range_cloneTheContents(range) {
    var e_4, _a, e_5, _b, e_6, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document
     * is rangeâ€™s start nodeâ€™s node document.
     * 2. If range is collapsed, then return fragment.
     */
    var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range))
        return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be rangeâ€™s start node, start offset, end node,
     * and end offset, respectively.
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.5. Return fragment.
     */
    var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode &&
        util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */
    var commonAncestor = originalStartNode;
    while (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)) {
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */
    var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for (var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */
    var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for (var i = children.length - 1; i > 0; i--) {
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */
    var containedChildren = [];
    try {
        for (var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()) {
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        }
        finally { if (e_5) throw e_5.error; }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 13. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 13.1. Let clone be a clone of original start node.
         * 13.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start nodeâ€™s length minus original start offset.
         * 13.3. Append clone to fragment.
         */
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    else if (firstPartiallyContainedChild !== null) {
        /**
         * 14. Otherwise, if first partially contained child is not null:
         * 14.1. Let clone be a clone of first partially contained child.
         * 14.2. Append clone to fragment.
         * 14.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained childâ€™s length).
         * 14.4. Let subfragment be the result of cloning the contents of
         * subrange.
         * 14.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([originalStartNode, originalStartOffset], [firstPartiallyContainedChild, TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)]);
        var subfragment = range_cloneTheContents(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 15. For each contained child in contained children, append contained
         * child to fragment.
         * 15.1. Let clone be a clone of contained child with the clone children
         * flag set.
         * 15.2. Append clone to fragment.
         */
        for (var containedChildren_2 = __values(containedChildren), containedChildren_2_1 = containedChildren_2.next(); !containedChildren_2_1.done; containedChildren_2_1 = containedChildren_2.next()) {
            var child = containedChildren_2_1.value;
            var clone = NodeAlgorithm_1.node_clone(child);
            MutationAlgorithm_1.mutation_append(clone, fragment);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (containedChildren_2_1 && !containedChildren_2_1.done && (_c = containedChildren_2.return)) _c.call(containedChildren_2);
        }
        finally { if (e_6) throw e_6.error; }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 16. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 16.1. Let clone be a clone of original end node.
         * 16.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 16.3. Append clone to fragment.
         */
        var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    else if (lastPartiallyContainedChild !== null) {
        /**
         * 17. Otherwise, if last partially contained child is not null:
         * 17.1. Let clone be a clone of last partially contained child.
         * 17.2. Append clone to fragment.
         * 17.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 17.4. Let subfragment be the result of cloning the contents of subrange.
         * 17.5. Append subfragment to clone.
         */
        var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        fragment.append(clone);
        var subrange = CreateAlgorithm_1.create_range([lastPartiallyContainedChild, 0], [originalEndNode, originalEndOffset]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 18. Return fragment.
     */
    return fragment;
}
exports.range_cloneTheContents = range_cloneTheContents;
/**
 * Inserts a node into a range at the start boundary point.
 *
 * @param node - node to insert
 * @param range - a range
 */
function range_insert(node, range) {
    var e_7, _a;
    /**
     * 1. If rangeâ€™s start node is a ProcessingInstruction or Comment node, is a
     * Text node whose parent is null, or is node, then throw a
     * "HierarchyRequestError" DOMException.
     */
    if (util_1.Guard.isProcessingInstructionNode(range._startNode) ||
        util_1.Guard.isCommentNode(range._startNode) ||
        (util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null) ||
        range._startNode === node) {
        throw new DOMException_1.HierarchyRequestError();
    }
    /**
     * 2. Let referenceNode be null.
     * 3. If rangeâ€™s start node is a Text node, set referenceNode to that Text
     * node.
     * 4. Otherwise, set referenceNode to the child of start node whose index is
     * start offset, and null if there is no such child.
     */
    var referenceNode = null;
    if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = range._startNode;
    }
    else {
        var index = 0;
        try {
            for (var _b = __values(range._startNode._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (index === range._startOffset) {
                    referenceNode = child;
                    break;
                }
                index++;
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }
    /**
     * 5. Let parent be rangeâ€™s start node if referenceNode is null, and
     * referenceNodeâ€™s parent otherwise.
     */
    var parent;
    if (referenceNode === null) {
        parent = range._startNode;
    }
    else {
        if (referenceNode._parent === null) {
            throw new Error("Parent node is null.");
        }
        parent = referenceNode._parent;
    }
    /**
     * 6. Ensure pre-insertion validity of node into parent before referenceNode.
     */
    MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node, parent, referenceNode);
    /**
     * 7. If rangeâ€™s start node is a Text node, set referenceNode to the result
     * of splitting it with offset rangeâ€™s start offset.
     */
    if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = TextAlgorithm_1.text_split(range._startNode, range._startOffset);
    }
    /**
     * 8. If node is referenceNode, set referenceNode to its next sibling.
     */
    if (node === referenceNode) {
        referenceNode = node._nextSibling;
    }
    /**
     * 9. If nodeâ€™s parent is not null, remove node from its parent.
     */
    if (node._parent !== null) {
        MutationAlgorithm_1.mutation_remove(node, node._parent);
    }
    /**
     * 10. Let newOffset be parentâ€™s length if referenceNode is null, and
     * referenceNodeâ€™s index otherwise.
     */
    var newOffset = (referenceNode === null ?
        TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode));
    /**
     * 11. Increase newOffset by nodeâ€™s length if node is a DocumentFragment
     * node, and one otherwise.
     */
    if (util_1.Guard.isDocumentFragmentNode(node)) {
        newOffset += TreeAlgorithm_1.tree_nodeLength(node);
    }
    else {
        newOffset++;
    }
    /**
     * 12. Pre-insert node into parent before referenceNode.
     */
    MutationAlgorithm_1.mutation_preInsert(node, parent, referenceNode);
    /**
     * 13. If range is collapsed, then set rangeâ€™s end to (parent, newOffset).
     */
    if (range_collapsed(range)) {
        range._end = [parent, newOffset];
    }
}
exports.range_insert = range_insert;
/**
 * Traverses through all contained nodes of a range.
 *
 * @param range - a range
 */
function range_getContainedNodes(range) {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            var container = range.commonAncestorContainer;
            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
            return {
                next: function () {
                    while (currentNode && !range_isContained(currentNode, range)) {
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.range_getContainedNodes = range_getContainedNodes;
/**
 * Traverses through all partially contained nodes of a range.
 *
 * @param range - a range
 */
function range_getPartiallyContainedNodes(range) {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            var container = range.commonAncestorContainer;
            var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
            return {
                next: function () {
                    while (currentNode && !range_isPartiallyContained(currentNode, range)) {
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes;
//# sourceMappingURL=RangeAlgorithm.js.map

/***/ }),

/***/ 1853:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(3166);
/**
 * Matches elements with the given selectors.
 *
 * @param selectors - selectors
 * @param node - the node to match against
 */
function selectors_scopeMatchASelectorsString(selectors, node) {
    /**
     * TODO: Selectors
     * 1. Let s be the result of parse a selector selectors. [SELECTORS4]
     * 2. If s is failure, then throw a "SyntaxError" DOMException.
     * 3. Return the result of match a selector against a tree with s and nodeâ€™s
     * root using scoping root node. [SELECTORS4].
     */
    throw new DOMException_1.NotSupportedError();
}
exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString;
//# sourceMappingURL=SelectorsAlgorithm.js.map

/***/ }),

/***/ 8733:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var util_2 = __nccwpck_require__(6195);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var MutationObserverAlgorithm_1 = __nccwpck_require__(8157);
/**
 * Signals a slot change to the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_signalASlotChange(slot) {
    /**
     * 1. Append slot to slotâ€™s relevant agentâ€™s signal slots.
     * 2. Queue a mutation observer microtask.
     */
    var window = DOMImpl_1.dom.window;
    window._signalSlots.add(slot);
    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();
}
exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
/**
 * Determines whether a the shadow tree of the given element node is
 * connected to a document node.
 *
 * @param element - an element node of the shadow tree
 */
function shadowTree_isConnected(element) {
    /**
     * An element is connected if its shadow-including root is a document.
     */
    return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element, true));
}
exports.shadowTree_isConnected = shadowTree_isConnected;
/**
 * Determines whether a slotable is assigned.
 *
 * @param slotable - a slotable
 */
function shadowTree_isAssigned(slotable) {
    /**
     * A slotable is assigned if its assigned slot is non-null.
     */
    return (slotable._assignedSlot !== null);
}
exports.shadowTree_isAssigned = shadowTree_isAssigned;
/**
 * Finds a slot for the given slotable.
 *
 * @param slotable - a slotable
 * @param openFlag - `true` to search open shadow tree's only
 */
function shadowTree_findASlot(slotable, openFlag) {
    if (openFlag === void 0) { openFlag = false; }
    /**
     * 1. If slotableâ€™s parent is null, then return null.
     * 2. Let shadow be slotableâ€™s parentâ€™s shadow root.
     * 3. If shadow is null, then return null.
     * 4. If the open flag is set and shadowâ€™s mode is not "open", then
     * return null.
     * 5. Return the first slot in tree order in shadowâ€™s descendants whose name
     * is slotableâ€™s name, if any, and null otherwise.
     */
    var node = util_1.Cast.asNode(slotable);
    var parent = node._parent;
    if (parent === null)
        return null;
    var shadow = parent._shadowRoot || null;
    if (shadow === null)
        return null;
    if (openFlag && shadow._mode !== "open")
        return null;
    var child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, function (e) { return util_1.Guard.isSlot(e); });
    while (child !== null) {
        if (child._name === slotable._name)
            return child;
        child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, function (e) { return util_1.Guard.isSlot(e); });
    }
    return null;
}
exports.shadowTree_findASlot = shadowTree_findASlot;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_findSlotables(slot) {
    var e_1, _a;
    /**
     * 1. Let result be an empty list.
     * 2. If slotâ€™s root is not a shadow root, then return result.
     */
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
        return result;
    /**
     * 3. Let host be slotâ€™s rootâ€™s host.
     * 4. For each slotable child of host, slotable, in tree order:
     */
    var host = root._host;
    try {
        for (var _b = __values(host._children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var slotable = _c.value;
            if (util_1.Guard.isSlotable(slotable)) {
                /**
                 * 4.1. Let foundSlot be the result of finding a slot given slotable.
                 * 4.2. If foundSlot is slot, then append slotable to result.
                 */
                var foundSlot = shadowTree_findASlot(slotable);
                if (foundSlot === slot) {
                    result.push(slotable);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /**
     * 5. Return result.
     */
    return result;
}
exports.shadowTree_findSlotables = shadowTree_findSlotables;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_findFlattenedSlotables(slot) {
    var e_2, _a, e_3, _b;
    /**
     * 1. Let result be an empty list.
     * 2. If slotâ€™s root is not a shadow root, then return result.
     */
    var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root))
        return result;
    /**
     * 3. Let slotables be the result of finding slotables given slot.
     * 4. If slotables is the empty list, then append each slotable child of
     * slot, in tree order, to slotables.
     */
    var slotables = shadowTree_findSlotables(slot);
    if (util_2.isEmpty(slotables)) {
        try {
            for (var _c = __values(slot._children), _d = _c.next(); !_d.done; _d = _c.next()) {
                var slotable = _d.value;
                if (util_1.Guard.isSlotable(slotable)) {
                    slotables.push(slotable);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    try {
        /**
         * 5. For each node in slotables:
         */
        for (var slotables_1 = __values(slotables), slotables_1_1 = slotables_1.next(); !slotables_1_1.done; slotables_1_1 = slotables_1.next()) {
            var node = slotables_1_1.value;
            /**
             * 5.1. If node is a slot whose root is a shadow root, then:
             */
            if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node))) {
                /**
                 * 5.1.1. Let temporaryResult be the result of finding flattened slotables given node.
                 * 5.1.2. Append each slotable in temporaryResult, in order, to result.
                 */
                var temporaryResult = shadowTree_findFlattenedSlotables(node);
                result.push.apply(result, __spread(temporaryResult));
            }
            else {
                /**
                 * 5.2. Otherwise, append node to result.
                 */
                result.push(node);
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (slotables_1_1 && !slotables_1_1.done && (_b = slotables_1.return)) _b.call(slotables_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    /**
     * 6. Return result.
     */
    return result;
}
exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
/**
 * Assigns slotables to the given slot.
 *
 * @param slot - a slot
 */
function shadowTree_assignSlotables(slot) {
    var e_4, _a;
    /**
     * 1. Let slotables be the result of finding slotables for slot.
     * 2. If slotables and slotâ€™s assigned nodes are not identical, then run
     * signal a slot change for slot.
     */
    var slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
        var nodesIdentical = true;
        for (var i = 0; i < slotables.length; i++) {
            if (slotables[i] !== slot._assignedNodes[i]) {
                nodesIdentical = false;
                break;
            }
        }
        if (!nodesIdentical) {
            shadowTree_signalASlotChange(slot);
        }
    }
    /**
     * 3. Set slotâ€™s assigned nodes to slotables.
     * 4. For each slotable in slotables, set slotableâ€™s assigned slot to slot.
     */
    slot._assignedNodes = slotables;
    try {
        for (var slotables_2 = __values(slotables), slotables_2_1 = slotables_2.next(); !slotables_2_1.done; slotables_2_1 = slotables_2.next()) {
            var slotable = slotables_2_1.value;
            slotable._assignedSlot = slot;
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (slotables_2_1 && !slotables_2_1.done && (_a = slotables_2.return)) _a.call(slotables_2);
        }
        finally { if (e_4) throw e_4.error; }
    }
}
exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
/**
 * Assigns slotables to all nodes of a tree.
 *
 * @param root - root node
 */
function shadowTree_assignSlotablesForATree(root) {
    /**
     * To assign slotables for a tree, given a node root, run assign slotables
     * for each slot slot in rootâ€™s inclusive descendants, in tree order.
     */
    var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, function (e) { return util_1.Guard.isSlot(e); });
    while (descendant !== null) {
        shadowTree_assignSlotables(descendant);
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, function (e) { return util_1.Guard.isSlot(e); });
    }
}
exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
/**
 * Assigns a slot to a slotables.
 *
 * @param slotable - a slotable
 */
function shadowTree_assignASlot(slotable) {
    /**
     * 1. Let slot be the result of finding a slot with slotable.
     * 2. If slot is non-null, then run assign slotables for slot.
     */
    var slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
        shadowTree_assignSlotables(slot);
    }
}
exports.shadowTree_assignASlot = shadowTree_assignASlot;
//# sourceMappingURL=ShadowTreeAlgorithm.js.map

/***/ }),

/***/ 3512:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var DOMException_1 = __nccwpck_require__(3166);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
var TreeAlgorithm_1 = __nccwpck_require__(6620);
var CharacterDataAlgorithm_1 = __nccwpck_require__(9461);
var MutationAlgorithm_1 = __nccwpck_require__(5463);
/**
 * Returns node with its adjacent text and cdata node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */
function text_contiguousTextNodes(node, self) {
    var _a;
    if (self === void 0) { self = false; }
    /**
     * The contiguous Text nodes of a node node are node, nodeâ€™s previous
     * sibling Text node, if any, and its contiguous Text nodes, and nodeâ€™s next
     * sibling Text node, if any, and its contiguous Text nodes, avoiding any
     * duplicates.
     */
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node;
            while (currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)) {
                currentNode = currentNode._previousSibling;
            }
            return {
                next: function () {
                    if (currentNode && (!self && currentNode === node)) {
                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.text_contiguousTextNodes = text_contiguousTextNodes;
/**
 * Returns node with its adjacent text node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */
function text_contiguousExclusiveTextNodes(node, self) {
    var _a;
    if (self === void 0) { self = false; }
    /**
     * The contiguous exclusive Text nodes of a node node are node, nodeâ€™s
     * previous sibling exclusive Text node, if any, and its contiguous
     * exclusive Text nodes, and nodeâ€™s next sibling exclusive Text node,
     * if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
     */
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node;
            while (currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)) {
                currentNode = currentNode._previousSibling;
            }
            return {
                next: function () {
                    if (currentNode && (!self && currentNode === node)) {
                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                            currentNode = currentNode._nextSibling;
                        }
                        else {
                            currentNode = null;
                        }
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
/**
 * Returns the concatenation of the data of all the Text node descendants of
 * node, in tree order.
 *
 * @param node - a node
 */
function text_descendantTextContent(node) {
    /**
     * The descendant text content of a node node is the concatenation of the
     * data of all the Text node descendants of node, in tree order.
     */
    var contents = '';
    var text = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, false, function (e) { return util_1.Guard.isTextNode(e); });
    while (text !== null) {
        contents += text._data;
        text = TreeAlgorithm_1.tree_getNextDescendantNode(node, text, false, false, function (e) { return util_1.Guard.isTextNode(e); });
    }
    return contents;
}
exports.text_descendantTextContent = text_descendantTextContent;
/**
 * Splits data at the given offset and returns the remainder as a text
 * node.
 *
 * @param node - a text node
 * @param offset - the offset at which to split the nodes.
 */
function text_split(node, offset) {
    var e_1, _a;
    /**
     * 1. Let length be nodeâ€™s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     */
    var length = node._data.length;
    if (offset > length) {
        throw new DOMException_1.IndexSizeError();
    }
    /**
     * 3. Let count be length minus offset.
     * 4. Let new data be the result of substringing data with node node,
     * offset offset, and count count.
     * 5. Let new node be a new Text node, with the same node document as node.
     * Set new nodeâ€™s data to new data.
     * 6. Let parent be nodeâ€™s parent.
     * 7. If parent is not null, then:
     */
    var count = length - offset;
    var newData = CharacterDataAlgorithm_1.characterData_substringData(node, offset, count);
    var newNode = CreateAlgorithm_1.create_text(node._nodeDocument, newData);
    var parent = node._parent;
    if (parent !== null) {
        /**
         * 7.1. Insert new node into parent before nodeâ€™s next sibling.
         */
        MutationAlgorithm_1.mutation_insert(newNode, parent, node._nextSibling);
        try {
            /**
             * 7.2. For each live range whose start node is node and start offset is
             * greater than offset, set its start node to new node and decrease its
             * start offset by offset.
             * 7.3. For each live range whose end node is node and end offset is greater
             * than offset, set its end node to new node and decrease its end offset
             * by offset.
             * 7.4. For each live range whose start node is parent and start offset is
             * equal to the index of node plus 1, increase its start offset by 1.
             * 7.5. For each live range whose end node is parent and end offset is equal
             * to the index of node plus 1, increase its end offset by 1.
             */
            for (var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var range = _c.value;
                if (range._start[0] === node && range._start[1] > offset) {
                    range._start[0] = newNode;
                    range._start[1] -= offset;
                }
                if (range._end[0] === node && range._end[1] > offset) {
                    range._end[0] = newNode;
                    range._end[1] -= offset;
                }
                var index = TreeAlgorithm_1.tree_index(node);
                if (range._start[0] === parent && range._start[1] === index + 1) {
                    range._start[1]++;
                }
                if (range._end[0] === parent && range._end[1] === index + 1) {
                    range._end[1]++;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 8. Replace data with node node, offset offset, count count, and data
     * the empty string.
     * 9. Return new node.
     */
    CharacterDataAlgorithm_1.characterData_replaceData(node, offset, count, '');
    return newNode;
}
exports.text_split = text_split;
//# sourceMappingURL=TextAlgorithm.js.map

/***/ }),

/***/ 998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var DOMException_1 = __nccwpck_require__(3166);
/**
 * Applies the filter to the given node and returns the result.
 *
 * @param traverser - the `NodeIterator` or `TreeWalker` instance
 * @param node - the node to filter
 */
function traversal_filter(traverser, node) {
    /**
     * 1. If traverserâ€™s active flag is set, then throw an "InvalidStateError"
     * DOMException.
     */
    if (traverser._activeFlag) {
        throw new DOMException_1.InvalidStateError();
    }
    /**
     * 2. Let n be nodeâ€™s nodeType attribute value âˆ’ 1.
     */
    var n = node._nodeType - 1;
    /**
     * 3. If the nth bit (where 0 is the least significant bit) of traverserâ€™s
     * whatToShow is not set, then return FILTER_SKIP.
     */
    var mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
        return interfaces_1.FilterResult.Skip;
    }
    /**
     * 4. If traverserâ€™s filter is null, then return FILTER_ACCEPT.
     */
    if (!traverser.filter) {
        return interfaces_1.FilterResult.Accept;
    }
    /**
     * 5. Set traverserâ€™s active flag.
     */
    traverser._activeFlag = true;
    /**
     * 6. Let result be the return value of call a user objectâ€™s operation with
     * traverserâ€™s filter, "acceptNode", and Â« node Â». If this throws an
     * exception, then unset traverserâ€™s active flag and rethrow the exception.
     */
    var result = interfaces_1.FilterResult.Reject;
    try {
        result = traverser.filter.acceptNode(node);
    }
    catch (err) {
        traverser._activeFlag = false;
        throw err;
    }
    /**
     * 7. Unset traverserâ€™s active flag.
     * 8. Return result.
     */
    traverser._activeFlag = false;
    return result;
}
exports.traversal_filter = traversal_filter;
//# sourceMappingURL=TraversalAlgorithm.js.map

/***/ }),

/***/ 6620:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(5282);
var interfaces_1 = __nccwpck_require__(7305);
/**
 * Gets the next descendant of the given node of the tree rooted at `root`
 * in depth-first pre-order.
 *
 * @param root - root node of the tree
 * @param node - a node
 * @param shadow - whether to visit shadow tree nodes
 */
function _getNextDescendantNode(root, node, shadow) {
    if (shadow === void 0) { shadow = false; }
    // traverse shadow tree
    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
        if (node.shadowRoot._firstChild)
            return node.shadowRoot._firstChild;
    }
    // traverse child nodes
    if (node._firstChild)
        return node._firstChild;
    if (node === root)
        return null;
    // traverse siblings
    if (node._nextSibling)
        return node._nextSibling;
    // traverse parent's next sibling
    var parent = node._parent;
    while (parent && parent !== root) {
        if (parent._nextSibling)
            return parent._nextSibling;
        parent = parent._parent;
    }
    return null;
}
function _emptyIterator() {
    var _a;
    return _a = {},
        _a[Symbol.iterator] = function () {
            return {
                next: function () {
                    return { done: true, value: null };
                }
            };
        },
        _a;
}
/**
 * Returns the first descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getFirstDescendantNode(node, self, shadow, filter) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var firstNode = (self ? node : _getNextDescendantNode(node, node, shadow));
    while (firstNode && filter && !filter(firstNode)) {
        firstNode = _getNextDescendantNode(node, firstNode, shadow);
    }
    return firstNode;
}
exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
/**
 * Returns the next descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param currentNode - current descendant node
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getNextDescendantNode(node, currentNode, self, shadow, filter) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var nextNode = _getNextDescendantNode(node, currentNode, shadow);
    while (nextNode && filter && !filter(nextNode)) {
        nextNode = _getNextDescendantNode(node, nextNode, shadow);
    }
    return nextNode;
}
exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
/**
 * Traverses through all descendant nodes of the tree rooted at
 * `node` in depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getDescendantNodes(node, self, shadow, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = (self ? node : _getNextDescendantNode(node, node, shadow));
            return {
                next: function () {
                    while (currentNode && filter && !filter(currentNode)) {
                        currentNode = _getNextDescendantNode(node, currentNode, shadow);
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = _getNextDescendantNode(node, currentNode, shadow);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getDescendantNodes = tree_getDescendantNodes;
/**
 * Traverses through all descendant element nodes of the tree rooted at
 * `node` in depth-first preorder.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */
function tree_getDescendantElements(node, self, shadow, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var it = tree_getDescendantNodes(node, self, shadow, function (e) { return util_1.Guard.isElementNode(e); })[Symbol.iterator]();
            var currentNode = it.next().value;
            return {
                next: function () {
                    while (currentNode && filter && !filter(currentNode)) {
                        currentNode = it.next().value;
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = it.next().value;
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getDescendantElements = tree_getDescendantElements;
/**
 * Traverses through all sibling nodes of `node`.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getSiblingNodes(node, self, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (!node._parent || node._parent._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = node._parent ? node._parent._firstChild : null;
            return {
                next: function () {
                    while (currentNode && (filter && !filter(currentNode) || (!self && currentNode === node))) {
                        currentNode = currentNode._nextSibling;
                    }
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = currentNode._nextSibling;
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getSiblingNodes = tree_getSiblingNodes;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getFirstAncestorNode(node, self, filter) {
    if (self === void 0) { self = false; }
    var firstNode = self ? node : node._parent;
    while (firstNode && filter && !filter(firstNode)) {
        firstNode = firstNode._parent;
    }
    return firstNode;
}
exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getNextAncestorNode(node, currentNode, self, filter) {
    if (self === void 0) { self = false; }
    var nextNode = currentNode._parent;
    while (nextNode && filter && !filter(nextNode)) {
        nextNode = nextNode._parent;
    }
    return nextNode;
}
exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
/**
 * Traverses through all ancestor nodes `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */
function tree_getAncestorNodes(node, self, filter) {
    var _a;
    if (self === void 0) { self = false; }
    if (!self && !node._parent) {
        return _emptyIterator();
    }
    return _a = {},
        _a[Symbol.iterator] = function () {
            var currentNode = tree_getFirstAncestorNode(node, self, filter);
            return {
                next: function () {
                    if (currentNode === null) {
                        return { done: true, value: null };
                    }
                    else {
                        var result = { done: false, value: currentNode };
                        currentNode = tree_getNextAncestorNode(node, currentNode, self, filter);
                        return result;
                    }
                }
            };
        },
        _a;
}
exports.tree_getAncestorNodes = tree_getAncestorNodes;
/**
 * Returns the common ancestor of the given nodes.
 *
 * @param nodeA - a node
 * @param nodeB - a node
 */
function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
        return nodeA._parent;
    }
    // lists of parent nodes
    var parentsA = [];
    var parentsB = [];
    var pA = tree_getFirstAncestorNode(nodeA, true);
    while (pA !== null) {
        parentsA.push(pA);
        pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    var pB = tree_getFirstAncestorNode(nodeB, true);
    while (pB !== null) {
        parentsB.push(pB);
        pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    // walk through parents backwards until they differ
    var pos1 = parentsA.length;
    var pos2 = parentsB.length;
    var parent = null;
    for (var i = Math.min(pos1, pos2); i > 0; i--) {
        var parent1 = parentsA[--pos1];
        var parent2 = parentsB[--pos2];
        if (parent1 !== parent2) {
            break;
        }
        parent = parent1;
    }
    return parent;
}
exports.tree_getCommonAncestor = tree_getCommonAncestor;
/**
 * Returns the node following `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */
function tree_getFollowingNode(root, node) {
    if (node._firstChild) {
        return node._firstChild;
    }
    else if (node._nextSibling) {
        return node._nextSibling;
    }
    else {
        while (true) {
            var parent = node._parent;
            if (parent === null || parent === root) {
                return null;
            }
            else if (parent._nextSibling) {
                return parent._nextSibling;
            }
            else {
                node = parent;
            }
        }
    }
}
exports.tree_getFollowingNode = tree_getFollowingNode;
/**
 * Returns the node preceding `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */
function tree_getPrecedingNode(root, node) {
    if (node === root) {
        return null;
    }
    if (node._previousSibling) {
        node = node._previousSibling;
        if (node._lastChild) {
            return node._lastChild;
        }
        else {
            return node;
        }
    }
    else {
        return node._parent;
    }
}
exports.tree_getPrecedingNode = tree_getPrecedingNode;
/**
 * Determines if the node tree is constrained. A node tree is
 * constrained as follows, expressed as a relationship between the
 * type of node and its allowed children:
 *  - Document (In tree order)
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one DocumentType node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one Element node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *  - DocumentFragment, Element
 *    * Zero or more nodes each of which is Element, Text,
 *      ProcessingInstruction, or Comment.
 *  - DocumentType, Text, ProcessingInstruction, Comment
 *    * None.
 *
 * @param node - the root of the tree
 */
function tree_isConstrained(node) {
    var e_1, _a, e_2, _b, e_3, _c;
    switch (node._nodeType) {
        case interfaces_1.NodeType.Document:
            var hasDocType = false;
            var hasElement = false;
            try {
                for (var _d = __values(node._children), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var childNode = _e.value;
                    switch (childNode._nodeType) {
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.Comment:
                            break;
                        case interfaces_1.NodeType.DocumentType:
                            if (hasDocType || hasElement)
                                return false;
                            hasDocType = true;
                            break;
                        case interfaces_1.NodeType.Element:
                            if (hasElement)
                                return false;
                            hasElement = true;
                            break;
                        default:
                            return false;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_1) throw e_1.error; }
            }
            break;
        case interfaces_1.NodeType.DocumentFragment:
        case interfaces_1.NodeType.Element:
            try {
                for (var _f = __values(node._children), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var childNode = _g.value;
                    switch (childNode._nodeType) {
                        case interfaces_1.NodeType.Element:
                        case interfaces_1.NodeType.Text:
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.CData:
                        case interfaces_1.NodeType.Comment:
                            break;
                        default:
                            return false;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            break;
        case interfaces_1.NodeType.DocumentType:
        case interfaces_1.NodeType.Text:
        case interfaces_1.NodeType.ProcessingInstruction:
        case interfaces_1.NodeType.CData:
        case interfaces_1.NodeType.Comment:
            return (!node.hasChildNodes());
    }
    try {
        for (var _h = __values(node._children), _j = _h.next(); !_j.done; _j = _h.next()) {
            var childNode = _j.value;
            // recursively check child nodes
            if (!tree_isConstrained(childNode))
                return false;
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return true;
}
exports.tree_isConstrained = tree_isConstrained;
/**
 * Returns the length of a node.
 *
 * @param node - a node to check
 */
function tree_nodeLength(node) {
    /**
        * To determine the length of a node node, switch on node:
        * - DocumentType
        * Zero.
        * - Text
        * - ProcessingInstruction
        * - Comment
        * Its dataâ€™s length.
        * - Any other node
        * Its number of children.
        */
    if (util_1.Guard.isDocumentTypeNode(node)) {
        return 0;
    }
    else if (util_1.Guard.isCharacterDataNode(node)) {
        return node._data.length;
    }
    else {
        return node._children.size;
    }
}
exports.tree_nodeLength = tree_nodeLength;
/**
 * Determines if a node is empty.
 *
 * @param node - a node to check
 */
function tree_isEmpty(node) {
    /**
        * A node is considered empty if its length is zero.
        */
    return (tree_nodeLength(node) === 0);
}
exports.tree_isEmpty = tree_isEmpty;
/**
 * Returns the root node of a tree. The root of an object is itself,
 * if its parent is `null`, or else it is the root of its parent.
 * The root of a tree is any object participating in that tree
 * whose parent is `null`.
 *
 * @param node - a node of the tree
 * @param shadow - `true` to return shadow-including root, otherwise
 * `false`
 */
function tree_rootNode(node, shadow) {
    if (shadow === void 0) { shadow = false; }
    /**
        * The root of an object is itself, if its parent is null, or else it is the
        * root of its parent. The root of a tree is any object participating in
        * that tree whose parent is null.
        */
    if (shadow) {
        var root = tree_rootNode(node, false);
        if (util_1.Guard.isShadowRoot(root))
            return tree_rootNode(root._host, true);
        else
            return root;
    }
    else {
        if (!node._parent)
            return node;
        else
            return tree_rootNode(node._parent);
    }
}
exports.tree_rootNode = tree_rootNode;
/**
 * Determines whether `other` is a descendant of `node`. An object
 * A is called a descendant of an object B, if either A is a child
 * of B or A is a child of an object C that is a descendant of B.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */
function tree_isDescendantOf(node, other, self, shadow) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    /**
        * An object A is called a descendant of an object B, if either A is a
        * child of B or A is a child of an object C that is a descendant of B.
        *
        * An inclusive descendant is an object or one of its descendants.
    */
    var child = tree_getFirstDescendantNode(node, self, shadow);
    while (child !== null) {
        if (child === other) {
            return true;
        }
        child = tree_getNextDescendantNode(node, child, self, shadow);
    }
    return false;
}
exports.tree_isDescendantOf = tree_isDescendantOf;
/**
 * Determines whether `other` is an ancestor of `node`. An object A
 * is called an ancestor of an object B if and only if B is a
 * descendant of A.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */
function tree_isAncestorOf(node, other, self, shadow) {
    if (self === void 0) { self = false; }
    if (shadow === void 0) { shadow = false; }
    var ancestor = self ? node : shadow && util_1.Guard.isShadowRoot(node) ?
        node._host : node._parent;
    while (ancestor !== null) {
        if (ancestor === other)
            return true;
        ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ?
            ancestor._host : ancestor._parent;
    }
    return false;
}
exports.tree_isAncestorOf = tree_isAncestorOf;
/**
 * Determines whether `other` is a host-including ancestor of `node`. An
 * object A is a host-including inclusive ancestor of an object B, if either
 * A is an inclusive ancestor of B, or if Bâ€™s root has a non-null host and
 * A is a host-including inclusive ancestor of Bâ€™s rootâ€™s host.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */
function tree_isHostIncludingAncestorOf(node, other, self) {
    if (self === void 0) { self = false; }
    if (tree_isAncestorOf(node, other, self))
        return true;
    var root = tree_rootNode(node);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null &&
        tree_isHostIncludingAncestorOf(root._host, other, self))
        return true;
    return false;
}
exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
/**
 * Determines whether `other` is a sibling of `node`. An object A is
 * called a sibling of an object B, if and only if B and A share
 * the same non-null parent.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */
function tree_isSiblingOf(node, other, self) {
    if (self === void 0) { self = false; }
    /**
        * An object A is called a sibling of an object B, if and only if B and A
        * share the same non-null parent.
        *
        * An inclusive sibling is an object or one of its siblings.
        */
    if (node === other) {
        if (self)
            return true;
    }
    else {
        return (node._parent !== null && node._parent === other._parent);
    }
    return false;
}
exports.tree_isSiblingOf = tree_isSiblingOf;
/**
 * Determines whether `other` is preceding `node`. An object A is
 * preceding an object B if A and B are in the same tree and A comes
 * before B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isPreceding(node, other) {
    /**
        * An object A is preceding an object B if A and B are in the same tree and
        * A comes before B in tree order.
        */
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
        return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
        return false;
    else
        return otherPos < nodePos;
}
exports.tree_isPreceding = tree_isPreceding;
/**
 * Determines whether `other` is following `node`. An object A is
 * following an object B if A and B are in the same tree and A comes
 * after B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isFollowing(node, other) {
    /**
        * An object A is following an object B if A and B are in the same tree and
        * A comes after B in tree order.
        */
    var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1)
        return false;
    else if (tree_rootNode(node) !== tree_rootNode(other))
        return false;
    else
        return otherPos > nodePos;
}
exports.tree_isFollowing = tree_isFollowing;
/**
 * Determines whether `other` is the parent node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isParentOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */
    return (node._parent === other);
}
exports.tree_isParentOf = tree_isParentOf;
/**
 * Determines whether `other` is a child node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_isChildOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */
    return (other._parent === node);
}
exports.tree_isChildOf = tree_isChildOf;
/**
 * Returns the previous sibling node of `node` or null if it has no
 * preceding sibling.
 *
 * @param node
 */
function tree_previousSibling(node) {
    /**
        * The previous sibling of an object is its first preceding sibling or null
        * if it has no preceding sibling.
        */
    return node._previousSibling;
}
exports.tree_previousSibling = tree_previousSibling;
/**
 * Returns the next sibling node of `node` or null if it has no
 * following sibling.
 *
 * @param node
 */
function tree_nextSibling(node) {
    /**
        * The next sibling of an object is its first following sibling or null
        * if it has no following sibling.
        */
    return node._nextSibling;
}
exports.tree_nextSibling = tree_nextSibling;
/**
 * Returns the first child node of `node` or null if it has no
 * children.
 *
 * @param node
 */
function tree_firstChild(node) {
    /**
        * The first child of an object is its first child or null if it has no
        * children.
        */
    return node._firstChild;
}
exports.tree_firstChild = tree_firstChild;
/**
 * Returns the last child node of `node` or null if it has no
 * children.
 *
 * @param node
 */
function tree_lastChild(node) {
    /**
        * The last child of an object is its last child or null if it has no
        * children.
        */
    return node._lastChild;
}
exports.tree_lastChild = tree_lastChild;
/**
 * Returns the zero-based index of `node` when counted preorder in
 * the tree rooted at `root`. Returns `-1` if `node` is not in
 * the tree.
 *
 * @param node - the node to get the index of
 */
function tree_treePosition(node) {
    var root = tree_rootNode(node);
    var pos = 0;
    var childNode = tree_getFirstDescendantNode(root);
    while (childNode !== null) {
        pos++;
        if (childNode === node)
            return pos;
        childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
}
exports.tree_treePosition = tree_treePosition;
/**
 * Determines the index of `node`. The index of an object is its number of
 * preceding siblings, or 0 if it has none.
 *
 * @param node - a node
 * @param other - the node to check
 */
function tree_index(node) {
    /**
        * The index of an object is its number of preceding siblings, or 0 if it
        * has none.
        */
    var n = 0;
    while (node._previousSibling !== null) {
        n++;
        node = node._previousSibling;
    }
    return n;
}
exports.tree_index = tree_index;
/**
 * Retargets an object against another object.
 *
 * @param a - an object to retarget
 * @param b - an object to retarget against
 */
function tree_retarget(a, b) {
    /**
        * To retarget an object A against an object B, repeat these steps until
        * they return an object:
        * 1. If one of the following is true
        * - A is not a node
        * - A's root is not a shadow root
        * - B is a node and A's root is a shadow-including inclusive ancestor
        * of B
        * then return A.
        * 2. Set A to A's root's host.
        */
    while (true) {
        if (!a || !util_1.Guard.isNode(a)) {
            return a;
        }
        var rootOfA = tree_rootNode(a);
        if (!util_1.Guard.isShadowRoot(rootOfA)) {
            return a;
        }
        if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
            return a;
        }
        a = rootOfA.host;
    }
}
exports.tree_retarget = tree_retarget;
//# sourceMappingURL=TreeAlgorithm.js.map

/***/ }),

/***/ 4962:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var TraversalAlgorithm_1 = __nccwpck_require__(998);
/**
 * Returns the first or last child node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param first - `true` to return the first child node, or `false` to
 * return the last child node.
 */
function treeWalker_traverseChildren(walker, first) {
    /**
     * 1. Let node be walkerâ€™s current.
     * 2. Set node to nodeâ€™s first child if type is first, and nodeâ€™s last child
     * if type is last.
     * 3. While node is non-null:
     */
    var node = (first ? walker._current._firstChild : walker._current._lastChild);
    while (node !== null) {
        /**
         * 3.1. Let result be the result of filtering node within walker.
         */
        var result = TraversalAlgorithm_1.traversal_filter(walker, node);
        if (result === interfaces_1.FilterResult.Accept) {
            /**
             * 3.2. If result is FILTER_ACCEPT, then set walkerâ€™s current to node and
             * return node.
             */
            walker._current = node;
            return node;
        }
        else if (result === interfaces_1.FilterResult.Skip) {
            /**
             * 3.3. If result is FILTER_SKIP, then:
             * 3.3.1. Let child be nodeâ€™s first child if type is first, and nodeâ€™s
             * last child if type is last.
             * 3.3.2. If child is non-null, then set node to child and continue.
             */
            var child = (first ? node._firstChild : node._lastChild);
            if (child !== null) {
                node = child;
                continue;
            }
        }
        /**
         * 3.4. While node is non-null:
         */
        while (node !== null) {
            /**
             * 3.4.1. Let sibling be nodeâ€™s next sibling if type is first, and
             * nodeâ€™s previous sibling if type is last.
             * 3.4.2. If sibling is non-null, then set node to sibling and break.
             */
            var sibling = (first ? node._nextSibling : node._previousSibling);
            if (sibling !== null) {
                node = sibling;
                break;
            }
            /**
             * 3.4.3. Let parent be nodeâ€™s parent.
             * 3.4.4. If parent is null, walkerâ€™s root, or walkerâ€™s current, then
             * return null.
             */
            var parent = node._parent;
            if (parent === null || parent === walker._root || parent === walker._current) {
                return null;
            }
            /**
             * 3.4.5. Set node to parent.
             */
            node = parent;
        }
    }
    /**
     * 5. Return null
     */
    return null;
}
exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
/**
 * Returns the next or previous sibling node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param next - `true` to return the next sibling node, or `false` to
 * return the previous sibling node.
 */
function treeWalker_traverseSiblings(walker, next) {
    /**
     * 1. Let node be walkerâ€™s current.
     * 2. If node is root, then return null.
     * 3. While node is non-null:
     */
    var node = walker._current;
    if (node === walker._root)
        return null;
    while (true) {
        /**
         * 3.1. Let sibling be nodeâ€™s next sibling if type is next, and nodeâ€™s
         * previous sibling if type is previous.
         * 3.2. While sibling is non-null:
         */
        var sibling = (next ? node._nextSibling : node._previousSibling);
        while (sibling !== null) {
            /**
             * 3.2.1. Set node to sibling.
             * 3.2.2. Let result be the result of filtering node within walker.
             * 3.2.3. If result is FILTER_ACCEPT, then set walkerâ€™s current to node
             * and return node.
             */
            node = sibling;
            var result = TraversalAlgorithm_1.traversal_filter(walker, node);
            if (result === interfaces_1.FilterResult.Accept) {
                walker._current = node;
                return node;
            }
            /**
             * 3.2.4. Set sibling to nodeâ€™s first child if type is next, and nodeâ€™s
             * last child if type is previous.
             * 3.2.5. If result is FILTER_REJECT or sibling is null, then set
             * sibling to nodeâ€™s next sibling if type is next, and nodeâ€™s previous
             * sibling if type is previous.
             */
            sibling = (next ? node._firstChild : node._lastChild);
            if (result === interfaces_1.FilterResult.Reject || sibling === null) {
                sibling = (next ? node._nextSibling : node._previousSibling);
            }
        }
        /**
         * 3.3. Set node to nodeâ€™s parent.
         * 3.4. If node is null or walkerâ€™s root, then return null.
         */
        node = node._parent;
        if (node === null || node === walker._root) {
            return null;
        }
        /**
         * 3.5. If the return value of filtering node within walker is FILTER_ACCEPT,
         * then return null.
         */
        if (TraversalAlgorithm_1.traversal_filter(walker, node) === interfaces_1.FilterResult.Accept) {
            return null;
        }
    }
}
exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings;
//# sourceMappingURL=TreeWalkerAlgorithm.js.map

/***/ }),

/***/ 5457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines a WebIDL `Const` property on the given object.
 *
 * @param o - object on which to add the property
 * @param name - property name
 * @param value - property value
 */
function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, { writable: false, enumerable: true, configurable: false, value: value });
}
exports.idl_defineConst = idl_defineConst;
//# sourceMappingURL=WebIDLAlgorithm.js.map

/***/ }),

/***/ 7030:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Determines if the given string is valid for a `"Name"` construct.
 *
 * @param name - name string to test
 */
function xml_isName(name) {
    for (var i = 0; i < name.length; i++) {
        var n = name.charCodeAt(i);
        // NameStartChar
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            n === 58 || n === 95 || // ':' or '_'
            (n >= 0xC0 && n <= 0xD6) ||
            (n >= 0xD8 && n <= 0xF6) ||
            (n >= 0xF8 && n <= 0x2FF) ||
            (n >= 0x370 && n <= 0x37D) ||
            (n >= 0x37F && n <= 0x1FFF) ||
            (n >= 0x200C && n <= 0x200D) ||
            (n >= 0x2070 && n <= 0x218F) ||
            (n >= 0x2C00 && n <= 0x2FEF) ||
            (n >= 0x3001 && n <= 0xD7FF) ||
            (n >= 0xF900 && n <= 0xFDCF) ||
            (n >= 0xFDF0 && n <= 0xFFFD)) {
            continue;
        }
        else if (i !== 0 &&
            (n === 45 || n === 46 || // '-' or '.'
                (n >= 48 && n <= 57) || // [0-9]
                (n === 0xB7) ||
                (n >= 0x0300 && n <= 0x036F) ||
                (n >= 0x203F && n <= 0x2040))) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isName = xml_isName;
/**
 * Determines if the given string is valid for a `"QName"` construct.
 *
 * @param name - name string to test
 */
function xml_isQName(name) {
    var colonFound = false;
    for (var i = 0; i < name.length; i++) {
        var n = name.charCodeAt(i);
        // NameStartChar
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            n === 95 || // '_'
            (n >= 0xC0 && n <= 0xD6) ||
            (n >= 0xD8 && n <= 0xF6) ||
            (n >= 0xF8 && n <= 0x2FF) ||
            (n >= 0x370 && n <= 0x37D) ||
            (n >= 0x37F && n <= 0x1FFF) ||
            (n >= 0x200C && n <= 0x200D) ||
            (n >= 0x2070 && n <= 0x218F) ||
            (n >= 0x2C00 && n <= 0x2FEF) ||
            (n >= 0x3001 && n <= 0xD7FF) ||
            (n >= 0xF900 && n <= 0xFDCF) ||
            (n >= 0xFDF0 && n <= 0xFFFD)) {
            continue;
        }
        else if (i !== 0 &&
            (n === 45 || n === 46 || // '-' or '.'
                (n >= 48 && n <= 57) || // [0-9]
                (n === 0xB7) ||
                (n >= 0x0300 && n <= 0x036F) ||
                (n >= 0x203F && n <= 0x2040))) {
            continue;
        }
        else if (i !== 0 && n === 58) { // :
            if (colonFound)
                return false; // multiple colons in qname
            if (i === name.length - 1)
                return false; // colon at the end of qname
            colonFound = true;
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isQName = xml_isQName;
/**
 * Determines if the given string contains legal characters.
 *
 * @param chars - sequence of characters to test
 */
function xml_isLegalChar(chars) {
    for (var i = 0; i < chars.length; i++) {
        var n = chars.charCodeAt(i);
        // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
        if (n === 0x9 || n === 0xA || n === 0xD ||
            (n >= 0x20 && n <= 0xD7FF) ||
            (n >= 0xE000 && n <= 0xFFFD)) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < chars.length - 1) {
            var n2 = chars.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0x10FFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isLegalChar = xml_isLegalChar;
/**
 * Determines if the given string contains legal characters for a public
 * identifier.
 *
 * @param chars - sequence of characters to test
 */
function xml_isPubidChar(chars) {
    for (var i = 0; i < chars.length; i++) {
        // PubId chars are all in the ASCII range, no need to check surrogates
        var n = chars.charCodeAt(i);
        // #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
        if ((n >= 97 && n <= 122) || // [a-z]
            (n >= 65 && n <= 90) || // [A-Z]
            (n >= 39 && n <= 59) || // ['()*+,-./] | [0-9] | [:;]
            n === 0x20 || n === 0xD || n === 0xA || // #x20 | #xD | #xA
            (n >= 35 && n <= 37) || // [#$%]
            n === 33 || // !
            n === 61 || n === 63 || n === 64 || n === 95) { // [=?@_]
            continue;
        }
        else {
            return false;
        }
    }
    return true;
}
exports.xml_isPubidChar = xml_isPubidChar;
//# sourceMappingURL=XMLAlgorithm.js.map

/***/ }),

/***/ 61:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
__export(__nccwpck_require__(2206));
__export(__nccwpck_require__(4309));
__export(__nccwpck_require__(1054));
__export(__nccwpck_require__(9461));
__export(__nccwpck_require__(7339));
__export(__nccwpck_require__(5648));
__export(__nccwpck_require__(2793));
__export(__nccwpck_require__(9628));
__export(__nccwpck_require__(3261));
__export(__nccwpck_require__(3220));
__export(__nccwpck_require__(8217));
__export(__nccwpck_require__(1312));
__export(__nccwpck_require__(5463));
__export(__nccwpck_require__(8157));
__export(__nccwpck_require__(5856));
__export(__nccwpck_require__(4924));
__export(__nccwpck_require__(9989));
__export(__nccwpck_require__(3670));
__export(__nccwpck_require__(2328));
__export(__nccwpck_require__(457));
__export(__nccwpck_require__(1853));
__export(__nccwpck_require__(8733));
__export(__nccwpck_require__(3512));
__export(__nccwpck_require__(998));
__export(__nccwpck_require__(6620));
__export(__nccwpck_require__(4962));
__export(__nccwpck_require__(5457));
__export(__nccwpck_require__(7030));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6461:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a controller that allows to abort DOM requests.
 */
var AbortControllerImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `AbortController`.
     */
    function AbortControllerImpl() {
        /**
         * 1. Let signal be a new AbortSignal object.
         * 2. Let controller be a new AbortController object whose signal is signal.
         * 3. Return controller.
         */
        this._signal = algorithm_1.create_abortSignal();
    }
    Object.defineProperty(AbortControllerImpl.prototype, "signal", {
        /** @inheritdoc */
        get: function () { return this._signal; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    AbortControllerImpl.prototype.abort = function () {
        algorithm_1.abort_signalAbort(this._signal);
    };
    return AbortControllerImpl;
}());
exports.AbortControllerImpl = AbortControllerImpl;
//# sourceMappingURL=AbortControllerImpl.js.map

/***/ }),

/***/ 22:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventTargetImpl_1 = __nccwpck_require__(9968);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a signal object that communicates with a DOM request and abort
 * it through an AbortController.
 */
var AbortSignalImpl = /** @class */ (function (_super) {
    __extends(AbortSignalImpl, _super);
    /**
     * Initializes a new instance of `AbortSignal`.
     */
    function AbortSignalImpl() {
        var _this = _super.call(this) || this;
        _this._abortedFlag = false;
        _this._abortAlgorithms = new Set();
        return _this;
    }
    Object.defineProperty(AbortSignalImpl.prototype, "aborted", {
        /** @inheritdoc */
        get: function () { return this._abortedFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbortSignalImpl.prototype, "onabort", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.event_getterEventHandlerIDLAttribute(this, "onabort");
        },
        set: function (val) {
            algorithm_1.event_setterEventHandlerIDLAttribute(this, "onabort", val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `AbortSignal`.
     */
    AbortSignalImpl._create = function () {
        return new AbortSignalImpl();
    };
    return AbortSignalImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.AbortSignalImpl = AbortSignalImpl;
//# sourceMappingURL=AbortSignalImpl.js.map

/***/ }),

/***/ 7126:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents an abstract range with a start and end boundary point.
 */
var AbstractRangeImpl = /** @class */ (function () {
    function AbstractRangeImpl() {
    }
    Object.defineProperty(AbstractRangeImpl.prototype, "_startNode", {
        get: function () { return this._start[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_startOffset", {
        get: function () { return this._start[1]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endNode", {
        get: function () { return this._end[0]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endOffset", {
        get: function () { return this._end[1]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_collapsed", {
        get: function () {
            return (this._start[0] === this._end[0] &&
                this._start[1] === this._end[1]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startContainer", {
        /** @inheritdoc */
        get: function () { return this._startNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startOffset", {
        /** @inheritdoc */
        get: function () { return this._startOffset; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endContainer", {
        /** @inheritdoc */
        get: function () { return this._endNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endOffset", {
        /** @inheritdoc */
        get: function () { return this._endOffset; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "collapsed", {
        /** @inheritdoc */
        get: function () { return this._collapsed; },
        enumerable: true,
        configurable: true
    });
    return AbstractRangeImpl;
}());
exports.AbstractRangeImpl = AbstractRangeImpl;
//# sourceMappingURL=AbstractRangeImpl.js.map

/***/ }),

/***/ 7875:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var NodeImpl_1 = __nccwpck_require__(1745);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents an attribute of an element node.
 */
var AttrImpl = /** @class */ (function (_super) {
    __extends(AttrImpl, _super);
    /**
     * Initializes a new instance of `Attr`.
     *
     * @param localName - local name
     */
    function AttrImpl(localName) {
        var _this = _super.call(this) || this;
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._element = null;
        _this._value = '';
        _this._localName = localName;
        return _this;
    }
    Object.defineProperty(AttrImpl.prototype, "ownerElement", {
        /** @inheritdoc */
        get: function () { return this._element; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "namespaceURI", {
        /** @inheritdoc */
        get: function () { return this._namespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "prefix", {
        /** @inheritdoc */
        get: function () { return this._namespacePrefix; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "localName", {
        /** @inheritdoc */
        get: function () { return this._localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "name", {
        /** @inheritdoc */
        get: function () { return this._qualifiedName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "value", {
        /** @inheritdoc */
        get: function () { return this._value; },
        set: function (value) {
            /**
             * The value attributeâ€™s setter must set an existing attribute value with
             * context object and the given value.
             */
            algorithm_1.attr_setAnExistingAttributeValue(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */
        get: function () {
            /**
             * An attributeâ€™s qualified name is its local name if its namespace prefix
             * is null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */
            return (this._namespacePrefix !== null ?
                this._namespacePrefix + ':' + this._localName :
                this._localName);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates an `Attr`.
     *
     * @param document - owner document
     * @param localName - local name
     */
    AttrImpl._create = function (document, localName) {
        var node = new AttrImpl(localName);
        node._nodeDocument = document;
        return node;
    };
    return AttrImpl;
}(NodeImpl_1.NodeImpl));
exports.AttrImpl = AttrImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "specified", true);
//# sourceMappingURL=AttrImpl.js.map

/***/ }),

/***/ 3977:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TextImpl_1 = __nccwpck_require__(2191);
var interfaces_1 = __nccwpck_require__(7305);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a CDATA node.
 */
var CDATASectionImpl = /** @class */ (function (_super) {
    __extends(CDATASectionImpl, _super);
    /**
     * Initializes a new instance of `CDATASection`.
     *
     * @param data - node contents
     */
    function CDATASectionImpl(data) {
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `CDATASection`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    CDATASectionImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new CDATASectionImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CDATASectionImpl;
}(TextImpl_1.TextImpl));
exports.CDATASectionImpl = CDATASectionImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData);
//# sourceMappingURL=CDATASectionImpl.js.map

/***/ }),

/***/ 5330:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NodeImpl_1 = __nccwpck_require__(1745);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a generic text node.
 */
var CharacterDataImpl = /** @class */ (function (_super) {
    __extends(CharacterDataImpl, _super);
    /**
     * Initializes a new instance of `CharacterData`.
     *
     * @param data - the text content
     */
    function CharacterDataImpl(data) {
        var _this = _super.call(this) || this;
        _this._data = data;
        return _this;
    }
    Object.defineProperty(CharacterDataImpl.prototype, "data", {
        /** @inheritdoc */
        get: function () { return this._data; },
        set: function (value) {
            algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () { return this._data.length; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    CharacterDataImpl.prototype.substringData = function (offset, count) {
        /**
         * The substringData(offset, count) method, when invoked, must return the
         * result of running substring data with node context object, offset offset, and count count.
         */
        return algorithm_1.characterData_substringData(this, offset, count);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.appendData = function (data) {
        /**
         * The appendData(data) method, when invoked, must replace data with node
         * context object, offset context objectâ€™s length, count 0, and data data.
         */
        return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.insertData = function (offset, data) {
        /**
         * The insertData(offset, data) method, when invoked, must replace data with
         * node context object, offset offset, count 0, and data data.
         */
        algorithm_1.characterData_replaceData(this, offset, 0, data);
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.deleteData = function (offset, count) {
        /**
         * The deleteData(offset, count) method, when invoked, must replace data
         * with node context object, offset offset, count count, and data the
         * empty string.
         */
        algorithm_1.characterData_replaceData(this, offset, count, '');
    };
    /** @inheritdoc */
    CharacterDataImpl.prototype.replaceData = function (offset, count, data) {
        /**
         * The replaceData(offset, count, data) method, when invoked, must replace
         * data with node context object, offset offset, count count, and data data.
         */
        algorithm_1.characterData_replaceData(this, offset, count, data);
    };
    Object.defineProperty(CharacterDataImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    CharacterDataImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    CharacterDataImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    return CharacterDataImpl;
}(NodeImpl_1.NodeImpl));
exports.CharacterDataImpl = CharacterDataImpl;
//# sourceMappingURL=CharacterDataImpl.js.map

/***/ }),

/***/ 8264:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(5282);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * including doctypes. This mixin is implemented by {@link Element},
 * {@link CharacterData} and {@link DocumentType}.
 */
var ChildNodeImpl = /** @class */ (function () {
    function ChildNodeImpl() {
    }
    /** @inheritdoc */
    ChildNodeImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context objectâ€™s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (parent === null)
            return;
        /**
         * 3. Let viablePreviousSibling be context objectâ€™s first preceding
         * sibling not in nodes, and null otherwise.
         */
        var viablePreviousSibling = context._previousSibling;
        var flag = true;
        while (flag && viablePreviousSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viablePreviousSibling) {
                    viablePreviousSibling = viablePreviousSibling._previousSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context objectâ€™s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If viablePreviousSibling is null, set it to parentâ€™s first child,
         * and to viablePreviousSiblingâ€™s next sibling otherwise.
         */
        if (viablePreviousSibling === null)
            viablePreviousSibling = parent._firstChild;
        else
            viablePreviousSibling = viablePreviousSibling._nextSibling;
        /**
         * 6. Pre-insert node into parent before viablePreviousSibling.
         */
        algorithm_1.mutation_preInsert(node, parent, viablePreviousSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context objectâ€™s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        /**
         * 3. Let viableNextSibling be context objectâ€™s first following sibling not
         * in nodes, and null otherwise.
         */
        var viableNextSibling = context._nextSibling;
        var flag = true;
        while (flag && viableNextSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context objectâ€™s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. Pre-insert node into parent before viableNextSibling.
         */
        algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context objectâ€™s parent.
         * 2. If parent is null, then return.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        /**
         * 3. Let viableNextSibling be context objectâ€™s first following sibling not
         * in nodes, and null otherwise.
         */
        var viableNextSibling = context._nextSibling;
        var flag = true;
        while (flag && viableNextSibling) {
            flag = false;
            for (var i = 0; i < nodes.length; i++) {
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context objectâ€™s node document.
         */
        var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If context objectâ€™s parent is parent, replace the context object with
         * node within parent.
         * _Note:_ Context object could have been inserted into node.
         * 6. Otherwise, pre-insert node into parent before viableNextSibling.
         */
        if (context._parent === parent)
            algorithm_1.mutation_replace(context, node, parent);
        else
            algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */
    ChildNodeImpl.prototype.remove = function () {
        /**
         * 1. If context objectâ€™s parent is null, then return.
         * 2. Remove the context object from context objectâ€™s parent.
         */
        var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent)
            return;
        algorithm_1.mutation_remove(context, parent);
    };
    return ChildNodeImpl;
}());
exports.ChildNodeImpl = ChildNodeImpl;
//# sourceMappingURL=ChildNodeImpl.js.map

/***/ }),

/***/ 930:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var CharacterDataImpl_1 = __nccwpck_require__(5330);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a comment node.
 */
var CommentImpl = /** @class */ (function (_super) {
    __extends(CommentImpl, _super);
    /**
     * Initializes a new instance of `Comment`.
     *
     * @param data - the text content
     */
    function CommentImpl(data) {
        if (data === void 0) { data = ''; }
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `Comment`.
     *
     * @param document - owner document
     * @param data - node contents
     */
    CommentImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new CommentImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CommentImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.CommentImpl = CommentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment);
//# sourceMappingURL=CommentImpl.js.map

/***/ }),

/***/ 9857:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventImpl_1 = __nccwpck_require__(8245);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents and event that carries custom data.
 */
var CustomEventImpl = /** @class */ (function (_super) {
    __extends(CustomEventImpl, _super);
    /**
     * Initializes a new instance of `CustomEvent`.
     */
    function CustomEventImpl(type, eventInit) {
        var _this = _super.call(this, type, eventInit) || this;
        _this._detail = null;
        _this._detail = (eventInit && eventInit.detail) || null;
        return _this;
    }
    Object.defineProperty(CustomEventImpl.prototype, "detail", {
        /** @inheritdoc */
        get: function () { return this._detail; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    CustomEventImpl.prototype.initCustomEvent = function (type, bubbles, cancelable, detail) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = false; }
        if (detail === void 0) { detail = null; }
        /**
         * 1. If the context objectâ€™s dispatch flag is set, then return.
         */
        if (this._dispatchFlag)
            return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */
        algorithm_1.event_initialize(this, type, bubbles, cancelable);
        /**
         * 3. Set the context objectâ€™s detail attribute to detail.
         */
        this._detail = detail;
    };
    return CustomEventImpl;
}(EventImpl_1.EventImpl));
exports.CustomEventImpl = CustomEventImpl;
//# sourceMappingURL=CustomEventImpl.js.map

/***/ }),

/***/ 3166:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents the base class of `Error` objects used by this module.
 */
var DOMException = /** @class */ (function (_super) {
    __extends(DOMException, _super);
    /**
     *
     * @param name - message name
     * @param message - error message
     */
    function DOMException(name, message) {
        if (message === void 0) { message = ""; }
        var _this = _super.call(this, message) || this;
        _this.name = name;
        return _this;
    }
    return DOMException;
}(Error));
exports.DOMException = DOMException;
var DOMStringSizeError = /** @class */ (function (_super) {
    __extends(DOMStringSizeError, _super);
    /**
    * @param message - error message
    */
    function DOMStringSizeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "DOMStringSizeError", message) || this;
    }
    return DOMStringSizeError;
}(DOMException));
exports.DOMStringSizeError = DOMStringSizeError;
var WrongDocumentError = /** @class */ (function (_super) {
    __extends(WrongDocumentError, _super);
    /**
    * @param message - error message
    */
    function WrongDocumentError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "WrongDocumentError", "The object is in the wrong document. " + message) || this;
    }
    return WrongDocumentError;
}(DOMException));
exports.WrongDocumentError = WrongDocumentError;
var NoDataAllowedError = /** @class */ (function (_super) {
    __extends(NoDataAllowedError, _super);
    /**
    * @param message - error message
    */
    function NoDataAllowedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NoDataAllowedError", message) || this;
    }
    return NoDataAllowedError;
}(DOMException));
exports.NoDataAllowedError = NoDataAllowedError;
var NoModificationAllowedError = /** @class */ (function (_super) {
    __extends(NoModificationAllowedError, _super);
    /**
    * @param message - error message
    */
    function NoModificationAllowedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NoModificationAllowedError", "The object can not be modified. " + message) || this;
    }
    return NoModificationAllowedError;
}(DOMException));
exports.NoModificationAllowedError = NoModificationAllowedError;
var NotSupportedError = /** @class */ (function (_super) {
    __extends(NotSupportedError, _super);
    /**
    * @param message - error message
    */
    function NotSupportedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotSupportedError", "The operation is not supported. " + message) || this;
    }
    return NotSupportedError;
}(DOMException));
exports.NotSupportedError = NotSupportedError;
var InUseAttributeError = /** @class */ (function (_super) {
    __extends(InUseAttributeError, _super);
    /**
    * @param message - error message
    */
    function InUseAttributeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InUseAttributeError", message) || this;
    }
    return InUseAttributeError;
}(DOMException));
exports.InUseAttributeError = InUseAttributeError;
var InvalidStateError = /** @class */ (function (_super) {
    __extends(InvalidStateError, _super);
    /**
    * @param message - error message
    */
    function InvalidStateError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidStateError", "The object is in an invalid state. " + message) || this;
    }
    return InvalidStateError;
}(DOMException));
exports.InvalidStateError = InvalidStateError;
var InvalidModificationError = /** @class */ (function (_super) {
    __extends(InvalidModificationError, _super);
    /**
    * @param message - error message
    */
    function InvalidModificationError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidModificationError", "The object can not be modified in this way. " + message) || this;
    }
    return InvalidModificationError;
}(DOMException));
exports.InvalidModificationError = InvalidModificationError;
var NamespaceError = /** @class */ (function (_super) {
    __extends(NamespaceError, _super);
    /**
    * @param message - error message
    */
    function NamespaceError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message) || this;
    }
    return NamespaceError;
}(DOMException));
exports.NamespaceError = NamespaceError;
var InvalidAccessError = /** @class */ (function (_super) {
    __extends(InvalidAccessError, _super);
    /**
    * @param message - error message
    */
    function InvalidAccessError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + message) || this;
    }
    return InvalidAccessError;
}(DOMException));
exports.InvalidAccessError = InvalidAccessError;
var ValidationError = /** @class */ (function (_super) {
    __extends(ValidationError, _super);
    /**
    * @param message - error message
    */
    function ValidationError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "ValidationError", message) || this;
    }
    return ValidationError;
}(DOMException));
exports.ValidationError = ValidationError;
var TypeMismatchError = /** @class */ (function (_super) {
    __extends(TypeMismatchError, _super);
    /**
    * @param message - error message
    */
    function TypeMismatchError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "TypeMismatchError", message) || this;
    }
    return TypeMismatchError;
}(DOMException));
exports.TypeMismatchError = TypeMismatchError;
var SecurityError = /** @class */ (function (_super) {
    __extends(SecurityError, _super);
    /**
    * @param message - error message
    */
    function SecurityError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "SecurityError", "The operation is insecure. " + message) || this;
    }
    return SecurityError;
}(DOMException));
exports.SecurityError = SecurityError;
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    /**
    * @param message - error message
    */
    function NetworkError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NetworkError", "A network error occurred. " + message) || this;
    }
    return NetworkError;
}(DOMException));
exports.NetworkError = NetworkError;
var AbortError = /** @class */ (function (_super) {
    __extends(AbortError, _super);
    /**
    * @param message - error message
    */
    function AbortError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "AbortError", "The operation was aborted. " + message) || this;
    }
    return AbortError;
}(DOMException));
exports.AbortError = AbortError;
var URLMismatchError = /** @class */ (function (_super) {
    __extends(URLMismatchError, _super);
    /**
    * @param message - error message
    */
    function URLMismatchError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "URLMismatchError", "The given URL does not match another URL. " + message) || this;
    }
    return URLMismatchError;
}(DOMException));
exports.URLMismatchError = URLMismatchError;
var QuotaExceededError = /** @class */ (function (_super) {
    __extends(QuotaExceededError, _super);
    /**
    * @param message - error message
    */
    function QuotaExceededError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "QuotaExceededError", "The quota has been exceeded. " + message) || this;
    }
    return QuotaExceededError;
}(DOMException));
exports.QuotaExceededError = QuotaExceededError;
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    /**
    * @param message - error message
    */
    function TimeoutError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "TimeoutError", "The operation timed out. " + message) || this;
    }
    return TimeoutError;
}(DOMException));
exports.TimeoutError = TimeoutError;
var InvalidNodeTypeError = /** @class */ (function (_super) {
    __extends(InvalidNodeTypeError, _super);
    /**
    * @param message - error message
    */
    function InvalidNodeTypeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message) || this;
    }
    return InvalidNodeTypeError;
}(DOMException));
exports.InvalidNodeTypeError = InvalidNodeTypeError;
var DataCloneError = /** @class */ (function (_super) {
    __extends(DataCloneError, _super);
    /**
    * @param message - error message
    */
    function DataCloneError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "DataCloneError", "The object can not be cloned. " + message) || this;
    }
    return DataCloneError;
}(DOMException));
exports.DataCloneError = DataCloneError;
var NotImplementedError = /** @class */ (function (_super) {
    __extends(NotImplementedError, _super);
    /**
    * @param message - error message
    */
    function NotImplementedError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + message) || this;
    }
    return NotImplementedError;
}(DOMException));
exports.NotImplementedError = NotImplementedError;
var HierarchyRequestError = /** @class */ (function (_super) {
    __extends(HierarchyRequestError, _super);
    /**
     * @param message - error message
     */
    function HierarchyRequestError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + message) || this;
    }
    return HierarchyRequestError;
}(DOMException));
exports.HierarchyRequestError = HierarchyRequestError;
var NotFoundError = /** @class */ (function (_super) {
    __extends(NotFoundError, _super);
    /**
     * @param message - error message
     */
    function NotFoundError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "NotFoundError", "The object can not be found here. " + message) || this;
    }
    return NotFoundError;
}(DOMException));
exports.NotFoundError = NotFoundError;
var IndexSizeError = /** @class */ (function (_super) {
    __extends(IndexSizeError, _super);
    /**
     * @param message - error message
     */
    function IndexSizeError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "IndexSizeError", "The index is not in the allowed range. " + message) || this;
    }
    return IndexSizeError;
}(DOMException));
exports.IndexSizeError = IndexSizeError;
var SyntaxError = /** @class */ (function (_super) {
    __extends(SyntaxError, _super);
    /**
     * @param message - error message
     */
    function SyntaxError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "SyntaxError", "The string did not match the expected pattern. " + message) || this;
    }
    return SyntaxError;
}(DOMException));
exports.SyntaxError = SyntaxError;
var InvalidCharacterError = /** @class */ (function (_super) {
    __extends(InvalidCharacterError, _super);
    /**
     * @param message - error message
     */
    function InvalidCharacterError(message) {
        if (message === void 0) { message = ""; }
        return _super.call(this, "InvalidCharacterError", "The string contains invalid characters. " + message) || this;
    }
    return InvalidCharacterError;
}(DOMException));
exports.InvalidCharacterError = InvalidCharacterError;
//# sourceMappingURL=DOMException.js.map

/***/ }),

/***/ 4177:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var CreateAlgorithm_1 = __nccwpck_require__(7339);
/**
 * Represents an object implementing DOM algorithms.
 */
var DOMImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOM`.
     */
    function DOMImpl() {
        this._features = {
            mutationObservers: true,
            customElements: true,
            slots: true,
            steps: true
        };
        this._window = null;
        this._compareCache = new util_1.CompareCache();
        this._rangeList = new util_1.FixedSizeSet();
    }
    /**
     * Sets DOM algorithm features.
     *
     * @param features - DOM features supported by algorithms. All features are
     * enabled by default unless explicity disabled.
     */
    DOMImpl.prototype.setFeatures = function (features) {
        if (features === undefined)
            features = true;
        if (util_1.isObject(features)) {
            for (var key in features) {
                this._features[key] = features[key] || false;
            }
        }
        else {
            // enable/disable all features
            for (var key in this._features) {
                this._features[key] = features;
            }
        }
    };
    Object.defineProperty(DOMImpl.prototype, "features", {
        /**
         * Gets DOM algorithm features.
         */
        get: function () { return this._features; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "window", {
        /**
         * Gets the DOM window.
         */
        get: function () {
            if (this._window === null) {
                this._window = CreateAlgorithm_1.create_window();
            }
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "compareCache", {
        /**
         * Gets the global node compare cache.
         */
        get: function () { return this._compareCache; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "rangeList", {
        /**
         * Gets the global range list.
         */
        get: function () { return this._rangeList; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl, "instance", {
        /**
         * Returns the instance of `DOM`.
         */
        get: function () {
            if (!DOMImpl._instance) {
                DOMImpl._instance = new DOMImpl();
            }
            return DOMImpl._instance;
        },
        enumerable: true,
        configurable: true
    });
    return DOMImpl;
}());
/**
 * Represents an object implementing DOM algorithms.
 */
exports.dom = DOMImpl.instance;
//# sourceMappingURL=DOMImpl.js.map

/***/ }),

/***/ 2197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document.
 */
var DOMImplementationImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOMImplementation`.
     *
     * @param document - the associated document
     */
    function DOMImplementationImpl(document) {
        this._associatedDocument = document || DOMImpl_1.dom.window.document;
    }
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createDocumentType = function (qualifiedName, publicId, systemId) {
        /**
         * 1. Validate qualifiedName.
         * 2. Return a new doctype, with qualifiedName as its name, publicId as its
         * public ID, and systemId as its system ID, and with its node document set
         * to the associated document of the context object.
         */
        algorithm_1.namespace_validate(qualifiedName);
        return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createDocument = function (namespace, qualifiedName, doctype) {
        if (doctype === void 0) { doctype = null; }
        /**
         * 1. Let document be a new XMLDocument.
         */
        var document = algorithm_1.create_xmlDocument();
        /**
         * 2. Let element be null.
         * 3. If qualifiedName is not the empty string, then set element to
         * the result of running the internal createElementNS steps, given document,
         * namespace, qualifiedName, and an empty dictionary.
         */
        var element = null;
        if (qualifiedName) {
            element = algorithm_1.document_internalCreateElementNS(document, namespace, qualifiedName);
        }
        /**
         * 4. If doctype is non-null, append doctype to document.
         * 5. If element is non-null, append element to document.
         */
        if (doctype)
            document.appendChild(doctype);
        if (element)
            document.appendChild(element);
        /**
         * 6. documentâ€™s origin is context objectâ€™s associated documentâ€™s origin.
         */
        document._origin = this._associatedDocument._origin;
        /**
         * 7. documentâ€™s content type is determined by namespace:
         * - HTML namespace
         * application/xhtml+xml
         * - SVG namespace
         * image/svg+xml
         * - Any other namespace
         * application/xml
         */
        if (namespace === infra_1.namespace.HTML)
            document._contentType = "application/xhtml+xml";
        else if (namespace === infra_1.namespace.SVG)
            document._contentType = "image/svg+xml";
        else
            document._contentType = "application/xml";
        /**
         * 8. Return document.
         */
        return document;
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.createHTMLDocument = function (title) {
        /**
         * 1. Let doc be a new document that is an HTML document.
         * 2. Set docâ€™s content type to "text/html".
         */
        var doc = algorithm_1.create_document();
        doc._type = "html";
        doc._contentType = "text/html";
        /**
         * 3. Append a new doctype, with "html" as its name and with its node
         * document set to doc, to doc.
         */
        doc.appendChild(algorithm_1.create_documentType(doc, "html", "", ""));
        /**
         * 4. Append the result of creating an element given doc, html, and the
         * HTML namespace, to doc.
         */
        var htmlElement = algorithm_1.element_createAnElement(doc, "html", infra_1.namespace.HTML);
        doc.appendChild(htmlElement);
        /**
         * 5. Append the result of creating an element given doc, head, and the
         * HTML namespace, to the html element created earlier.
         */
        var headElement = algorithm_1.element_createAnElement(doc, "head", infra_1.namespace.HTML);
        htmlElement.appendChild(headElement);
        /**
         * 6. If title is given:
         * 6.1. Append the result of creating an element given doc, title, and
         * the HTML namespace, to the head element created earlier.
         * 6.2. Append a new Text node, with its data set to title (which could
         * be the empty string) and its node document set to doc, to the title
         * element created earlier.
         */
        if (title !== undefined) {
            var titleElement = algorithm_1.element_createAnElement(doc, "title", infra_1.namespace.HTML);
            headElement.appendChild(titleElement);
            var textElement = algorithm_1.create_text(doc, title);
            titleElement.appendChild(textElement);
        }
        /**
         * 7. Append the result of creating an element given doc, body, and the
         * HTML namespace, to the html element created earlier.
         */
        var bodyElement = algorithm_1.element_createAnElement(doc, "body", infra_1.namespace.HTML);
        htmlElement.appendChild(bodyElement);
        /**
         * 8. docâ€™s origin is context objectâ€™s associated documentâ€™s origin.
         */
        doc._origin = this._associatedDocument._origin;
        /**
         * 9. Return doc.
         */
        return doc;
    };
    /** @inheritdoc */
    DOMImplementationImpl.prototype.hasFeature = function () { return true; };
    /**
     * Creates a new `DOMImplementation`.
     *
     * @param document - owner document
     */
    DOMImplementationImpl._create = function (document) {
        return new DOMImplementationImpl(document);
    };
    return DOMImplementationImpl;
}());
exports.DOMImplementationImpl = DOMImplementationImpl;
WebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom");
//# sourceMappingURL=DOMImplementationImpl.js.map

/***/ }),

/***/ 5096:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var DOMException_1 = __nccwpck_require__(3166);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a token set.
 */
var DOMTokenListImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    function DOMTokenListImpl(element, attribute) {
        /**
         * 1. Let element be associated element.
         * 2. Let localName be associated attributeâ€™s local name.
         * 3. Let value be the result of getting an attribute value given element
         * and localName.
         * 4. Run the attribute change steps for element, localName, value, value,
         * and null.
         */
        this._element = element;
        this._attribute = attribute;
        this._tokenSet = new Set();
        var localName = attribute._localName;
        var value = algorithm_1.element_getAnAttributeValue(element, localName);
        // define a closure to be called when the associated attribute's value changes
        var thisObj = this;
        function updateTokenSet(element, localName, oldValue, value, namespace) {
            /**
             * 1. If localName is associated attributeâ€™s local name, namespace is null,
             * and value is null, then empty token set.
             * 2. Otherwise, if localName is associated attributeâ€™s local name,
             * namespace is null, then set token set to value, parsed.
             */
            if (localName === thisObj._attribute._localName && namespace === null) {
                if (!value)
                    thisObj._tokenSet.clear();
                else
                    thisObj._tokenSet = algorithm_1.orderedSet_parse(value);
            }
        }
        // add the closure to the associated element's attribute change steps
        this._element._attributeChangeSteps.push(updateTokenSet);
        if (DOMImpl_1.dom.features.steps) {
            algorithm_1.dom_runAttributeChangeSteps(element, localName, value, value, null);
        }
    }
    Object.defineProperty(DOMTokenListImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute' getter must return context objectâ€™s token setâ€™s
             * size.
             */
            return this._tokenSet.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    DOMTokenListImpl.prototype.item = function (index) {
        var e_1, _a;
        /**
         * 1. If index is equal to or greater than context objectâ€™s token setâ€™s
         * size, then return null.
         * 2. Return context objectâ€™s token set[index].
         */
        var i = 0;
        try {
            for (var _b = __values(this._tokenSet), _c = _b.next(); !_c.done; _c = _b.next()) {
                var token = _c.value;
                if (i === index)
                    return token;
                i++;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.contains = function (token) {
        /**
         * The contains(token) method, when invoked, must return true if context
         * objectâ€™s token set[token] exists, and false otherwise.
         */
        return this._tokenSet.has(token);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.add = function () {
        var e_2, _a;
        var tokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, append token to context objectâ€™s token set.
             * 3. Run the update steps.
             */
            for (var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
                var token = tokens_1_1.value;
                if (token === '') {
                    throw new DOMException_1.SyntaxError("Cannot add an empty token.");
                }
                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                }
                else {
                    this._tokenSet.add(token);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.remove = function () {
        var e_3, _a;
        var tokens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, remove token from context objectâ€™s token set.
             * 3. Run the update steps.
             */
            for (var tokens_2 = __values(tokens), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
                var token = tokens_2_1.value;
                if (token === '') {
                    throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
                }
                else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                }
                else {
                    this._tokenSet.delete(token);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (tokens_2_1 && !tokens_2_1.done && (_a = tokens_2.return)) _a.call(tokens_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.toggle = function (token, force) {
        if (force === void 0) { force = undefined; }
        /**
         * 1. If token is the empty string, then throw a "SyntaxError" DOMException.
         * 2. If token contains any ASCII whitespace, then throw an
         * "InvalidCharacterError" DOMException.
         */
        if (token === '') {
            throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
        }
        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context objectâ€™s token set[token] exists, then:
         */
        if (this._tokenSet.has(token)) {
            /**
             * 3.1. If force is either not given or is false, then remove token from
             * context objectâ€™s token set, run the update steps and return false.
             * 3.2. Return true.
             */
            if (force === undefined || force === false) {
                this._tokenSet.delete(token);
                algorithm_1.tokenList_updateSteps(this);
                return false;
            }
            return true;
        }
        /**
         * 4. Otherwise, if force not given or is true, append token to context
         * objectâ€™s token set, run the update steps, and return true.
         */
        if (force === undefined || force === true) {
            this._tokenSet.add(token);
            algorithm_1.tokenList_updateSteps(this);
            return true;
        }
        /**
         * 5. Return false.
         */
        return false;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.replace = function (token, newToken) {
        /**
         * 1. If either token or newToken is the empty string, then throw a
         * "SyntaxError" DOMException.
         * 2. If either token or newToken contains any ASCII whitespace, then throw
         * an "InvalidCharacterError" DOMException.
         */
        if (token === '' || newToken === '') {
            throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
        }
        else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context objectâ€™s token set does not contain token, then return
         * false.
         */
        if (!this._tokenSet.has(token))
            return false;
        /**
         * 4. Replace token in context objectâ€™s token set with newToken.
         * 5. Run the update steps.
         * 6. Return true.
         */
        infra_1.set.replace(this._tokenSet, token, newToken);
        algorithm_1.tokenList_updateSteps(this);
        return true;
    };
    /** @inheritdoc */
    DOMTokenListImpl.prototype.supports = function (token) {
        /**
         * 1. Let result be the return value of validation steps called with token.
         * 2. Return result.
         */
        return algorithm_1.tokenList_validationSteps(this, token);
    };
    Object.defineProperty(DOMTokenListImpl.prototype, "value", {
        /** @inheritdoc */
        get: function () {
            /**
             * The value attribute must return the result of running context objectâ€™s
             * serialize steps.
             */
            return algorithm_1.tokenList_serializeSteps(this);
        },
        set: function (value) {
            /**
             * Setting the value attribute must set an attribute value for the
             * associated element using associated attributeâ€™s local name and the given
             * value.
             */
            algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an iterator for the token set.
     */
    DOMTokenListImpl.prototype[Symbol.iterator] = function () {
        var it = this._tokenSet[Symbol.iterator]();
        return {
            next: function () {
                return it.next();
            }
        };
    };
    /**
     * Creates a new `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */
    DOMTokenListImpl._create = function (element, attribute) {
        return new DOMTokenListImpl(element, attribute);
    };
    return DOMTokenListImpl;
}());
exports.DOMTokenListImpl = DOMTokenListImpl;
//# sourceMappingURL=DOMTokenListImpl.js.map

/***/ }),

/***/ 2585:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var NodeImpl_1 = __nccwpck_require__(1745);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a document fragment in the XML tree.
 */
var DocumentFragmentImpl = /** @class */ (function (_super) {
    __extends(DocumentFragmentImpl, _super);
    /**
     * Initializes a new instance of `DocumentFragment`.
     *
     * @param host - shadow root's host element
     */
    function DocumentFragmentImpl(host) {
        if (host === void 0) { host = null; }
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._host = host;
        return _this;
    }
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.getElementById = function (elementId) { throw new Error("Mixin: NonElementParentNode not implemented."); };
    Object.defineProperty(DocumentFragmentImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    DocumentFragmentImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /**
     * Creates a new `DocumentFragment`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    DocumentFragmentImpl._create = function (document, host) {
        if (host === void 0) { host = null; }
        var node = new DocumentFragmentImpl(host);
        node._nodeDocument = document;
        return node;
    };
    return DocumentFragmentImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentFragmentImpl = DocumentFragmentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment);
//# sourceMappingURL=DocumentFragmentImpl.js.map

/***/ }),

/***/ 4333:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var interfaces_1 = __nccwpck_require__(7305);
var DOMException_1 = __nccwpck_require__(3166);
var NodeImpl_1 = __nccwpck_require__(1745);
var util_1 = __nccwpck_require__(5282);
var util_2 = __nccwpck_require__(6195);
var infra_1 = __nccwpck_require__(4251);
var URLAlgorithm_1 = __nccwpck_require__(3568);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a document node.
 */
var DocumentImpl = /** @class */ (function (_super) {
    __extends(DocumentImpl, _super);
    /**
     * Initializes a new instance of `Document`.
     */
    function DocumentImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._encoding = {
            name: "UTF-8",
            labels: ["unicode-1-1-utf-8", "utf-8", "utf8"]
        };
        _this._contentType = 'application/xml';
        _this._URL = {
            scheme: "about",
            username: "",
            password: "",
            host: null,
            port: null,
            path: ["blank"],
            query: null,
            fragment: null,
            _cannotBeABaseURLFlag: true,
            _blobURLEntry: null
        };
        _this._origin = null;
        _this._type = "xml";
        _this._mode = "no-quirks";
        _this._documentElement = null;
        _this._hasNamespaces = false;
        _this._nodeDocumentOverwrite = null;
        return _this;
    }
    Object.defineProperty(DocumentImpl.prototype, "_nodeDocument", {
        get: function () { return this._nodeDocumentOverwrite || this; },
        set: function (val) { this._nodeDocumentOverwrite = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "implementation", {
        /** @inheritdoc */
        get: function () {
            /**
             * The implementation attributeâ€™s getter must return the DOMImplementation
             * object that is associated with the document.
             */
            return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "URL", {
        /** @inheritdoc */
        get: function () {
            /**
             * The URL attributeâ€™s getter and documentURI attributeâ€™s getter must return
             * the URL, serialized.
             * See: https://url.spec.whatwg.org/#concept-url-serializer
             */
            return URLAlgorithm_1.urlSerializer(this._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentURI", {
        /** @inheritdoc */
        get: function () { return this.URL; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "origin", {
        /** @inheritdoc */
        get: function () {
            return "null";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "compatMode", {
        /** @inheritdoc */
        get: function () {
            /**
             * The compatMode attributeâ€™s getter must return "BackCompat" if context
             * objectâ€™s mode is "quirks", and "CSS1Compat" otherwise.
             */
            return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "characterSet", {
        /** @inheritdoc */
        get: function () {
            /**
             * The characterSet attributeâ€™s getter, charset attributeâ€™s getter, and
             * inputEncoding attributeâ€™s getter, must return context objectâ€™s
             * encodingâ€™s name.
             */
            return this._encoding.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "charset", {
        /** @inheritdoc */
        get: function () { return this._encoding.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "inputEncoding", {
        /** @inheritdoc */
        get: function () { return this._encoding.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "contentType", {
        /** @inheritdoc */
        get: function () {
            /**
             * The contentType attributeâ€™s getter must return the content type.
             */
            return this._contentType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "doctype", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            try {
                /**
                 * The doctype attributeâ€™s getter must return the child of the document
                 * that is a doctype, and null otherwise.
                 */
                for (var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (util_1.Guard.isDocumentTypeNode(child))
                        return child;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentElement", {
        /** @inheritdoc */
        get: function () {
            /**
             * The documentElement attributeâ€™s getter must return the document element.
             */
            return this._documentElement;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByTagName = function (qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for the context object.
         */
        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for the context object.
         */
        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.getElementsByClassName = function (classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for the context object.
         */
        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createElement = function (localName, options) {
        /**
         * 1. If localName does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Let is be null.
         * 4. If options is a dictionary and optionsâ€™s is is present, then set is
         * to it.
         * 5. Let namespace be the HTML namespace, if the context object is an
         * HTML document or context objectâ€™s content type is
         * "application/xhtml+xml", and null otherwise.
         * 6. Return the result of creating an element given the context object,
         * localName, namespace, null, is, and with the synchronous custom elements
         * flag set.
         */
        if (!algorithm_1.xml_isName(localName))
            throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html")
            localName = localName.toLowerCase();
        var is = null;
        if (options !== undefined) {
            if (util_2.isString(options)) {
                is = options;
            }
            else {
                is = options.is;
            }
        }
        var namespace = (this._type === "html" || this._contentType === "application/xhtml+xml") ?
            infra_1.namespace.HTML : null;
        return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createElementNS = function (namespace, qualifiedName, options) {
        /**
         * The createElementNS(namespace, qualifiedName, options) method, when
         * invoked, must return the result of running the internal createElementNS
         * steps, given context object, namespace, qualifiedName, and options.
         */
        return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createDocumentFragment = function () {
        /**
         * The createDocumentFragment() method, when invoked, must return a new
         * DocumentFragment node with its node document set to the context object.
         */
        return algorithm_1.create_documentFragment(this);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createTextNode = function (data) {
        /**
         * The createTextNode(data) method, when invoked, must return a new Text
         * node with its data set to data and node document set to the context object.
         */
        return algorithm_1.create_text(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createCDATASection = function (data) {
        /**
         * 1. If context object is an HTML document, then throw a
         * "NotSupportedError" DOMException.
         * 2. If data contains the string "]]>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new CDATASection node with its data set to data and node
         * document set to the context object.
         */
        if (this._type === "html")
            throw new DOMException_1.NotSupportedError();
        if (data.indexOf(']]>') !== -1)
            throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_cdataSection(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createComment = function (data) {
        /**
         * The createComment(data) method, when invoked, must return a new Comment
         * node with its data set to data and node document set to the context object.
         */
        return algorithm_1.create_comment(this, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createProcessingInstruction = function (target, data) {
        /**
         * 1. If target does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If data contains the string "?>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new ProcessingInstruction node, with target set to target,
         * data set to data, and node document set to the context object.
         */
        if (!algorithm_1.xml_isName(target))
            throw new DOMException_1.InvalidCharacterError();
        if (data.indexOf("?>") !== -1)
            throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_processingInstruction(this, target, data);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.importNode = function (node, deep) {
        if (deep === void 0) { deep = false; }
        /**
         * 1. If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. Return a clone of node, with context object and the clone children flag set if deep is true.
         */
        return algorithm_1.node_clone(node, this, deep);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.adoptNode = function (node) {
        /**
         * 1. If node is a document, then throw a "NotSupportedError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(node))
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
         */
        if (util_1.Guard.isShadowRoot(node))
            throw new DOMException_1.HierarchyRequestError();
        /**
         * 3. Adopt node into the context object.
         * 4. Return node.
         */
        algorithm_1.document_adopt(node, this);
        return node;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createAttribute = function (localName) {
        /**
         * 1. If localName does not match the Name production in XML, then throw
         * an "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Return a new attribute whose local name is localName and node document
         * is context object.
         */
        if (!algorithm_1.xml_isName(localName))
            throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html") {
            localName = localName.toLowerCase();
        }
        var attr = algorithm_1.create_attr(this, localName);
        return attr;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createAttributeNS = function (namespace, qualifiedName) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Return a new attribute whose namespace is namespace, namespace prefix
         * is prefix, local name is localName, and node document is context object.
         */
        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        var attr = algorithm_1.create_attr(this, localName);
        attr._namespace = ns;
        attr._namespacePrefix = prefix;
        return attr;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createEvent = function (eventInterface) {
        return algorithm_1.event_createLegacyEvent(eventInterface);
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createRange = function () {
        /**
         * The createRange() method, when invoked, must return a new live range
         * with (context object, 0) as its start and end.
         */
        var range = algorithm_1.create_range();
        range._start = [this, 0];
        range._end = [this, 0];
        return range;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createNodeIterator = function (root, whatToShow, filter) {
        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }
        if (filter === void 0) { filter = null; }
        /**
         * 1. Let iterator be a new NodeIterator object.
         * 2. Set iteratorâ€™s root and iteratorâ€™s reference to root.
         * 3. Set iteratorâ€™s pointer before reference to true.
         * 4. Set iteratorâ€™s whatToShow to whatToShow.
         * 5. Set iteratorâ€™s filter to filter.
         * 6. Return iterator.
         */
        var iterator = algorithm_1.create_nodeIterator(root, root, true);
        iterator._whatToShow = whatToShow;
        iterator._iteratorCollection = algorithm_1.create_nodeList(root);
        if (util_2.isFunction(filter)) {
            iterator._filter = algorithm_1.create_nodeFilter();
            iterator._filter.acceptNode = filter;
        }
        else {
            iterator._filter = filter;
        }
        return iterator;
    };
    /** @inheritdoc */
    DocumentImpl.prototype.createTreeWalker = function (root, whatToShow, filter) {
        if (whatToShow === void 0) { whatToShow = interfaces_1.WhatToShow.All; }
        if (filter === void 0) { filter = null; }
        /**
         * 1. Let walker be a new TreeWalker object.
         * 2. Set walkerâ€™s root and walkerâ€™s current to root.
         * 3. Set walkerâ€™s whatToShow to whatToShow.
         * 4. Set walkerâ€™s filter to filter.
         * 5. Return walker.
         */
        var walker = algorithm_1.create_treeWalker(root, root);
        walker._whatToShow = whatToShow;
        if (util_2.isFunction(filter)) {
            walker._filter = algorithm_1.create_nodeFilter();
            walker._filter.acceptNode = filter;
        }
        else {
            walker._filter = filter;
        }
        return walker;
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    DocumentImpl.prototype._getTheParent = function (event) {
        /**
         * TODO: Implement realms
         * A documentâ€™s get the parent algorithm, given an event, returns null if
         * eventâ€™s type attribute value is "load" or document does not have a
         * browsing context, and the documentâ€™s relevant global object otherwise.
         */
        if (event._type === "load") {
            return null;
        }
        else {
            return DOMImpl_1.dom.window;
        }
    };
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */
    DocumentImpl.prototype.getElementById = function (elementId) { throw new Error("Mixin: NonElementParentNode not implemented."); };
    Object.defineProperty(DocumentImpl.prototype, "children", {
        // MIXIN: DocumentOrShadowRoot
        // No elements
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    DocumentImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    DocumentImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    return DocumentImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentImpl = DocumentImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document);
//# sourceMappingURL=DocumentImpl.js.map

/***/ }),

/***/ 5274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a mixin for an interface to be used to share APIs between
 * documents and shadow roots. This mixin is implemented by
 * {@link Document} and {@link ShadowRoot}.
 *
 * _Note:_ The DocumentOrShadowRoot mixin is expected to be used by other
 * standards that want to define APIs shared between documents and shadow roots.
 */
var DocumentOrShadowRootImpl = /** @class */ (function () {
    function DocumentOrShadowRootImpl() {
    }
    return DocumentOrShadowRootImpl;
}());
exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl;
//# sourceMappingURL=DocumentOrShadowRootImpl.js.map

/***/ }),

/***/ 3173:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var NodeImpl_1 = __nccwpck_require__(1745);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document
 */
var DocumentTypeImpl = /** @class */ (function (_super) {
    __extends(DocumentTypeImpl, _super);
    /**
     * Initializes a new instance of `DocumentType`.
     *
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    function DocumentTypeImpl(name, publicId, systemId) {
        var _this = _super.call(this) || this;
        _this._name = '';
        _this._publicId = '';
        _this._systemId = '';
        _this._name = name;
        _this._publicId = publicId;
        _this._systemId = systemId;
        return _this;
    }
    Object.defineProperty(DocumentTypeImpl.prototype, "name", {
        /** @inheritdoc */
        get: function () { return this._name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "publicId", {
        /** @inheritdoc */
        get: function () { return this._publicId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "systemId", {
        /** @inheritdoc */
        get: function () { return this._systemId; },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    DocumentTypeImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    /**
     * Creates a new `DocumentType`.
     *
     * @param document - owner document
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */
    DocumentTypeImpl._create = function (document, name, publicId, systemId) {
        if (publicId === void 0) { publicId = ''; }
        if (systemId === void 0) { systemId = ''; }
        var node = new DocumentTypeImpl(name, publicId, systemId);
        node._nodeDocument = document;
        return node;
    };
    return DocumentTypeImpl;
}(NodeImpl_1.NodeImpl));
exports.DocumentTypeImpl = DocumentTypeImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType);
//# sourceMappingURL=DocumentTypeImpl.js.map

/***/ }),

/***/ 5975:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var NodeImpl_1 = __nccwpck_require__(1745);
var DOMException_1 = __nccwpck_require__(3166);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents an element node.
 */
var ElementImpl = /** @class */ (function (_super) {
    __extends(ElementImpl, _super);
    /**
     * Initializes a new instance of `Element`.
     */
    function ElementImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._localName = "";
        _this._customElementState = "undefined";
        _this._customElementDefinition = null;
        _this._is = null;
        _this._shadowRoot = null;
        _this._attributeList = algorithm_1.create_namedNodeMap(_this);
        _this._attributeChangeSteps = [];
        _this._name = '';
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(ElementImpl.prototype, "namespaceURI", {
        /** @inheritdoc */
        get: function () { return this._namespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "prefix", {
        /** @inheritdoc */
        get: function () { return this._namespacePrefix; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "localName", {
        /** @inheritdoc */
        get: function () { return this._localName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "tagName", {
        /** @inheritdoc */
        get: function () { return this._htmlUppercasedQualifiedName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "id", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "id");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "id", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "className", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "class");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "class", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "classList", {
        /** @inheritdoc */
        get: function () {
            var attr = algorithm_1.element_getAnAttributeByName("class", this);
            if (attr === null) {
                attr = algorithm_1.create_attr(this._nodeDocument, "class");
            }
            return algorithm_1.create_domTokenList(this, attr);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "slot", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.element_getAnAttributeValue(this, "slot");
        },
        set: function (value) {
            algorithm_1.element_setAnAttributeValue(this, "slot", value);
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.hasAttributes = function () {
        return this._attributeList.length !== 0;
    };
    Object.defineProperty(ElementImpl.prototype, "attributes", {
        /** @inheritdoc */
        get: function () { return this._attributeList; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNames = function () {
        var e_1, _a;
        /**
         * The getAttributeNames() method, when invoked, must return the qualified
         * names of the attributes in context objectâ€™s attribute list, in order,
         * and a new list otherwise.
         */
        var names = [];
        try {
            for (var _b = __values(this._attributeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                names.push(attr._qualifiedName);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return names;
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttribute = function (qualifiedName) {
        /**
         * 1. Let attr be the result of getting an attribute given qualifiedName
         * and the context object.
         * 2. If attr is null, return null.
         * 3. Return attrâ€™s value.
         */
        var attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);
        return (attr ? attr._value : null);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNS = function (namespace, localName) {
        /**
         * 1. Let attr be the result of getting an attribute given namespace,
         * localName, and the context object.
         * 2. If attr is null, return null.
         * 3. Return attrâ€™s value.
         */
        var attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
        return (attr ? attr._value : null);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttribute = function (qualifiedName, value) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */
        if (!algorithm_1.xml_isName(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in context objectâ€™s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */
        var attribute = null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        /**
         * 4. If attribute is null, create an attribute whose local name is
         * qualifiedName, value is value, and node document is context objectâ€™s
         * node document, then append this attribute to context object, and
         * then return.
         */
        if (attribute === null) {
            attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
            attribute._value = value;
            algorithm_1.element_append(attribute, this);
            return;
        }
        /**
         * 5. Change attribute from context object to value.
         */
        algorithm_1.element_change(attribute, this, value);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNS = function (namespace, qualifiedName, value) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Set an attribute value for the context object using localName, value,
         * and also prefix and namespace.
         */
        var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttribute = function (qualifiedName) {
        /**
         * The removeAttribute(qualifiedName) method, when invoked, must remove an
         * attribute given qualifiedName and the context object, and then return
         * undefined.
         */
        algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttributeNS = function (namespace, localName) {
        /**
         * The removeAttributeNS(namespace, localName) method, when invoked, must
         * remove an attribute given namespace, localName, and context object, and
         * then return undefined.
         */
        algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.hasAttribute = function (qualifiedName) {
        /**
         * 1. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         * 2. Return true if the context object has an attribute whose qualified
         * name is qualifiedName, and false otherwise.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */
    ElementImpl.prototype.toggleAttribute = function (qualifiedName, force) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */
        if (!algorithm_1.xml_isName(qualifiedName))
            throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */
        if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in the context objectâ€™s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */
        var attribute = null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        if (attribute === null) {
            /**
             * 4. If attribute is null, then:
             * 4.1. If force is not given or is true, create an attribute whose local
             * name is qualifiedName, value is the empty string, and node document is
             * the context objectâ€™s node document, then append this attribute to the
             * context object, and then return true.
             * 4.2. Return false.
             */
            if (force === undefined || force === true) {
                attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
                attribute._value = '';
                algorithm_1.element_append(attribute, this);
                return true;
            }
            return false;
        }
        else if (force === undefined || force === false) {
            /**
             * 5. Otherwise, if force is not given or is false, remove an attribute
             * given qualifiedName and the context object, and then return false.
             */
            algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
            return false;
        }
        /**
         * 6. Return true.
         */
        return true;
    };
    /** @inheritdoc */
    ElementImpl.prototype.hasAttributeNS = function (namespace, localName) {
        /**
         * 1. If namespace is the empty string, set it to null.
         * 2. Return true if the context object has an attribute whose namespace is
         * namespace and local name is localName, and false otherwise.
         */
        var ns = namespace || null;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attr = this._attributeList[i];
            if (attr._namespace === ns && attr._localName === localName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNode = function (qualifiedName) {
        /**
         * The getAttributeNode(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and context object.
         */
        return algorithm_1.element_getAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getAttributeNodeNS = function (namespace, localName) {
        /**
         * The getAttributeNodeNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName, and
         * the context object.
         */
        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNode = function (attr) {
        /**
         * The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when
         * invoked, must return the result of setting an attribute given attr and
         * the context object.
         */
        return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.setAttributeNodeNS = function (attr) {
        return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.removeAttributeNode = function (attr) {
        /**
         * 1. If context objectâ€™s attribute list does not contain attr, then throw
         * a "NotFoundError" DOMException.
         * 2. Remove attr from context object.
         * 3. Return attr.
         */
        var found = false;
        for (var i = 0; i < this._attributeList.length; i++) {
            var attribute = this._attributeList[i];
            if (attribute === attr) {
                found = true;
                break;
            }
        }
        if (!found)
            throw new DOMException_1.NotFoundError();
        algorithm_1.element_remove(attr, this);
        return attr;
    };
    /** @inheritdoc */
    ElementImpl.prototype.attachShadow = function (init) {
        /**
         * 1. If context objectâ€™s namespace is not the HTML namespace, then throw a
         * "NotSupportedError" DOMException.
         */
        if (this._namespace !== infra_1.namespace.HTML)
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context objectâ€™s local name is not a valid custom element name,
         * "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2",
         * "h3", "h4", "h5", "h6", "header", "main" "nav", "p", "section",
         * or "span", then throw a "NotSupportedError" DOMException.
         */
        if (!algorithm_1.customElement_isValidCustomElementName(this._localName) &&
            !algorithm_1.customElement_isValidShadowHostName(this._localName))
            throw new DOMException_1.NotSupportedError();
        /**
         * 3. If context objectâ€™s local name is a valid custom element name,
         * or context objectâ€™s is value is not null, then:
         * 3.1. Let definition be the result of looking up a custom element
         * definition given context objectâ€™s node document, its namespace, its
         * local name, and its is value.
         * 3.2. If definition is not null and definitionâ€™s disable shadow is true,
         *  then throw a "NotSupportedError" DOMException.
         */
        if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {
            var definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
            if (definition !== null && definition.disableShadow === true) {
                throw new DOMException_1.NotSupportedError();
            }
        }
        /**
         * 4. If context object is a shadow host, then throw an "NotSupportedError"
         * DOMException.
         */
        if (this._shadowRoot !== null)
            throw new DOMException_1.NotSupportedError();
        /**
         * 5. Let shadow be a new shadow root whose node document is context
         * objectâ€™s node document, host is context object, and mode is initâ€™s mode.
         * 6. Set context objectâ€™s shadow root to shadow.
         * 7. Return shadow.
         */
        var shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);
        shadow._mode = init.mode;
        this._shadowRoot = shadow;
        return shadow;
    };
    Object.defineProperty(ElementImpl.prototype, "shadowRoot", {
        /** @inheritdoc */
        get: function () {
            /**
             * 1. Let shadow be context objectâ€™s shadow root.
             * 2. If shadow is null or its mode is "closed", then return null.
             * 3. Return shadow.
             */
            var shadow = this._shadowRoot;
            if (shadow === null || shadow.mode === "closed")
                return null;
            else
                return shadow;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ElementImpl.prototype.closest = function (selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Let elements be context objectâ€™s inclusive ancestors that are
         * elements, in reverse tree order.
         * 4. For each element in elements, if match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * return element. [SELECTORS4]
         * 5. Return null.
         */
        throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */
    ElementImpl.prototype.matches = function (selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Return true if the result of match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * and false otherwise. [SELECTORS4]
         */
        throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */
    ElementImpl.prototype.webkitMatchesSelector = function (selectors) {
        return this.matches(selectors);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByTagName = function (qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for context
         * object.
         */
        return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByTagNameNS = function (namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for context object.
         */
        return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.getElementsByClassName = function (classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for context object.
         */
        return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */
    ElementImpl.prototype.insertAdjacentElement = function (where, element) {
        /**
         * The insertAdjacentElement(where, element) method, when invoked, must
         * return the result of running insert adjacent, given context object,
         *  where, and element.
         */
        return algorithm_1.element_insertAdjacent(this, where, element);
    };
    /** @inheritdoc */
    ElementImpl.prototype.insertAdjacentText = function (where, data) {
        /**
         * 1. Let text be a new Text node whose data is data and node document is
         * context objectâ€™s node document.
         * 2. Run insert adjacent, given context object, where, and text.
         */
        var text = algorithm_1.create_text(this._nodeDocument, data);
        algorithm_1.element_insertAdjacent(this, where, text);
    };
    Object.defineProperty(ElementImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */
        get: function () {
            /**
             * An elementâ€™s qualified name is its local name if its namespace prefix is
             * null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */
            return (this._namespacePrefix ?
                this._namespacePrefix + ':' + this._localName :
                this._localName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "_htmlUppercasedQualifiedName", {
        /**
         * Returns the upper-cased qualified name for a html element.
         */
        get: function () {
            /**
             * 1. Let qualifiedName be context objectâ€™s qualified name.
             * 2. If the context object is in the HTML namespace and its node document
             * is an HTML document, then set qualifiedName to qualifiedName in ASCII
             * uppercase.
             * 3. Return qualifiedName.
             */
            var qualifiedName = this._qualifiedName;
            if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
                qualifiedName = qualifiedName.toUpperCase();
            }
            return qualifiedName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "childElementCount", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: ParentNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    ElementImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.querySelector = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    /* istanbul ignore next */
    ElementImpl.prototype.querySelectorAll = function (selectors) { throw new Error("Mixin: ParentNode not implemented."); };
    Object.defineProperty(ElementImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: NonDocumentTypeChildNode not implemented."); },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */
    ElementImpl.prototype.before = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.after = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.replaceWith = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */
    ElementImpl.prototype.remove = function () { throw new Error("Mixin: ChildNode not implemented."); };
    Object.defineProperty(ElementImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: Slotable not implemented."); },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `Element`.
     *
     * @param document - owner document
     * @param localName - local name
     * @param namespace - namespace
     * @param prefix - namespace prefix
     */
    ElementImpl._create = function (document, localName, namespace, namespacePrefix) {
        if (namespace === void 0) { namespace = null; }
        if (namespacePrefix === void 0) { namespacePrefix = null; }
        var node = new ElementImpl();
        node._localName = localName;
        node._namespace = namespace;
        node._namespacePrefix = namespacePrefix;
        node._nodeDocument = document;
        return node;
    };
    return ElementImpl;
}(NodeImpl_1.NodeImpl));
exports.ElementImpl = ElementImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element);
//# sourceMappingURL=ElementImpl.js.map

/***/ }),

/***/ 8245:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a DOM event.
 */
var EventImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `Event`.
     */
    function EventImpl(type, eventInit) {
        this._target = null;
        this._relatedTarget = null;
        this._touchTargetList = [];
        this._path = [];
        this._currentTarget = null;
        this._eventPhase = interfaces_1.EventPhase.None;
        this._stopPropagationFlag = false;
        this._stopImmediatePropagationFlag = false;
        this._canceledFlag = false;
        this._inPassiveListenerFlag = false;
        this._composedFlag = false;
        this._initializedFlag = false;
        this._dispatchFlag = false;
        this._isTrusted = false;
        this._bubbles = false;
        this._cancelable = false;
        /**
         * When a constructor of the Event interface, or of an interface that
         * inherits from the Event interface, is invoked, these steps must be run,
         * given the arguments type and eventInitDict:
         * 1. Let event be the result of running the inner event creation steps with
         * this interface, null, now, and eventInitDict.
         * 2. Initialize eventâ€™s type attribute to type.
         * 3. Return event.
         */
        this._type = type;
        if (eventInit) {
            this._bubbles = eventInit.bubbles || false;
            this._cancelable = eventInit.cancelable || false;
            this._composedFlag = eventInit.composed || false;
        }
        this._initializedFlag = true;
        this._timeStamp = new Date().getTime();
    }
    Object.defineProperty(EventImpl.prototype, "type", {
        /** @inheritdoc */
        get: function () { return this._type; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "target", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "srcElement", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "currentTarget", {
        /** @inheritdoc */
        get: function () { return this._currentTarget; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.composedPath = function () {
        /**
         * 1. Let composedPath be an empty list.
         * 2. Let path be the context objectâ€™s path.
         * 3. If path is empty, then return composedPath.
         * 4. Let currentTarget be the context objectâ€™s currentTarget attribute
         * value.
         * 5. Append currentTarget to composedPath.
         * 6. Let currentTargetIndex be 0.
         * 7. Let currentTargetHiddenSubtreeLevel be 0.
         */
        var composedPath = [];
        var path = this._path;
        if (path.length === 0)
            return composedPath;
        var currentTarget = this._currentTarget;
        if (currentTarget === null) {
            throw new Error("Event currentTarget is null.");
        }
        composedPath.push(currentTarget);
        var currentTargetIndex = 0;
        var currentTargetHiddenSubtreeLevel = 0;
        /**
         * 8. Let index be pathâ€™s size âˆ’ 1.
         * 9. While index is greater than or equal to 0:
         */
        var index = path.length - 1;
        while (index >= 0) {
            /**
             * 9.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.2. If path[index]'s invocation target is currentTarget, then set
             * currentTargetIndex to index and break.
             * 9.3. If path[index]'s slot-in-closed-tree is true, then decrease
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.4. Decrease index by 1.
             */
            if (path[index].rootOfClosedTree) {
                currentTargetHiddenSubtreeLevel++;
            }
            if (path[index].invocationTarget === currentTarget) {
                currentTargetIndex = index;
                break;
            }
            if (path[index].slotInClosedTree) {
                currentTargetHiddenSubtreeLevel--;
            }
            index--;
        }
        /**
         * 10. Let currentHiddenLevel and maxHiddenLevel be
         * currentTargetHiddenSubtreeLevel.
         */
        var currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        var maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 11. Set index to currentTargetIndex âˆ’ 1.
         * 12. While index is greater than or equal to 0:
         */
        index = currentTargetIndex - 1;
        while (index >= 0) {
            /**
             * 12.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 12.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then prepend path[index]'s invocation target to composedPath.
             */
            if (path[index].rootOfClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.unshift(path[index].invocationTarget);
            }
            /**
             * 12.3. If path[index]'s slot-in-closed-tree is true, then:
             */
            if (path[index].slotInClosedTree) {
                /**
                 * 12.3.1. Decrease currentHiddenLevel by 1.
                 * 12.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */
                currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 12.4. Decrease index by 1.
             */
            index--;
        }
        /**
         * 13. Set currentHiddenLevel and maxHiddenLevel to
         * currentTargetHiddenSubtreeLevel.
         */
        currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 14. Set index to currentTargetIndex + 1.
         * 15. While index is less than pathâ€™s size:
         */
        index = currentTargetIndex + 1;
        while (index < path.length) {
            /**
             * 15.1. If path[index]'s slot-in-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 15.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then append path[index]'s invocation target to composedPath.
             */
            if (path[index].slotInClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.push(path[index].invocationTarget);
            }
            /**
             * 15.3. If path[index]'s root-of-closed-tree is true, then:
             */
            if (path[index].rootOfClosedTree) {
                /**
                 * 15.3.1. Decrease currentHiddenLevel by 1.
                 * 15.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */
                currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 15.4. Increase index by 1.
             */
            index++;
        }
        /**
         * 16. Return composedPath.
         */
        return composedPath;
    };
    Object.defineProperty(EventImpl.prototype, "eventPhase", {
        /** @inheritdoc */
        get: function () { return this._eventPhase; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.stopPropagation = function () { this._stopPropagationFlag = true; };
    Object.defineProperty(EventImpl.prototype, "cancelBubble", {
        /** @inheritdoc */
        get: function () { return this._stopPropagationFlag; },
        set: function (value) { if (value)
            this.stopPropagation(); },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.stopImmediatePropagation = function () {
        this._stopPropagationFlag = true;
        this._stopImmediatePropagationFlag = true;
    };
    Object.defineProperty(EventImpl.prototype, "bubbles", {
        /** @inheritdoc */
        get: function () { return this._bubbles; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "cancelable", {
        /** @inheritdoc */
        get: function () { return this._cancelable; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "returnValue", {
        /** @inheritdoc */
        get: function () { return !this._canceledFlag; },
        set: function (value) {
            if (!value) {
                algorithm_1.event_setTheCanceledFlag(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.preventDefault = function () {
        algorithm_1.event_setTheCanceledFlag(this);
    };
    Object.defineProperty(EventImpl.prototype, "defaultPrevented", {
        /** @inheritdoc */
        get: function () { return this._canceledFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "composed", {
        /** @inheritdoc */
        get: function () { return this._composedFlag; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "isTrusted", {
        /** @inheritdoc */
        get: function () { return this._isTrusted; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "timeStamp", {
        /** @inheritdoc */
        get: function () { return this._timeStamp; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventImpl.prototype.initEvent = function (type, bubbles, cancelable) {
        if (bubbles === void 0) { bubbles = false; }
        if (cancelable === void 0) { cancelable = false; }
        /**
         * 1. If the context objectâ€™s dispatch flag is set, then return.
         */
        if (this._dispatchFlag)
            return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */
        algorithm_1.event_initialize(this, type, bubbles, cancelable);
    };
    EventImpl.NONE = 0;
    EventImpl.CAPTURING_PHASE = 1;
    EventImpl.AT_TARGET = 2;
    EventImpl.BUBBLING_PHASE = 3;
    return EventImpl;
}());
exports.EventImpl = EventImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "NONE", 0);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "CAPTURING_PHASE", 1);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "AT_TARGET", 2);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "BUBBLING_PHASE", 3);
//# sourceMappingURL=EventImpl.js.map

/***/ }),

/***/ 9968:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(3166);
var util_1 = __nccwpck_require__(5282);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a target to which an event can be dispatched.
 */
var EventTargetImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `EventTarget`.
     */
    function EventTargetImpl() {
    }
    Object.defineProperty(EventTargetImpl.prototype, "_eventListenerList", {
        get: function () {
            return this.__eventListenerList || (this.__eventListenerList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventTargetImpl.prototype, "_eventHandlerMap", {
        get: function () {
            return this.__eventHandlerMap || (this.__eventHandlerMap = {});
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    EventTargetImpl.prototype.addEventListener = function (type, callback, options) {
        if (options === void 0) { options = { passive: false, once: false, capture: false }; }
        /**
         * 1. Let capture, passive, and once be the result of flattening more options.
         */
        var _a = __read(algorithm_1.eventTarget_flattenMore(options), 3), capture = _a[0], passive = _a[1], once = _a[2];
        // convert callback function to EventListener, return if null
        var listenerCallback;
        if (!callback) {
            return;
        }
        else if (util_1.Guard.isEventListener(callback)) {
            listenerCallback = callback;
        }
        else {
            listenerCallback = { handleEvent: callback };
        }
        /**
         * 2. Add an event listener with the context object and an event listener
         * whose type is type, callback is callback, capture is capture, passive is
         * passive, and once is once.
         */
        algorithm_1.eventTarget_addEventListener(this, {
            type: type,
            callback: listenerCallback,
            capture: capture,
            passive: passive,
            once: once,
            removed: false
        });
    };
    /** @inheritdoc */
    EventTargetImpl.prototype.removeEventListener = function (type, callback, options) {
        /**
         * TODO: Implement realms
         * 1. If the context objectâ€™s relevant global object is a
         * ServiceWorkerGlobalScope object and its associated service workerâ€™s
         * script resourceâ€™s has ever been evaluated flag is set, then throw
         * a TypeError. [SERVICE-WORKERS]
         */
        if (options === void 0) { options = { capture: false }; }
        /**
         * 2. Let capture be the result of flattening options.
         */
        var capture = algorithm_1.eventTarget_flatten(options);
        if (!callback)
            return;
        /**
         * 3. If the context objectâ€™s event listener list contains an event listener
         * whose type is type, callback is callback, and capture is capture, then
         * remove an event listener with the context object and that event listener.
         */
        for (var i = 0; i < this._eventListenerList.length; i++) {
            var entry = this._eventListenerList[i];
            if (entry.type !== type || entry.capture !== capture)
                continue;
            if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            }
            else if (callback && entry.callback.handleEvent === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            }
        }
    };
    /** @inheritdoc */
    EventTargetImpl.prototype.dispatchEvent = function (event) {
        /**
         * 1. If eventâ€™s dispatch flag is set, or if its initialized flag is not
         * set, then throw an "InvalidStateError" DOMException.
         * 2. Initialize eventâ€™s isTrusted attribute to false.
         * 3. Return the result of dispatching event to the context object.
         */
        if (event._dispatchFlag || !event._initializedFlag) {
            throw new DOMException_1.InvalidStateError();
        }
        event._isTrusted = false;
        return algorithm_1.event_dispatch(event, this);
    };
    /** @inheritdoc */
    EventTargetImpl.prototype._getTheParent = function (event) {
        return null;
    };
    return EventTargetImpl;
}());
exports.EventTargetImpl = EventTargetImpl;
//# sourceMappingURL=EventTargetImpl.js.map

/***/ }),

/***/ 3969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
var util_1 = __nccwpck_require__(5282);
var util_2 = __nccwpck_require__(6195);
/**
 * Represents a collection of elements.
 */
var HTMLCollectionImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    function HTMLCollectionImpl(root, filter) {
        this._live = true;
        this._root = root;
        this._filter = filter;
        return new Proxy(this, this);
    }
    Object.defineProperty(HTMLCollectionImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            var _this = this;
            /**
             * The length attributeâ€™s getter must return the number of nodes
             * represented by the collection.
             */
            var count = 0;
            var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
            while (node !== null) {
                count++;
                node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    HTMLCollectionImpl.prototype.item = function (index) {
        var _this = this;
        /**
         * The item(index) method, when invoked, must return the indexth element
         * in the collection. If there is no indexth element in the collection,
         * then the method must return null.
         */
        var i = 0;
        var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        while (node !== null) {
            if (i === index)
                return node;
            else
                i++;
            node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        }
        return null;
    };
    /** @inheritdoc */
    HTMLCollectionImpl.prototype.namedItem = function (key) {
        var _this = this;
        /**
         * 1. If key is the empty string, return null.
         * 2. Return the first element in the collection for which at least one of
         * the following is true:
         * - it has an ID which is key;
         * - it is in the HTML namespace and has a name attribute whose value is key;
         * or null if there is no such element.
         */
        if (key === '')
            return null;
        var ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        while (ele != null) {
            if (ele._uniqueIdentifier === key) {
                return ele;
            }
            else if (ele._namespace === infra_1.namespace.HTML) {
                for (var i = 0; i < ele._attributeList.length; i++) {
                    var attr = ele._attributeList[i];
                    if (attr._localName === "name" && attr._namespace === null &&
                        attr._namespacePrefix === null && attr._value === key)
                        return ele;
                }
            }
            ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, function (e) { return util_1.Guard.isElementNode(e) && _this._filter(e); });
        }
        return null;
    };
    /** @inheritdoc */
    HTMLCollectionImpl.prototype[Symbol.iterator] = function () {
        var root = this._root;
        var filter = this._filter;
        var currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });
        return {
            next: function () {
                if (currentNode === null) {
                    return { done: true, value: null };
                }
                else {
                    var result = { done: false, value: currentNode };
                    currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, function (e) { return util_1.Guard.isElementNode(e) && filter(e); });
                    return result;
                }
            }
        };
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    HTMLCollectionImpl.prototype.get = function (target, key, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return target.namedItem(key) || undefined;
        }
        else {
            return target.item(index) || undefined;
        }
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    HTMLCollectionImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        var node = isNaN(index) ?
            target.namedItem(key) || undefined : target.item(index) || undefined;
        if (node && node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */
    HTMLCollectionImpl._create = function (root, filter) {
        if (filter === void 0) { filter = (function () { return true; }); }
        return new HTMLCollectionImpl(root, filter);
    };
    HTMLCollectionImpl.reservedNames = ['_root', '_live', '_filter', 'length',
        'item', 'namedItem', 'get', 'set'];
    return HTMLCollectionImpl;
}());
exports.HTMLCollectionImpl = HTMLCollectionImpl;
//# sourceMappingURL=HTMLCollectionImpl.js.map

/***/ }),

/***/ 9616:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(5282);
var infra_1 = __nccwpck_require__(4251);
/**
 * Represents an object that can be used to observe mutations to the tree of
 * nodes.
 */
var MutationObserverImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `MutationObserver`.
     *
     * @param callback - the callback function
     */
    function MutationObserverImpl(callback) {
        this._nodeList = [];
        this._recordQueue = [];
        /**
         * 1. Let mo be a new MutationObserver object whose callback is callback.
         * 2. Append mo to moâ€™s relevant agentâ€™s mutation observers.
         * 3. Return mo.
         */
        this._callback = callback;
        var window = DOMImpl_1.dom.window;
        infra_1.set.append(window._mutationObservers, this);
    }
    /** @inheritdoc */
    MutationObserverImpl.prototype.observe = function (target, options) {
        var e_1, _a;
        options = options || {
            childList: false,
            subtree: false
        };
        /**
         * 1. If either optionsâ€™s attributeOldValue or attributeFilter is present
         * and optionsâ€™s attributes is omitted, then set optionsâ€™s attributes
         * to true.
         * 2. If optionsâ€™s characterDataOldValue is present and optionsâ€™s
         * characterData is omitted, then set optionsâ€™s characterData to true.
         * 3. If none of optionsâ€™s childList, attributes, and characterData is
         * true, then throw a TypeError.
         * 4. If optionsâ€™s attributeOldValue is true and optionsâ€™s attributes is
         * false, then throw a TypeError.
         * 5. If optionsâ€™s attributeFilter is present and optionsâ€™s attributes is
         *  false, then throw a TypeError.
         * 6. If optionsâ€™s characterDataOldValue is true and optionsâ€™s characterData
         * is false, then throw a TypeError.
         */
        if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) &&
            options.attributes === undefined) {
            options.attributes = true;
        }
        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {
            options.characterData = true;
        }
        if (!options.childList && !options.attributes && !options.characterData) {
            throw new TypeError();
        }
        if (options.attributeOldValue && !options.attributes) {
            throw new TypeError();
        }
        if (options.attributeFilter !== undefined && !options.attributes) {
            throw new TypeError();
        }
        if (options.characterDataOldValue && !options.characterData) {
            throw new TypeError();
        }
        /**
         * 7. For each registered of targetâ€™s registered observer list, if
         * registeredâ€™s observer is the context object:
         */
        var isRegistered = false;
        var coptions = options;
        var _loop_1 = function (registered) {
            var e_2, _a;
            if (registered.observer === this_1) {
                isRegistered = true;
                try {
                    /**
                     * 7.1. For each node of the context objectâ€™s node list, remove all
                     * transient registered observers whose source is registered from nodeâ€™s
                     * registered observer list.
                     */
                    for (var _b = (e_2 = void 0, __values(this_1._nodeList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var node = _c.value;
                        infra_1.list.remove(node._registeredObserverList, function (ob) {
                            return util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered;
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                /**
                 * 7.2. Set registeredâ€™s options to options.
                 */
                registered.options = coptions;
            }
        };
        var this_1 = this;
        try {
            for (var _b = __values(target._registeredObserverList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var registered = _c.value;
                _loop_1(registered);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        /**
         * 8. Otherwise:
         * 8.1. Append a new registered observer whose observer is the context
         * object and options is options to targetâ€™s registered observer list.
         * 8.2. Append target to the context objectâ€™s node list.
         */
        if (!isRegistered) {
            target._registeredObserverList.push({ observer: this, options: options });
            this._nodeList.push(target);
        }
    };
    /** @inheritdoc */
    MutationObserverImpl.prototype.disconnect = function () {
        var e_3, _a;
        var _this = this;
        try {
            /**
             * 1. For each node of the context objectâ€™s node list, remove any
             * registered observer from nodeâ€™s registered observer list for which the
             * context object is the observer.
             */
            for (var _b = __values(this._nodeList), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                infra_1.list.remove((node)._registeredObserverList, function (ob) {
                    return ob.observer === _this;
                });
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 2. Empty the context objectâ€™s record queue.
         */
        this._recordQueue = [];
    };
    /** @inheritdoc */
    MutationObserverImpl.prototype.takeRecords = function () {
        /**
         * 1. Let records be a clone of the context objectâ€™s record queue.
         * 2. Empty the context objectâ€™s record queue.
         * 3. Return records.
         */
        var records = this._recordQueue;
        this._recordQueue = [];
        return records;
    };
    return MutationObserverImpl;
}());
exports.MutationObserverImpl = MutationObserverImpl;
//# sourceMappingURL=MutationObserverImpl.js.map

/***/ }),

/***/ 6219:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a mutation record.
 */
var MutationRecordImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    function MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        this._type = type;
        this._target = target;
        this._addedNodes = addedNodes;
        this._removedNodes = removedNodes;
        this._previousSibling = previousSibling;
        this._nextSibling = nextSibling;
        this._attributeName = attributeName;
        this._attributeNamespace = attributeNamespace;
        this._oldValue = oldValue;
    }
    Object.defineProperty(MutationRecordImpl.prototype, "type", {
        /** @inheritdoc */
        get: function () { return this._type; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "target", {
        /** @inheritdoc */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "addedNodes", {
        /** @inheritdoc */
        get: function () { return this._addedNodes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "removedNodes", {
        /** @inheritdoc */
        get: function () { return this._removedNodes; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "previousSibling", {
        /** @inheritdoc */
        get: function () { return this._previousSibling; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "nextSibling", {
        /** @inheritdoc */
        get: function () { return this._nextSibling; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeName", {
        /** @inheritdoc */
        get: function () { return this._attributeName; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeNamespace", {
        /** @inheritdoc */
        get: function () { return this._attributeNamespace; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "oldValue", {
        /** @inheritdoc */
        get: function () { return this._oldValue; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */
    MutationRecordImpl._create = function (type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        return new MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    };
    return MutationRecordImpl;
}());
exports.MutationRecordImpl = MutationRecordImpl;
//# sourceMappingURL=MutationRecordImpl.js.map

/***/ }),

/***/ 7206:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMException_1 = __nccwpck_require__(3166);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a collection of attributes.
 */
var NamedNodeMapImpl = /** @class */ (function (_super) {
    __extends(NamedNodeMapImpl, _super);
    /**
     * Initializes a new instance of `NamedNodeMap`.
     *
     * @param element - parent element
     */
    function NamedNodeMapImpl(element) {
        var _this = _super.call(this) || this;
        _this._element = element;
        // TODO: This workaround is needed to extend Array in ES5
        Object.setPrototypeOf(_this, NamedNodeMapImpl.prototype);
        return _this;
    }
    NamedNodeMapImpl.prototype._asArray = function () { return this; };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.item = function (index) {
        /**
         * 1. If index is equal to or greater than context objectâ€™s attribute listâ€™s
         * size, then return null.
         * 2. Otherwise, return context objectâ€™s attribute list[index].
         *
         */
        return this[index] || null;
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.getNamedItem = function (qualifiedName) {
        /**
         * The getNamedItem(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and element.
         */
        return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.getNamedItemNS = function (namespace, localName) {
        /**
         * The getNamedItemNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName,
         * and element.
         */
        return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.setNamedItem = function (attr) {
        /**
         * The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked,
         * must return the result of setting an attribute given attr and element.
         */
        return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.setNamedItemNS = function (attr) {
        return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.removeNamedItem = function (qualifiedName) {
        /**
         * 1. Let attr be the result of removing an attribute given qualifiedName
         * and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */
        var attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);
        if (attr === null)
            throw new DOMException_1.NotFoundError();
        return attr;
    };
    /** @inheritdoc */
    NamedNodeMapImpl.prototype.removeNamedItemNS = function (namespace, localName) {
        /**
         * 1. Let attr be the result of removing an attribute given namespace,
         * localName, and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */
        var attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || '', localName, this._element);
        if (attr === null)
            throw new DOMException_1.NotFoundError();
        return attr;
    };
    /**
     * Creates a new `NamedNodeMap`.
     *
     * @param element - parent element
     */
    NamedNodeMapImpl._create = function (element) {
        return new NamedNodeMapImpl(element);
    };
    return NamedNodeMapImpl;
}(Array));
exports.NamedNodeMapImpl = NamedNodeMapImpl;
//# sourceMappingURL=NamedNodeMapImpl.js.map

/***/ }),

/***/ 2355:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a node filter.
 */
var NodeFilterImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeFilter`.
     */
    function NodeFilterImpl() {
    }
    /**
     * Callback function.
     */
    NodeFilterImpl.prototype.acceptNode = function (node) {
        return interfaces_1.FilterResult.Accept;
    };
    /**
     * Creates a new `NodeFilter`.
     */
    NodeFilterImpl._create = function () {
        return new NodeFilterImpl();
    };
    NodeFilterImpl.FILTER_ACCEPT = 1;
    NodeFilterImpl.FILTER_REJECT = 2;
    NodeFilterImpl.FILTER_SKIP = 3;
    NodeFilterImpl.SHOW_ALL = 0xffffffff;
    NodeFilterImpl.SHOW_ELEMENT = 0x1;
    NodeFilterImpl.SHOW_ATTRIBUTE = 0x2;
    NodeFilterImpl.SHOW_TEXT = 0x4;
    NodeFilterImpl.SHOW_CDATA_SECTION = 0x8;
    NodeFilterImpl.SHOW_ENTITY_REFERENCE = 0x10;
    NodeFilterImpl.SHOW_ENTITY = 0x20;
    NodeFilterImpl.SHOW_PROCESSING_INSTRUCTION = 0x40;
    NodeFilterImpl.SHOW_COMMENT = 0x80;
    NodeFilterImpl.SHOW_DOCUMENT = 0x100;
    NodeFilterImpl.SHOW_DOCUMENT_TYPE = 0x200;
    NodeFilterImpl.SHOW_DOCUMENT_FRAGMENT = 0x400;
    NodeFilterImpl.SHOW_NOTATION = 0x800;
    return NodeFilterImpl;
}());
exports.NodeFilterImpl = NodeFilterImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ALL", 0xffffffff);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ELEMENT", 0x1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 0x2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_TEXT", 0x4);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 0x8);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY", 0x20);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 0x40);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_COMMENT", 0x80);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 0x100);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 0x200);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 0x400);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_NOTATION", 0x800);
//# sourceMappingURL=NodeFilterImpl.js.map

/***/ }),

/***/ 1745:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var interfaces_1 = __nccwpck_require__(7305);
var EventTargetImpl_1 = __nccwpck_require__(9968);
var util_1 = __nccwpck_require__(5282);
var DOMException_1 = __nccwpck_require__(3166);
var algorithm_1 = __nccwpck_require__(61);
var URLAlgorithm_1 = __nccwpck_require__(3568);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a generic XML node.
 */
var NodeImpl = /** @class */ (function (_super) {
    __extends(NodeImpl, _super);
    /**
     * Initializes a new instance of `Node`.
     */
    function NodeImpl() {
        var _this = _super.call(this) || this;
        _this._parent = null;
        _this._firstChild = null;
        _this._lastChild = null;
        _this._previousSibling = null;
        _this._nextSibling = null;
        return _this;
    }
    Object.defineProperty(NodeImpl.prototype, "_childNodes", {
        get: function () {
            return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_nodeDocument", {
        get: function () { return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument; },
        set: function (val) { this._nodeDocumentOverride = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_registeredObserverList", {
        get: function () {
            return this.__registeredObserverList || (this.__registeredObserverList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeType", {
        /** @inheritdoc */
        get: function () { return this._nodeType; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeName", {
        /**
         * Returns a string appropriate for the type of node.
         */
        get: function () {
            if (util_1.Guard.isElementNode(this)) {
                return this._htmlUppercasedQualifiedName;
            }
            else if (util_1.Guard.isAttrNode(this)) {
                return this._qualifiedName;
            }
            else if (util_1.Guard.isExclusiveTextNode(this)) {
                return "#text";
            }
            else if (util_1.Guard.isCDATASectionNode(this)) {
                return "#cdata-section";
            }
            else if (util_1.Guard.isProcessingInstructionNode(this)) {
                return this._target;
            }
            else if (util_1.Guard.isCommentNode(this)) {
                return "#comment";
            }
            else if (util_1.Guard.isDocumentNode(this)) {
                return "#document";
            }
            else if (util_1.Guard.isDocumentTypeNode(this)) {
                return this._name;
            }
            else if (util_1.Guard.isDocumentFragmentNode(this)) {
                return "#document-fragment";
            }
            else {
                return "";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "baseURI", {
        /**
         * Gets the absolute base URL of the node.
         */
        get: function () {
            /**
             * The baseURI attributeâ€™s getter must return node documentâ€™s document
             * base URL, serialized.
             * TODO: Implement in HTML DOM
             * https://html.spec.whatwg.org/multipage/urls-and-fetching.html#document-base-url
             */
            return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "isConnected", {
        /**
         * Returns whether the node is rooted to a document node.
         */
        get: function () {
            /**
             * The isConnected attributeâ€™s getter must return true, if context object
             * is connected, and false otherwise.
             */
            return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "ownerDocument", {
        /**
         * Returns the parent document.
         */
        get: function () {
            /**
             * The ownerDocument attributeâ€™s getter must return null, if the context
             * object is a document, and the context objectâ€™s node document otherwise.
             * _Note:_ The node document of a document is that document itself. All
             * nodes have a node document at all times.
             */
            if (this._nodeType === interfaces_1.NodeType.Document)
                return null;
            else
                return this._nodeDocument;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the root node.
     *
     * @param options - if options has `composed = true` this function
     * returns the node's shadow-including root, otherwise it returns
     * the node's root node.
     */
    NodeImpl.prototype.getRootNode = function (options) {
        /**
         * The getRootNode(options) method, when invoked, must return context
         * objectâ€™s shadow-including root if optionsâ€™s composed is true,
         * and context objectâ€™s root otherwise.
         */
        return algorithm_1.tree_rootNode(this, !!options && options.composed);
    };
    Object.defineProperty(NodeImpl.prototype, "parentNode", {
        /**
         * Returns the parent node.
         */
        get: function () {
            /**
             * The parentNode attributeâ€™s getter must return the context objectâ€™s parent.
             * _Note:_ An Attr node has no parent.
             */
            if (this._nodeType === interfaces_1.NodeType.Attribute) {
                return null;
            }
            else {
                return this._parent;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "parentElement", {
        /**
         * Returns the parent element.
         */
        get: function () {
            /**
             * The parentElement attributeâ€™s getter must return the context objectâ€™s
             * parent element.
             */
            if (this._parent && util_1.Guard.isElementNode(this._parent)) {
                return this._parent;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether a node has any children.
     */
    NodeImpl.prototype.hasChildNodes = function () {
        /**
         * The hasChildNodes() method, when invoked, must return true if the context
         * object has children, and false otherwise.
         */
        return (this._firstChild !== null);
    };
    Object.defineProperty(NodeImpl.prototype, "childNodes", {
        /**
         * Returns a {@link NodeList} of child nodes.
         */
        get: function () {
            /**
             * The childNodes attributeâ€™s getter must return a NodeList rooted at the
             * context object matching only children.
             */
            return this._childNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "firstChild", {
        /**
         * Returns the first child node.
         */
        get: function () {
            /**
             * The firstChild attributeâ€™s getter must return the context objectâ€™s first
             * child.
             */
            return this._firstChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "lastChild", {
        /**
         * Returns the last child node.
         */
        get: function () {
            /**
             * The lastChild attributeâ€™s getter must return the context objectâ€™s last
             * child.
             */
            return this._lastChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "previousSibling", {
        /**
         * Returns the previous sibling node.
         */
        get: function () {
            /**
             * The previousSibling attributeâ€™s getter must return the context objectâ€™s
             * previous sibling.
             * _Note:_ An Attr node has no siblings.
             */
            return this._previousSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nextSibling", {
        /**
         * Returns the next sibling node.
         */
        get: function () {
            /**
             * The nextSibling attributeâ€™s getter must return the context objectâ€™s
             * next sibling.
             */
            return this._nextSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeValue", {
        /**
         * Gets or sets the data associated with a {@link CharacterData} node or the
         * value of an {@link @Attr} node. For other node types returns `null`.
         */
        get: function () {
            if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            }
            else {
                return null;
            }
        },
        set: function (value) {
            if (value === null) {
                value = '';
            }
            if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "textContent", {
        /**
         * Returns the concatenation of data of all the {@link Text}
         * node descendants in tree order. When set, replaces the text
         * contents of the node with the given value.
         */
        get: function () {
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                return algorithm_1.text_descendantTextContent(this);
            }
            else if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            }
            else {
                return null;
            }
        },
        set: function (value) {
            if (value === null) {
                value = '';
            }
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                algorithm_1.node_stringReplaceAll(value, this);
            }
            else if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            }
            else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Puts all {@link Text} nodes in the full depth of the sub-tree
     * underneath this node into a "normal" form where only markup
     * (e.g., tags, comments, processing instructions, CDATA sections,
     * and entity references) separates {@link Text} nodes, i.e., there
     * are no adjacent Text nodes.
     */
    NodeImpl.prototype.normalize = function () {
        var e_1, _a, e_2, _b;
        /**
         * The normalize() method, when invoked, must run these steps for each
         * descendant exclusive Text node node of context object:
         */
        var descendantNodes = [];
        var node = algorithm_1.tree_getFirstDescendantNode(this, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });
        while (node !== null) {
            descendantNodes.push(node);
            node = algorithm_1.tree_getNextDescendantNode(this, node, false, false, function (e) { return util_1.Guard.isExclusiveTextNode(e); });
        }
        for (var i = 0; i < descendantNodes.length; i++) {
            var node_1 = descendantNodes[i];
            if (node_1._parent === null)
                continue;
            /**
             * 1. Let length be nodeâ€™s length.
             * 2. If length is zero, then remove node and continue with the next
             * exclusive Text node, if any.
             */
            var length = algorithm_1.tree_nodeLength(node_1);
            if (length === 0) {
                algorithm_1.mutation_remove(node_1, node_1._parent);
                continue;
            }
            /**
             * 3. Let data be the concatenation of the data of nodeâ€™s contiguous
             * exclusive Text nodes (excluding itself), in tree order.
             */
            var textSiblings = [];
            var data = '';
            try {
                for (var _c = (e_1 = void 0, __values(algorithm_1.text_contiguousExclusiveTextNodes(node_1))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var sibling = _d.value;
                    textSiblings.push(sibling);
                    data += sibling._data;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            /**
             * 4. Replace data with node node, offset length, count 0, and data data.
             */
            algorithm_1.characterData_replaceData(node_1, length, 0, data);
            /**
             * 5. Let currentNode be nodeâ€™s next sibling.
             * 6. While currentNode is an exclusive Text node:
             */
            if (DOMImpl_1.dom.rangeList.size !== 0) {
                var currentNode = node_1._nextSibling;
                while (currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)) {
                    /**
                     * 6.1. For each live range whose start node is currentNode, add length
                     * to its start offset and set its start node to node.
                     * 6.2. For each live range whose end node is currentNode, add length to
                     * its end offset and set its end node to node.
                     * 6.3. For each live range whose start node is currentNodeâ€™s parent and
                     * start offset is currentNodeâ€™s index, set its start node to node and
                     * its start offset to length.
                     * 6.4. For each live range whose end node is currentNodeâ€™s parent and
                     * end offset is currentNodeâ€™s index, set its end node to node and its
                     * end offset to length.
                     */
                    var cn = currentNode;
                    var index = algorithm_1.tree_index(cn);
                    try {
                        for (var _e = (e_2 = void 0, __values(DOMImpl_1.dom.rangeList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var range = _f.value;
                            if (range._start[0] === cn) {
                                range._start[0] = node_1;
                                range._start[1] += length;
                            }
                            if (range._end[0] === cn) {
                                range._end[0] = node_1;
                                range._end[1] += length;
                            }
                            if (range._start[0] === cn._parent && range._start[1] === index) {
                                range._start[0] = node_1;
                                range._start[1] = length;
                            }
                            if (range._end[0] === cn._parent && range._end[1] === index) {
                                range._end[0] = node_1;
                                range._end[1] = length;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    /**
                     * 6.5. Add currentNodeâ€™s length to length.
                     * 6.6. Set currentNode to its next sibling.
                     */
                    length += algorithm_1.tree_nodeLength(currentNode);
                    currentNode = currentNode._nextSibling;
                }
            }
            /**
             * 7. Remove nodeâ€™s contiguous exclusive Text nodes (excluding itself),
             * in tree order.
             */
            for (var i_1 = 0; i_1 < textSiblings.length; i_1++) {
                var sibling = textSiblings[i_1];
                if (sibling._parent === null)
                    continue;
                algorithm_1.mutation_remove(sibling, sibling._parent);
            }
        }
    };
    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent
     * ({@link parentNode} returns `null`).
     *
     * @param deep - if `true`, recursively clone the subtree under the
     * specified node. If `false`, clone only the node itself (and its
     * attributes, if it is an {@link Element}).
     */
    NodeImpl.prototype.cloneNode = function (deep) {
        if (deep === void 0) { deep = false; }
        /**
         * 1. If context object is a shadow root, then throw a "NotSupportedError"
         * DOMException.
         * 2. Return a clone of the context object, with the clone children flag set
         * if deep is true.
         */
        if (util_1.Guard.isShadowRoot(this))
            throw new DOMException_1.NotSupportedError();
        return algorithm_1.node_clone(this, null, deep);
    };
    /**
     * Determines if the given node is equal to this one.
     *
     * @param node - the node to compare with
     */
    NodeImpl.prototype.isEqualNode = function (node) {
        if (node === void 0) { node = null; }
        /**
         * The isEqualNode(otherNode) method, when invoked, must return true if
         * otherNode is non-null and context object equals otherNode, and false
         * otherwise.
         */
        return (node !== null && algorithm_1.node_equals(this, node));
    };
    /**
     * Determines if the given node is reference equal to this one.
     *
     * @param node - the node to compare with
     */
    NodeImpl.prototype.isSameNode = function (node) {
        if (node === void 0) { node = null; }
        /**
         * The isSameNode(otherNode) method, when invoked, must return true if
         * otherNode is context object, and false otherwise.
         */
        return (this === node);
    };
    /**
     * Returns a bitmask indicating the position of the given `node`
     * relative to this node.
     */
    NodeImpl.prototype.compareDocumentPosition = function (other) {
        /**
         * 1. If context object is other, then return zero.
         * 2. Let node1 be other and node2 be context object.
         * 3. Let attr1 and attr2 be null.
         * attr1â€™s element.
         */
        if (other === this)
            return 0;
        var node1 = other;
        var node2 = this;
        var attr1 = null;
        var attr2 = null;
        /**
         * 4. If node1 is an attribute, then set attr1 to node1 and node1 to
         * attr1â€™s element.
         */
        if (util_1.Guard.isAttrNode(node1)) {
            attr1 = node1;
            node1 = attr1._element;
        }
        /**
         * 5. If node2 is an attribute, then:
         */
        if (util_1.Guard.isAttrNode(node2)) {
            /**
             * 5.1. Set attr2 to node2 and node2 to attr2â€™s element.
             */
            attr2 = node2;
            node2 = attr2._element;
            /**
             * 5.2. If attr1 and node1 are non-null, and node2 is node1, then:
             */
            if (attr1 && node1 && (node1 === node2)) {
                /**
                 * 5.2. For each attr in node2â€™s attribute list:
                 */
                for (var i = 0; i < node2._attributeList.length; i++) {
                    var attr = node2._attributeList[i];
                    /**
                     * 5.2.1. If attr equals attr1, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_PRECEDING.
                     * 5.2.2. If attr equals attr2, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_FOLLOWING.
                     */
                    if (algorithm_1.node_equals(attr, attr1)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
                    }
                    else if (algorithm_1.node_equals(attr, attr2)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
                    }
                }
            }
        }
        /**
         * 6. If node1 or node2 is null, or node1â€™s root is not node2â€™s root, then
         * return the result of adding DOCUMENT_POSITION_DISCONNECTED,
         * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either
         * DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,
         * with the constraint that this is to be consistent, together.
         */
        if (node1 === null || node2 === null ||
            algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {
            // nodes are disconnected
            // return a random result but cache the value for consistency
            return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific |
                (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
        }
        /**
         * 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2
         * and attr2 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
         */
        if ((!attr1 && algorithm_1.tree_isAncestorOf(node2, node1)) ||
            (attr2 && (node1 === node2))) {
            return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
        }
        /**
         * 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2
         * and attr1 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
         */
        if ((!attr2 && algorithm_1.tree_isDescendantOf(node2, node1)) ||
            (attr1 && (node1 === node2))) {
            return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
        }
        /**
         * 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
         */
        if (algorithm_1.tree_isPreceding(node2, node1))
            return interfaces_1.Position.Preceding;
        /**
         * 10. Return DOCUMENT_POSITION_FOLLOWING.
         */
        return interfaces_1.Position.Following;
    };
    /**
     * Returns `true` if given node is an inclusive descendant of this
     * node, and `false` otherwise (including when other node is `null`).
     *
     * @param other - the node to check
     */
    NodeImpl.prototype.contains = function (other) {
        /**
         * The contains(other) method, when invoked, must return true if other is an
         * inclusive descendant of context object, and false otherwise (including
         * when other is null).
         */
        if (other === null)
            return false;
        return algorithm_1.tree_isDescendantOf(this, other, true);
    };
    /**
     * Returns the prefix for a given namespace URI, if present, and
     * `null` if not.
     *
     * @param namespace - the namespace to search
     */
    NodeImpl.prototype.lookupPrefix = function (namespace) {
        /**
         * 1. If namespace is null or the empty string, then return null.
         * 2. Switch on the context object:
         */
        if (!namespace)
            return null;
        if (util_1.Guard.isElementNode(this)) {
            /**
             * Return the result of locating a namespace prefix for it using
             * namespace.
             */
            return algorithm_1.node_locateANamespacePrefix(this, namespace);
        }
        else if (util_1.Guard.isDocumentNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its document
             * element, if its document element is non-null, and null otherwise.
             */
            if (this.documentElement === null) {
                return null;
            }
            else {
                return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);
            }
        }
        else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
            return null;
        }
        else if (util_1.Guard.isAttrNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its element,
             * if its element is non-null, and null otherwise.
             */
            if (this._element === null) {
                return null;
            }
            else {
                return algorithm_1.node_locateANamespacePrefix(this._element, namespace);
            }
        }
        else {
            /**
             * Return the result of locating a namespace prefix for its parent
             * element, if its parent element is non-null, and null otherwise.
             */
            if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
                return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);
            }
            else {
                return null;
            }
        }
    };
    /**
     * Returns the namespace URI for a given prefix if present, and `null`
     * if not.
     *
     * @param prefix - the prefix to search
     */
    NodeImpl.prototype.lookupNamespaceURI = function (prefix) {
        /**
         * 1. If prefix is the empty string, then set it to null.
         * 2. Return the result of running locate a namespace for the context object
         * using prefix.
         */
        return algorithm_1.node_locateANamespace(this, prefix || null);
    };
    /**
     * Returns `true` if the namespace is the default namespace on this
     * node or `false` if not.
     *
     * @param namespace - the namespace to check
     */
    NodeImpl.prototype.isDefaultNamespace = function (namespace) {
        /**
         * 1. If namespace is the empty string, then set it to null.
         * 2. Let defaultNamespace be the result of running locate a namespace for
         * context object using null.
         * 3. Return true if defaultNamespace is the same as namespace, and false otherwise.
         */
        if (!namespace)
            namespace = null;
        var defaultNamespace = algorithm_1.node_locateANamespace(this, null);
        return (defaultNamespace === namespace);
    };
    /**
     * Inserts the node `newChild` before the existing child node
     * `refChild`. If `refChild` is `null`, inserts `newChild` at the end
     * of the list of children.
     *
     * If `newChild` is a {@link DocumentFragment} object, all of its
     * children are inserted, in the same order, before `refChild`.
     *
     * If `newChild` is already in the tree, it is first removed.
     *
     * @param newChild - the node to insert
     * @param refChild - the node before which the new node must be
     *   inserted
     *
     * @returns the newly inserted child node
     */
    NodeImpl.prototype.insertBefore = function (newChild, refChild) {
        /**
         * The insertBefore(node, child) method, when invoked, must return the
         * result of pre-inserting node into context object before child.
         */
        return algorithm_1.mutation_preInsert(newChild, this, refChild);
    };
    /**
     * Adds the node `newChild` to the end of the list of children of this
     * node, and returns it. If `newChild` is already in the tree, it is
     * first removed.
     *
     * If `newChild` is a {@link DocumentFragment} object, the entire
     * contents of the document fragment are moved into the child list of
     * this node.
     *
     * @param newChild - the node to add
     *
     * @returns the newly inserted child node
     */
    NodeImpl.prototype.appendChild = function (newChild) {
        /**
         * The appendChild(node) method, when invoked, must return the result of
         * appending node to context object.
         */
        return algorithm_1.mutation_append(newChild, this);
    };
    /**
     * Replaces the child node `oldChild` with `newChild` in the list of
     * children, and returns the `oldChild` node. If `newChild` is already
     * in the tree, it is first removed.
     *
     * @param newChild - the new node to put in the child list
     * @param oldChild - the node being replaced in the list
     *
     * @returns the removed child node
     */
    NodeImpl.prototype.replaceChild = function (newChild, oldChild) {
        /**
         * The replaceChild(node, child) method, when invoked, must return the
         * result of replacing child with node within context object.
         */
        return algorithm_1.mutation_replace(oldChild, newChild, this);
    };
    /**
    * Removes the child node indicated by `oldChild` from the list of
    * children, and returns it.
    *
    * @param oldChild - the node being removed from the list
    *
    * @returns the removed child node
    */
    NodeImpl.prototype.removeChild = function (oldChild) {
        /**
         * The removeChild(child) method, when invoked, must return the result of
         * pre-removing child from context object.
         */
        return algorithm_1.mutation_preRemove(oldChild, this);
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    NodeImpl.prototype._getTheParent = function (event) {
        /**
         * A nodeâ€™s get the parent algorithm, given an event, returns the nodeâ€™s
         * assigned slot, if node is assigned, and nodeâ€™s parent otherwise.
         */
        if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {
            return this._assignedSlot;
        }
        else {
            return this._parent;
        }
    };
    NodeImpl.ELEMENT_NODE = 1;
    NodeImpl.ATTRIBUTE_NODE = 2;
    NodeImpl.TEXT_NODE = 3;
    NodeImpl.CDATA_SECTION_NODE = 4;
    NodeImpl.ENTITY_REFERENCE_NODE = 5;
    NodeImpl.ENTITY_NODE = 6;
    NodeImpl.PROCESSING_INSTRUCTION_NODE = 7;
    NodeImpl.COMMENT_NODE = 8;
    NodeImpl.DOCUMENT_NODE = 9;
    NodeImpl.DOCUMENT_TYPE_NODE = 10;
    NodeImpl.DOCUMENT_FRAGMENT_NODE = 11;
    NodeImpl.NOTATION_NODE = 12;
    NodeImpl.DOCUMENT_POSITION_DISCONNECTED = 0x01;
    NodeImpl.DOCUMENT_POSITION_PRECEDING = 0x02;
    NodeImpl.DOCUMENT_POSITION_FOLLOWING = 0x04;
    NodeImpl.DOCUMENT_POSITION_CONTAINS = 0x08;
    NodeImpl.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    NodeImpl.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    return NodeImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.NodeImpl = NodeImpl;
/**
 * A performance tweak to share an empty set between all node classes. This will
 * be overwritten by element, document and document fragment nodes to supply an
 * actual set of nodes.
 */
NodeImpl.prototype._children = new util_1.EmptySet();
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ELEMENT_NODE", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "TEXT_NODE", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_NODE", 6);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "COMMENT_NODE", 8);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_NODE", 9);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "NOTATION_NODE", 12);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 0x01);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 0x02);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 0x04);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 0x08);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 0x20);
//# sourceMappingURL=NodeImpl.js.map

/***/ }),

/***/ 1997:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var TraverserImpl_1 = __nccwpck_require__(9782);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */
var NodeIteratorImpl = /** @class */ (function (_super) {
    __extends(NodeIteratorImpl, _super);
    /**
     * Initializes a new instance of `NodeIterator`.
     */
    function NodeIteratorImpl(root, reference, pointerBeforeReference) {
        var _this = _super.call(this, root) || this;
        _this._iteratorCollection = undefined;
        _this._reference = reference;
        _this._pointerBeforeReference = pointerBeforeReference;
        algorithm_1.nodeIterator_iteratorList().add(_this);
        return _this;
    }
    Object.defineProperty(NodeIteratorImpl.prototype, "referenceNode", {
        /** @inheritdoc */
        get: function () { return this._reference; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeIteratorImpl.prototype, "pointerBeforeReferenceNode", {
        /** @inheritdoc */
        get: function () { return this._pointerBeforeReference; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeIteratorImpl.prototype.nextNode = function () {
        /**
         * The nextNode() method, when invoked, must return the result of
         * traversing with the context object and next.
         */
        return algorithm_1.nodeIterator_traverse(this, true);
    };
    /** @inheritdoc */
    NodeIteratorImpl.prototype.previousNode = function () {
        /**
         * The previousNode() method, when invoked, must return the result of
         * traversing with the context object and previous.
         */
        return algorithm_1.nodeIterator_traverse(this, false);
    };
    /** @inheritdoc */
    NodeIteratorImpl.prototype.detach = function () {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */
        algorithm_1.nodeIterator_iteratorList().delete(this);
    };
    /**
     * Creates a new `NodeIterator`.
     *
     * @param root - iterator's root node
     * @param reference - reference node
     * @param pointerBeforeReference - whether the iterator is before or after the
     * reference node
     */
    NodeIteratorImpl._create = function (root, reference, pointerBeforeReference) {
        return new NodeIteratorImpl(root, reference, pointerBeforeReference);
    };
    return NodeIteratorImpl;
}(TraverserImpl_1.TraverserImpl));
exports.NodeIteratorImpl = NodeIteratorImpl;
//# sourceMappingURL=NodeIteratorImpl.js.map

/***/ }),

/***/ 3728:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(6195);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents an ordered set of nodes.
 */
var NodeListImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    function NodeListImpl(root) {
        this._live = true;
        this._filter = null;
        this._length = 0;
        this._root = root;
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute must return the number of nodes represented
             * by the collection.
             */
            return this._root._children.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeListImpl.prototype.item = function (index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */
        if (index < 0 || index > this.length - 1)
            return null;
        if (index < this.length / 2) {
            var i = 0;
            var node = this._root._firstChild;
            while (node !== null && i !== index) {
                node = node._nextSibling;
                i++;
            }
            return node;
        }
        else {
            var i = this.length - 1;
            var node = this._root._lastChild;
            while (node !== null && i !== index) {
                node = node._previousSibling;
                i--;
            }
            return node;
        }
    };
    /** @inheritdoc */
    NodeListImpl.prototype.keys = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var index = 0;
                return {
                    next: function () {
                        if (index === this.length) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: index++ };
                        }
                    }.bind(this)
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype.values = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                return {
                    next: function () {
                        return it.next();
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype.entries = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                var index = 0;
                return {
                    next: function () {
                        var itResult = it.next();
                        if (itResult.done) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: [index++, itResult.value] };
                        }
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListImpl.prototype[Symbol.iterator] = function () {
        return this._root._children[Symbol.iterator]();
    };
    /** @inheritdoc */
    NodeListImpl.prototype.forEach = function (callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for (var _b = __values(this._root._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    NodeListImpl.prototype.get = function (target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target.item(index) || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    NodeListImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        var node = target.item(index) || undefined;
        if (!node)
            return false;
        if (node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     */
    NodeListImpl._create = function (root) {
        return new NodeListImpl(root);
    };
    return NodeListImpl;
}());
exports.NodeListImpl = NodeListImpl;
//# sourceMappingURL=NodeListImpl.js.map

/***/ }),

/***/ 5306:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var util_1 = __nccwpck_require__(6195);
/**
 * Represents an ordered list of nodes.
 * This is a static implementation of `NodeList`.
 */
var NodeListStaticImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */
    function NodeListStaticImpl(root) {
        this._live = false;
        this._items = [];
        this._length = 0;
        this._root = root;
        this._items = [];
        this._filter = function (node) { return true; };
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListStaticImpl.prototype, "length", {
        /** @inheritdoc */
        get: function () {
            /**
             * The length attribute must return the number of nodes represented by
             * the collection.
             */
            return this._items.length;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    NodeListStaticImpl.prototype.item = function (index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */
        if (index < 0 || index > this.length - 1)
            return null;
        return this._items[index];
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.keys = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var index = 0;
                return {
                    next: function () {
                        if (index === this.length) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: index++ };
                        }
                    }.bind(this)
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.values = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                return {
                    next: function () {
                        return it.next();
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.entries = function () {
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var it = this[Symbol.iterator]();
                var index = 0;
                return {
                    next: function () {
                        var itResult = it.next();
                        if (itResult.done) {
                            return { done: true, value: null };
                        }
                        else {
                            return { done: false, value: [index++, itResult.value] };
                        }
                    }
                };
            }.bind(this),
            _a;
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype[Symbol.iterator] = function () {
        var it = this._items[Symbol.iterator]();
        return {
            next: function () {
                return it.next();
            }
        };
    };
    /** @inheritdoc */
    NodeListStaticImpl.prototype.forEach = function (callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for (var _b = __values(this._items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */
    NodeListStaticImpl.prototype.get = function (target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target._items[index] || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */
    NodeListStaticImpl.prototype.set = function (target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        if (index >= 0 && index < target._items.length) {
            target._items[index] = value;
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     * @param items - a list of items to initialize the list
     */
    NodeListStaticImpl._create = function (root, items) {
        var list = new NodeListStaticImpl(root);
        list._items = items;
        return list;
    };
    return NodeListStaticImpl;
}());
exports.NodeListStaticImpl = NodeListStaticImpl;
//# sourceMappingURL=NodeListStaticImpl.js.map

/***/ }),

/***/ 1032:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(5282);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * other than doctypes. This mixin is implemented by {@link Element} and
 * {@link CharacterData}.
 */
var NonDocumentTypeChildNodeImpl = /** @class */ (function () {
    function NonDocumentTypeChildNodeImpl() {
    }
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "previousElementSibling", {
        /** @inheritdoc */
        get: function () {
            /**
             * The previousElementSibling attributeâ€™s getter must return the first
             * preceding sibling that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._previousSibling;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "nextElementSibling", {
        /** @inheritdoc */
        get: function () {
            /**
             * The nextElementSibling attributeâ€™s getter must return the first
             * following sibling that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._nextSibling;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return NonDocumentTypeChildNodeImpl;
}());
exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl;
//# sourceMappingURL=NonDocumentTypeChildNodeImpl.js.map

/***/ }),

/***/ 733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(5282);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a mixin that extends non-element parent nodes. This mixin
 * is implemented by {@link Document} and {@link DocumentFragment}.
 */
var NonElementParentNodeImpl = /** @class */ (function () {
    function NonElementParentNodeImpl() {
    }
    /** @inheritdoc */
    NonElementParentNodeImpl.prototype.getElementById = function (id) {
        /**
         * The getElementById(elementId) method, when invoked, must return the first
         * element, in tree order, within the context objectâ€™s descendants,
         * whose ID is elementId, and null if there is no such element otherwise.
         */
        var ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, function (e) { return util_1.Guard.isElementNode(e); });
        while (ele !== null) {
            if (ele._uniqueIdentifier === id) {
                return ele;
            }
            ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, function (e) { return util_1.Guard.isElementNode(e); });
        }
        return null;
    };
    return NonElementParentNodeImpl;
}());
exports.NonElementParentNodeImpl = NonElementParentNodeImpl;
//# sourceMappingURL=NonElementParentNodeImpl.js.map

/***/ }),

/***/ 5988:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(5282);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a mixin that extends parent nodes that can have children.
 * This mixin is implemented by {@link Element}, {@link Document} and
 * {@link DocumentFragment}.
 */
var ParentNodeImpl = /** @class */ (function () {
    function ParentNodeImpl() {
    }
    Object.defineProperty(ParentNodeImpl.prototype, "children", {
        /** @inheritdoc */
        get: function () {
            /**
             * The children attributeâ€™s getter must return an HTMLCollection collection
             * rooted at context object matching only element children.
             */
            return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "firstElementChild", {
        /** @inheritdoc */
        get: function () {
            /**
             * The firstElementChild attributeâ€™s getter must return the first child
             * that is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._firstChild;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "lastElementChild", {
        /** @inheritdoc */
        get: function () {
            /**
             * The lastElementChild attributeâ€™s getter must return the last child that
             * is an element, and null otherwise.
             */
            var node = util_1.Cast.asNode(this)._lastChild;
            while (node) {
                if (util_1.Guard.isElementNode(node))
                    return node;
                else
                    node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "childElementCount", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            /**
             * The childElementCount attributeâ€™s getter must return the number of
             * children of context object that are elements.
             */
            var count = 0;
            try {
                for (var _b = __values(util_1.Cast.asNode(this)._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    if (util_1.Guard.isElementNode(childNode))
                        count++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    ParentNodeImpl.prototype.prepend = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context objectâ€™s node document.
         * 2. Pre-insert node into context object before the context objectâ€™s first
         * child.
         */
        var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_preInsert(childNode, node, node._firstChild);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.append = function () {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context objectâ€™s node document.
         * 2. Append node to context object.
         */
        var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_append(childNode, node);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.querySelector = function (selectors) {
        /**
         * The querySelector(selectors) method, when invoked, must return the first
         * result of running scope-match a selectors string selectors against
         * context object, if the result is not an empty list, and null otherwise.
         */
        var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return (result.length === 0 ? null : result[0]);
    };
    /** @inheritdoc */
    ParentNodeImpl.prototype.querySelectorAll = function (selectors) {
        /**
         * The querySelectorAll(selectors) method, when invoked, must return the
         * static result of running scope-match a selectors string selectors against
         * context object.
         */
        var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return algorithm_1.create_nodeListStatic(node, result);
    };
    return ParentNodeImpl;
}());
exports.ParentNodeImpl = ParentNodeImpl;
//# sourceMappingURL=ParentNodeImpl.js.map

/***/ }),

/***/ 9430:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var CharacterDataImpl_1 = __nccwpck_require__(5330);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a processing instruction node.
 */
var ProcessingInstructionImpl = /** @class */ (function (_super) {
    __extends(ProcessingInstructionImpl, _super);
    /**
     * Initializes a new instance of `ProcessingInstruction`.
     */
    function ProcessingInstructionImpl(target, data) {
        var _this = _super.call(this, data) || this;
        _this._target = target;
        return _this;
    }
    Object.defineProperty(ProcessingInstructionImpl.prototype, "target", {
        /**
         * Gets the target of the {@link ProcessingInstruction} node.
         */
        get: function () { return this._target; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `ProcessingInstruction`.
     *
     * @param document - owner document
     * @param target - instruction target
     * @param data - node contents
     */
    ProcessingInstructionImpl._create = function (document, target, data) {
        var node = new ProcessingInstructionImpl(target, data);
        node._nodeDocument = document;
        return node;
    };
    return ProcessingInstructionImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction);
//# sourceMappingURL=ProcessingInstructionImpl.js.map

/***/ }),

/***/ 166:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DOMImpl_1 = __nccwpck_require__(4177);
var interfaces_1 = __nccwpck_require__(7305);
var AbstractRangeImpl_1 = __nccwpck_require__(7126);
var DOMException_1 = __nccwpck_require__(3166);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
var util_1 = __nccwpck_require__(5282);
/**
 * Represents a live range.
 */
var RangeImpl = /** @class */ (function (_super) {
    __extends(RangeImpl, _super);
    /**
     * Initializes a new instance of `Range`.
     */
    function RangeImpl() {
        var _this = _super.call(this) || this;
        /**
         * The Range() constructor, when invoked, must return a new live range with
         * (current global objectâ€™s associated Document, 0) as its start and end.
         */
        var doc = DOMImpl_1.dom.window._associatedDocument;
        _this._start = [doc, 0];
        _this._end = [doc, 0];
        DOMImpl_1.dom.rangeList.add(_this);
        return _this;
    }
    Object.defineProperty(RangeImpl.prototype, "commonAncestorContainer", {
        /** @inheritdoc */
        get: function () {
            /**
             * 1. Let container be start node.
             * 2. While container is not an inclusive ancestor of end node, let
             * container be containerâ€™s parent.
             * 3. Return container.
             */
            var container = this._start[0];
            while (!algorithm_1.tree_isAncestorOf(this._end[0], container, true)) {
                if (container._parent === null) {
                    throw new Error("Parent node  is null.");
                }
                container = container._parent;
            }
            return container;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    RangeImpl.prototype.setStart = function (node, offset) {
        /**
         * The setStart(node, offset) method, when invoked, must set the start of
         * context object to boundary point (node, offset).
         */
        algorithm_1.range_setTheStart(this, node, offset);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEnd = function (node, offset) {
        /**
         * The setEnd(node, offset) method, when invoked, must set the end of
         * context object to boundary point (node, offset).
         */
        algorithm_1.range_setTheEnd(this, node, offset);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setStartBefore = function (node) {
        /**
         * 1. Let parent be nodeâ€™s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, nodeâ€™s index).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */
    RangeImpl.prototype.setStartAfter = function (node) {
        /**
         * 1. Let parent be nodeâ€™s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, nodeâ€™s index plus 1).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEndBefore = function (node) {
        /**
         * 1. Let parent be nodeâ€™s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, nodeâ€™s index).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */
    RangeImpl.prototype.setEndAfter = function (node) {
        /**
         * 1. Let parent be nodeâ€™s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, nodeâ€™s index plus 1).
         */
        var parent = node._parent;
        if (parent === null)
            throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */
    RangeImpl.prototype.collapse = function (toStart) {
        /**
         * The collapse(toStart) method, when invoked, must if toStart is true,
         * set end to start, and set start to end otherwise.
         */
        if (toStart) {
            this._end = this._start;
        }
        else {
            this._start = this._end;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.selectNode = function (node) {
        /**
         * The selectNode(node) method, when invoked, must select node within
         * context object.
         */
        algorithm_1.range_select(node, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.selectNodeContents = function (node) {
        /**
         * 1. If node is a doctype, throw an "InvalidNodeTypeError" DOMException.
         * 2. Let length be the length of node.
         * 3. Set start to the boundary point (node, 0).
         * 4. Set end to the boundary point (node, length).
         */
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        var length = algorithm_1.tree_nodeLength(node);
        this._start = [node, 0];
        this._end = [node, length];
    };
    /** @inheritdoc */
    RangeImpl.prototype.compareBoundaryPoints = function (how, sourceRange) {
        /**
         * 1. If how is not one of
         * - START_TO_START,
         * - START_TO_END,
         * - END_TO_END, and
         * - END_TO_START,
         * then throw a "NotSupportedError" DOMException.
         */
        if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd &&
            how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart)
            throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context objectâ€™s root is not the same as sourceRangeâ€™s root,
         * then throw a "WrongDocumentError" DOMException.
         */
        if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange))
            throw new DOMException_1.WrongDocumentError();
        /**
         * 3. If how is:
         * - START_TO_START:
         * Let this point be the context objectâ€™s start. Let other point be
         * sourceRangeâ€™s start.
         * - START_TO_END:
         * Let this point be the context objectâ€™s end. Let other point be
         * sourceRangeâ€™s start.
         * - END_TO_END:
         * Let this point be the context objectâ€™s end. Let other point be
         * sourceRangeâ€™s end.
         * - END_TO_START:
         * Let this point be the context objectâ€™s start. Let other point be
         * sourceRangeâ€™s end.
         */
        var thisPoint;
        var otherPoint;
        switch (how) {
            case interfaces_1.HowToCompare.StartToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.StartToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.EndToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._end;
                break;
            case interfaces_1.HowToCompare.EndToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._end;
                break;
            /* istanbul ignore next */
            default:
                throw new DOMException_1.NotSupportedError();
        }
        /**
         * 4. If the position of this point relative to other point is
         * - before
         * Return âˆ’1.
         * - equal
         * Return 0.
         * - after
         * Return 1.
         */
        var position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);
        if (position === interfaces_1.BoundaryPosition.Before) {
            return -1;
        }
        else if (position === interfaces_1.BoundaryPosition.After) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.deleteContents = function () {
        var e_1, _a, e_2, _b;
        /**
         * 1. If the context object is collapsed, then return.
         * 2. Let original start node, original start offset, original end node,
         * and original end offset be the context objectâ€™s start node,
         * start offset, end node, and end offset, respectively.
         */
        if (algorithm_1.range_collapsed(this))
            return;
        var originalStartNode = this._startNode;
        var originalStartOffset = this._startOffset;
        var originalEndNode = this._endNode;
        var originalEndOffset = this._endOffset;
        /**
         * 3. If original start node and original end node are the same, and they
         * are a Text, ProcessingInstruction, or Comment node, replace data with
         * node original start node, offset original start offset, count original
         * end offset minus original start offset, and data the empty string,
         * and then return.
         */
        if (originalStartNode === originalEndNode &&
            util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, '');
            return;
        }
        /**
         * 4. Let nodes to remove be a list of all the nodes that are contained in
         * the context object, in tree order, omitting any node whose parent is also
         * contained in the context object.
         */
        var nodesToRemove = [];
        try {
            for (var _c = __values(algorithm_1.range_getContainedNodes(this)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                var parent = node._parent;
                if (parent !== null && algorithm_1.range_isContained(parent, this)) {
                    continue;
                }
                nodesToRemove.push(node);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var newNode;
        var newOffset;
        if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
            /**
             * 5. If original start node is an inclusive ancestor of original end
             * node, set new node to original start node and new offset to original
             * start offset.
             */
            newNode = originalStartNode;
            newOffset = originalStartOffset;
        }
        else {
            /**
             * 6. Otherwise:
             * 6.1. Let reference node equal original start node.
             * 6.2. While reference nodeâ€™s parent is not null and is not an inclusive
             * ancestor of original end node, set reference node to its parent.
             * 6.3. Set new node to the parent of reference node, and new offset to
             * one plus the index of reference node.
             */
            var referenceNode = originalStartNode;
            while (referenceNode._parent !== null &&
                !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)) {
                referenceNode = referenceNode._parent;
            }
            /* istanbul ignore next */
            if (referenceNode._parent === null) {
                throw new Error("Parent node is null.");
            }
            newNode = referenceNode._parent;
            newOffset = algorithm_1.tree_index(referenceNode) + 1;
        }
        /**
         * 7. If original start node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original start node, offset original start
         * offset, count original start nodeâ€™s length minus original start offset,
         * data the empty string.
         */
        if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, '');
        }
        try {
            /**
             * 8. For each node in nodes to remove, in tree order, remove node from its
             * parent.
             */
            for (var nodesToRemove_1 = __values(nodesToRemove), nodesToRemove_1_1 = nodesToRemove_1.next(); !nodesToRemove_1_1.done; nodesToRemove_1_1 = nodesToRemove_1.next()) {
                var node = nodesToRemove_1_1.value;
                /* istanbul ignore else */
                if (node._parent) {
                    algorithm_1.mutation_remove(node, node._parent);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (nodesToRemove_1_1 && !nodesToRemove_1_1.done && (_b = nodesToRemove_1.return)) _b.call(nodesToRemove_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        /**
         * 9. If original end node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original end node, offset 0, count original
         * end offset and data the empty string.
         */
        if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
            algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, '');
        }
        /**
         * 10. Set start and end to (new node, new offset).
         */
        this._start = [newNode, newOffset];
        this._end = [newNode, newOffset];
    };
    /** @inheritdoc */
    RangeImpl.prototype.extractContents = function () {
        /**
         * The extractContents() method, when invoked, must return the result of
         * extracting the context object.
         */
        return algorithm_1.range_extract(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.cloneContents = function () {
        /**
         * The cloneContents() method, when invoked, must return the result of
         * cloning the contents of the context object.
         */
        return algorithm_1.range_cloneTheContents(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.insertNode = function (node) {
        /**
         * The insertNode(node) method, when invoked, must insert node into the
         * context object.
         */
        return algorithm_1.range_insert(node, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.surroundContents = function (newParent) {
        var e_3, _a;
        try {
            /**
             * 1. If a non-Text node is partially contained in the context object, then
             * throw an "InvalidStateError" DOMException.
             */
            for (var _b = __values(algorithm_1.range_getPartiallyContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (!util_1.Guard.isTextNode(node)) {
                    throw new DOMException_1.InvalidStateError();
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 2. If newParent is a Document, DocumentType, or DocumentFragment node,
         * then throw an "InvalidNodeTypeError" DOMException.
         */
        if (util_1.Guard.isDocumentNode(newParent) ||
            util_1.Guard.isDocumentTypeNode(newParent) ||
            util_1.Guard.isDocumentFragmentNode(newParent)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        /**
         * 3. Let fragment be the result of extracting the context object.
         */
        var fragment = algorithm_1.range_extract(this);
        /**
         * 4. If newParent has children, then replace all with null within newParent.
         */
        if ((newParent)._children.size !== 0) {
            algorithm_1.mutation_replaceAll(null, newParent);
        }
        /**
         * 5. Insert newParent into the context object.
         * 6. Append fragment to newParent.
         */
        algorithm_1.range_insert(newParent, this);
        algorithm_1.mutation_append(fragment, newParent);
        /**
         * 7. Select newParent within the context object.
         */
        algorithm_1.range_select(newParent, this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.cloneRange = function () {
        /**
         * The cloneRange() method, when invoked, must return a new live range with
         * the same start and end as the context object.
         */
        return algorithm_1.create_range(this._start, this._end);
    };
    /** @inheritdoc */
    RangeImpl.prototype.detach = function () {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */
        DOMImpl_1.dom.rangeList.delete(this);
    };
    /** @inheritdoc */
    RangeImpl.prototype.isPointInRange = function (node, offset) {
        /**
         * 1. If nodeâ€™s root is different from the context objectâ€™s root, return false.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than nodeâ€™s length, then throw an
         * "IndexSizeError" DOMException.
         */
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node))
            throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start or after end, return false.
         */
        var bp = [node, offset];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before ||
            algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return false;
        }
        /**
         * 5. Return true.
         */
        return true;
    };
    /** @inheritdoc */
    RangeImpl.prototype.comparePoint = function (node, offset) {
        /**
         * 1. If nodeâ€™s root is different from the context objectâ€™s root, then throw
         * a "WrongDocumentError" DOMException.
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than nodeâ€™s length, then throw an
         * "IndexSizeError" DOMException.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this))
            throw new DOMException_1.WrongDocumentError();
        if (util_1.Guard.isDocumentTypeNode(node))
            throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node))
            throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start, return âˆ’1.
         * 5. If (node, offset) is after end, return 1.
         * 6. Return 0.
         */
        var bp = [node, offset];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
            return -1;
        }
        else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return 1;
        }
        else {
            return 0;
        }
    };
    /** @inheritdoc */
    RangeImpl.prototype.intersectsNode = function (node) {
        /**
         * 1. If nodeâ€™s root is different from the context objectâ€™s root, return false.
         */
        if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. Let parent be nodeâ€™s parent.
         * 3. If parent is null, return true.
         */
        var parent = node._parent;
        if (parent === null)
            return true;
        /**
         * 4. Let offset be nodeâ€™s index.
         */
        var offset = algorithm_1.tree_index(node);
        /**
         * 5. If (parent, offset) is before end and (parent, offset plus 1) is
         * after start, return true.
         */
        if (algorithm_1.boundaryPoint_position([parent, offset], this._end) === interfaces_1.BoundaryPosition.Before &&
            algorithm_1.boundaryPoint_position([parent, offset + 1], this._start) === interfaces_1.BoundaryPosition.After) {
            return true;
        }
        /**
         * 6. Return false.
         */
        return false;
    };
    RangeImpl.prototype.toString = function () {
        var e_4, _a;
        /**
         * 1. Let s be the empty string.
         */
        var s = '';
        /**
         * 2. If the context objectâ€™s start node is the context objectâ€™s end node
         * and it is a Text node, then return the substring of that Text nodeâ€™s data
         * beginning at the context objectâ€™s start offset and ending at the context
         * objectâ€™s end offset.
         */
        if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
            return this._startNode._data.substring(this._startOffset, this._endOffset);
        }
        /**
         * 3. If the context objectâ€™s start node is a Text node, then append the
         * substring of that nodeâ€™s data from the context objectâ€™s start offset
         * until the end to s.
         */
        if (util_1.Guard.isTextNode(this._startNode)) {
            s += this._startNode._data.substring(this._startOffset);
        }
        try {
            /**
             * 4. Append the concatenation of the data of all Text nodes that are
             * contained in the context object, in tree order, to s.
             */
            for (var _b = __values(algorithm_1.range_getContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (util_1.Guard.isTextNode(child)) {
                    s += child._data;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        /**
         * 5. If the context objectâ€™s end node is a Text node, then append the
         * substring of that nodeâ€™s data from its start until the context objectâ€™s
         * end offset to s.
         */
        if (util_1.Guard.isTextNode(this._endNode)) {
            s += this._endNode._data.substring(0, this._endOffset);
        }
        /**
         * 6. Return s.
         */
        return s;
    };
    /**
     * Creates a new `Range`.
     *
     * @param start - start point
     * @param end - end point
     */
    RangeImpl._create = function (start, end) {
        var range = new RangeImpl();
        if (start)
            range._start = start;
        if (end)
            range._end = end;
        return range;
    };
    RangeImpl.START_TO_START = 0;
    RangeImpl.START_TO_END = 1;
    RangeImpl.END_TO_END = 2;
    RangeImpl.END_TO_START = 3;
    return RangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl));
exports.RangeImpl = RangeImpl;
/**
 * Define constants on prototype.
 */
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_START", 0);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_END", 1);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_END", 2);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_START", 3);
//# sourceMappingURL=RangeImpl.js.map

/***/ }),

/***/ 1911:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DocumentFragmentImpl_1 = __nccwpck_require__(2585);
var util_1 = __nccwpck_require__(6195);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a shadow root.
 */
var ShadowRootImpl = /** @class */ (function (_super) {
    __extends(ShadowRootImpl, _super);
    /**
     * Initializes a new instance of `ShadowRoot`.
     *
     * @param host - shadow root's host element
     * @param mode - shadow root's mode
     */
    function ShadowRootImpl(host, mode) {
        var _this = _super.call(this) || this;
        _this._host = host;
        _this._mode = mode;
        return _this;
    }
    Object.defineProperty(ShadowRootImpl.prototype, "mode", {
        /** @inheritdoc */
        get: function () { return this._mode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowRootImpl.prototype, "host", {
        /** @inheritdoc */
        get: function () { return this._host; },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */
    ShadowRootImpl.prototype._getTheParent = function (event) {
        /**
         * A shadow rootâ€™s get the parent algorithm, given an event, returns null
         * if eventâ€™s composed flag is unset and shadow root is the root of
         * eventâ€™s pathâ€™s first structâ€™s invocation target, and shadow rootâ€™s host
         * otherwise.
         */
        if (!event._composedFlag && !util_1.isEmpty(event._path) &&
            algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {
            return null;
        }
        else {
            return this._host;
        }
    };
    // MIXIN: DocumentOrShadowRoot
    // No elements
    /**
     * Creates a new `ShadowRoot`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */
    ShadowRootImpl._create = function (document, host) {
        return new ShadowRootImpl(host, "closed");
    };
    return ShadowRootImpl;
}(DocumentFragmentImpl_1.DocumentFragmentImpl));
exports.ShadowRootImpl = ShadowRootImpl;
//# sourceMappingURL=ShadowRootImpl.js.map

/***/ }),

/***/ 1964:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a mixin that allows nodes to become the contents of
 * a <slot> element. This mixin is implemented by {@link Element} and
 * {@link Text}.
 */
var SlotableImpl = /** @class */ (function () {
    function SlotableImpl() {
    }
    Object.defineProperty(SlotableImpl.prototype, "_name", {
        get: function () { return this.__name || ''; },
        set: function (val) { this.__name = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "_assignedSlot", {
        get: function () { return this.__assignedSlot || null; },
        set: function (val) { this.__assignedSlot = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "assignedSlot", {
        /** @inheritdoc */
        get: function () {
            return algorithm_1.shadowTree_findASlot(this, true);
        },
        enumerable: true,
        configurable: true
    });
    return SlotableImpl;
}());
exports.SlotableImpl = SlotableImpl;
//# sourceMappingURL=SlotableImpl.js.map

/***/ }),

/***/ 6357:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractRangeImpl_1 = __nccwpck_require__(7126);
var DOMException_1 = __nccwpck_require__(3166);
var util_1 = __nccwpck_require__(5282);
/**
 * Represents a static range.
 */
var StaticRangeImpl = /** @class */ (function (_super) {
    __extends(StaticRangeImpl, _super);
    /**
     * Initializes a new instance of `StaticRange`.
     */
    function StaticRangeImpl(init) {
        var _this = _super.call(this) || this;
        /**
         * 1. If initâ€™s startContainer or endContainer is a DocumentType or Attr
         * node, then throw an "InvalidNodeTypeError" DOMException.
         * 2. Let staticRange be a new StaticRange object.
         * 3. Set staticRangeâ€™s start to (initâ€™s startContainer, initâ€™s startOffset)
         * and end to (initâ€™s endContainer, initâ€™s endOffset).
         * 4. Return staticRange.
         */
        if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) ||
            util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        _this._start = [init.startContainer, init.startOffset];
        _this._end = [init.endContainer, init.endOffset];
        return _this;
    }
    return StaticRangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl));
exports.StaticRangeImpl = StaticRangeImpl;
//# sourceMappingURL=StaticRangeImpl.js.map

/***/ }),

/***/ 2191:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var CharacterDataImpl_1 = __nccwpck_require__(5330);
var algorithm_1 = __nccwpck_require__(61);
var WebIDLAlgorithm_1 = __nccwpck_require__(5457);
/**
 * Represents a text node.
 */
var TextImpl = /** @class */ (function (_super) {
    __extends(TextImpl, _super);
    /**
     * Initializes a new instance of `Text`.
     *
     * @param data - the text content
     */
    function TextImpl(data) {
        if (data === void 0) { data = ''; }
        var _this = _super.call(this, data) || this;
        _this._name = '';
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(TextImpl.prototype, "wholeText", {
        /** @inheritdoc */
        get: function () {
            var e_1, _a;
            /**
             * The wholeText attributeâ€™s getter must return the concatenation of the
             * data of the contiguous Text nodes of the context object, in tree order.
             */
            var text = '';
            try {
                for (var _b = __values(algorithm_1.text_contiguousTextNodes(this, true)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    text = text + node._data;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return text;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    TextImpl.prototype.splitText = function (offset) {
        /**
         * The splitText(offset) method, when invoked, must split context object
         * with offset offset.
         */
        return algorithm_1.text_split(this, offset);
    };
    Object.defineProperty(TextImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */
        get: function () { throw new Error("Mixin: Slotable not implemented."); },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a `Text`.
     *
     * @param document - owner document
     * @param data - the text content
     */
    TextImpl._create = function (document, data) {
        if (data === void 0) { data = ''; }
        var node = new TextImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return TextImpl;
}(CharacterDataImpl_1.CharacterDataImpl));
exports.TextImpl = TextImpl;
/**
 * Initialize prototype properties
 */
WebIDLAlgorithm_1.idl_defineConst(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text);
//# sourceMappingURL=TextImpl.js.map

/***/ }),

/***/ 9782:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */
var TraverserImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `Traverser`.
     *
     * @param root - root node
     */
    function TraverserImpl(root) {
        this._activeFlag = false;
        this._root = root;
        this._whatToShow = interfaces_1.WhatToShow.All;
        this._filter = null;
    }
    Object.defineProperty(TraverserImpl.prototype, "root", {
        /** @inheritdoc */
        get: function () { return this._root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "whatToShow", {
        /** @inheritdoc */
        get: function () { return this._whatToShow; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "filter", {
        /** @inheritdoc */
        get: function () { return this._filter; },
        enumerable: true,
        configurable: true
    });
    return TraverserImpl;
}());
exports.TraverserImpl = TraverserImpl;
//# sourceMappingURL=TraverserImpl.js.map

/***/ }),

/***/ 9261:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var TraverserImpl_1 = __nccwpck_require__(9782);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents the nodes of a subtree and a position within them.
 */
var TreeWalkerImpl = /** @class */ (function (_super) {
    __extends(TreeWalkerImpl, _super);
    /**
     * Initializes a new instance of `TreeWalker`.
     */
    function TreeWalkerImpl(root, current) {
        var _this = _super.call(this, root) || this;
        _this._current = current;
        return _this;
    }
    Object.defineProperty(TreeWalkerImpl.prototype, "currentNode", {
        /** @inheritdoc */
        get: function () { return this._current; },
        set: function (value) { this._current = value; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    TreeWalkerImpl.prototype.parentNode = function () {
        /**
         * 1. Let node be the context objectâ€™s current.
         * 2. While node is non-null and is not the context objectâ€™s root:
         */
        var node = this._current;
        while (node !== null && node !== this._root) {
            /**
             * 2.1. Set node to nodeâ€™s parent.
             * 2.2. If node is non-null and filtering node within the context object
             * returns FILTER_ACCEPT, then set the context objectâ€™s current to node
             * and return node.
             */
            node = node._parent;
            if (node !== null &&
                algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */
        return null;
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.firstChild = function () {
        /**
         * The firstChild() method, when invoked, must traverse children with the
         * context object and first.
         */
        return algorithm_1.treeWalker_traverseChildren(this, true);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.lastChild = function () {
        /**
         * The lastChild() method, when invoked, must traverse children with the
         * context object and last.
         */
        return algorithm_1.treeWalker_traverseChildren(this, false);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.nextSibling = function () {
        /**
         * The nextSibling() method, when invoked, must traverse siblings with the
         * context object and next.
         */
        return algorithm_1.treeWalker_traverseSiblings(this, true);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.previousNode = function () {
        /**
         * 1. Let node be the context objectâ€™s current.
         * 2. While node is not the context objectâ€™s root:
         */
        var node = this._current;
        while (node !== this._root) {
            /**
             * 2.1. Let sibling be nodeâ€™s previous sibling.
             * 2.2. While sibling is non-null:
             */
            var sibling = node._previousSibling;
            while (sibling) {
                /**
                 * 2.2.1. Set node to sibling.
                 * 2.2.2. Let result be the result of filtering node within the context
                 * object.
                 */
                node = sibling;
                var result = algorithm_1.traversal_filter(this, node);
                /**
                 * 2.2.3. While result is not FILTER_REJECT and node has a child:
                 */
                while (result !== interfaces_1.FilterResult.Reject && node._lastChild) {
                    /**
                     * 2.2.3.1. Set node to nodeâ€™s last child.
                     * 2.2.3.2. Set result to the result of filtering node within the
                     * context object.
                     */
                    node = node._lastChild;
                    result = algorithm_1.traversal_filter(this, node);
                }
                /**
                 * 2.2.4. If result is FILTER_ACCEPT, then set the context objectâ€™s
                 * current to node and return node.
                 */
                if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
                /**
                 * 2.2.5. Set sibling to nodeâ€™s previous sibling.
                 */
                sibling = node._previousSibling;
            }
            /**
             * 2.3. If node is the context objectâ€™s root or nodeâ€™s parent is null,
             * then return null.
             */
            if (node === this._root || node._parent === null) {
                return null;
            }
            /**
             * 2.4. Set node to nodeâ€™s parent.
             */
            node = node._parent;
            /**
             * 2.5. If the return value of filtering node within the context object is
             * FILTER_ACCEPT, then set the context objectâ€™s current to node and
             * return node.
             */
            if (algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */
        return null;
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.previousSibling = function () {
        /**
         * The previousSibling() method, when invoked, must traverse siblings with
         * the context object and previous.
         */
        return algorithm_1.treeWalker_traverseSiblings(this, false);
    };
    /** @inheritdoc */
    TreeWalkerImpl.prototype.nextNode = function () {
        /**
         * 1. Let node be the context objectâ€™s current.
         * 2. Let result be FILTER_ACCEPT.
         * 3. While true:
         */
        var node = this._current;
        var result = interfaces_1.FilterResult.Accept;
        while (true) {
            /**
             * 3.1. While result is not FILTER_REJECT and node has a child:
             */
            while (result !== interfaces_1.FilterResult.Reject && node._firstChild) {
                /**
                 * 3.1.1. Set node to its first child.
                 * 3.1.2. Set result to the result of filtering node within the context
                 * object.
                 * 3.1.3. If result is FILTER_ACCEPT, then set the context objectâ€™s
                 * current to node and return node.
                 */
                node = node._firstChild;
                result = algorithm_1.traversal_filter(this, node);
                if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
            }
            /**
             * 3.2. Let sibling be null.
             * 3.3. Let temporary be node.
             * 3.4. While temporary is non-null:
             */
            var sibling = null;
            var temporary = node;
            while (temporary !== null) {
                /**
                 * 3.4.1. If temporary is the context objectâ€™s root, then return null.
                 */
                if (temporary === this._root) {
                    return null;
                }
                /**
                 * 3.4.2. Set sibling to temporaryâ€™s next sibling.
                 * 3.4.3. If sibling is non-null, then break.
                 */
                sibling = temporary._nextSibling;
                if (sibling !== null) {
                    node = sibling;
                    break;
                }
                /**
                 * 3.4.4. Set temporary to temporaryâ€™s parent.
                 */
                temporary = temporary._parent;
            }
            /**
             * 3.5. Set result to the result of filtering node within the context object.
             * 3.6. If result is FILTER_ACCEPT, then set the context objectâ€™s current
             * to node and return node.
             */
            result = algorithm_1.traversal_filter(this, node);
            if (result === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
    };
    /**
     * Creates a new `TreeWalker`.
     *
     * @param root - iterator's root node
     * @param current - current node
     */
    TreeWalkerImpl._create = function (root, current) {
        return new TreeWalkerImpl(root, current);
    };
    return TreeWalkerImpl;
}(TraverserImpl_1.TraverserImpl));
exports.TreeWalkerImpl = TreeWalkerImpl;
//# sourceMappingURL=TreeWalkerImpl.js.map

/***/ }),

/***/ 9067:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var EventTargetImpl_1 = __nccwpck_require__(9968);
var util_1 = __nccwpck_require__(6195);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents a window containing a DOM document.
 */
var WindowImpl = /** @class */ (function (_super) {
    __extends(WindowImpl, _super);
    /**
     * Initializes a new instance of `Window`.
     */
    function WindowImpl() {
        var _this = _super.call(this) || this;
        _this._signalSlots = new Set();
        _this._mutationObserverMicrotaskQueued = false;
        _this._mutationObservers = new Set();
        _this._iteratorList = new util_1.FixedSizeSet();
        _this._associatedDocument = algorithm_1.create_document();
        return _this;
    }
    Object.defineProperty(WindowImpl.prototype, "document", {
        /** @inheritdoc */
        get: function () { return this._associatedDocument; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowImpl.prototype, "event", {
        /** @inheritdoc */
        get: function () { return this._currentEvent; },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new window with a blank document.
     */
    WindowImpl._create = function () {
        return new WindowImpl();
    };
    return WindowImpl;
}(EventTargetImpl_1.EventTargetImpl));
exports.WindowImpl = WindowImpl;
//# sourceMappingURL=WindowImpl.js.map

/***/ }),

/***/ 1685:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var DocumentImpl_1 = __nccwpck_require__(4333);
/**
 * Represents an XML document.
 */
var XMLDocumentImpl = /** @class */ (function (_super) {
    __extends(XMLDocumentImpl, _super);
    /**
     * Initializes a new instance of `XMLDocument`.
     */
    function XMLDocumentImpl() {
        return _super.call(this) || this;
    }
    return XMLDocumentImpl;
}(DocumentImpl_1.DocumentImpl));
exports.XMLDocumentImpl = XMLDocumentImpl;
//# sourceMappingURL=XMLDocumentImpl.js.map

/***/ }),

/***/ 633:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
// Import implementation classes
var AbortControllerImpl_1 = __nccwpck_require__(6461);
exports.AbortController = AbortControllerImpl_1.AbortControllerImpl;
var AbortSignalImpl_1 = __nccwpck_require__(22);
exports.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;
var AbstractRangeImpl_1 = __nccwpck_require__(7126);
exports.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;
var AttrImpl_1 = __nccwpck_require__(7875);
exports.Attr = AttrImpl_1.AttrImpl;
var CDATASectionImpl_1 = __nccwpck_require__(3977);
exports.CDATASection = CDATASectionImpl_1.CDATASectionImpl;
var CharacterDataImpl_1 = __nccwpck_require__(5330);
exports.CharacterData = CharacterDataImpl_1.CharacterDataImpl;
var ChildNodeImpl_1 = __nccwpck_require__(8264);
var CommentImpl_1 = __nccwpck_require__(930);
exports.Comment = CommentImpl_1.CommentImpl;
var CustomEventImpl_1 = __nccwpck_require__(9857);
exports.CustomEvent = CustomEventImpl_1.CustomEventImpl;
var DocumentFragmentImpl_1 = __nccwpck_require__(2585);
exports.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;
var DocumentImpl_1 = __nccwpck_require__(4333);
exports.Document = DocumentImpl_1.DocumentImpl;
var DocumentOrShadowRootImpl_1 = __nccwpck_require__(5274);
var DocumentTypeImpl_1 = __nccwpck_require__(3173);
exports.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;
var DOMImpl_1 = __nccwpck_require__(4177);
exports.dom = DOMImpl_1.dom;
var DOMImplementationImpl_1 = __nccwpck_require__(2197);
exports.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;
var DOMTokenListImpl_1 = __nccwpck_require__(5096);
exports.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;
var ElementImpl_1 = __nccwpck_require__(5975);
exports.Element = ElementImpl_1.ElementImpl;
var EventImpl_1 = __nccwpck_require__(8245);
exports.Event = EventImpl_1.EventImpl;
var EventTargetImpl_1 = __nccwpck_require__(9968);
exports.EventTarget = EventTargetImpl_1.EventTargetImpl;
var HTMLCollectionImpl_1 = __nccwpck_require__(3969);
exports.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;
var MutationObserverImpl_1 = __nccwpck_require__(9616);
exports.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;
var MutationRecordImpl_1 = __nccwpck_require__(6219);
exports.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;
var NamedNodeMapImpl_1 = __nccwpck_require__(7206);
exports.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;
var NodeFilterImpl_1 = __nccwpck_require__(2355);
exports.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;
var NodeImpl_1 = __nccwpck_require__(1745);
exports.Node = NodeImpl_1.NodeImpl;
var NodeIteratorImpl_1 = __nccwpck_require__(1997);
exports.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;
var NodeListImpl_1 = __nccwpck_require__(3728);
exports.NodeList = NodeListImpl_1.NodeListImpl;
var NodeListStaticImpl_1 = __nccwpck_require__(5306);
exports.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;
var NonDocumentTypeChildNodeImpl_1 = __nccwpck_require__(1032);
var NonElementParentNodeImpl_1 = __nccwpck_require__(733);
var ParentNodeImpl_1 = __nccwpck_require__(5988);
var ProcessingInstructionImpl_1 = __nccwpck_require__(9430);
exports.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;
var RangeImpl_1 = __nccwpck_require__(166);
exports.Range = RangeImpl_1.RangeImpl;
var ShadowRootImpl_1 = __nccwpck_require__(1911);
exports.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;
var SlotableImpl_1 = __nccwpck_require__(1964);
var StaticRangeImpl_1 = __nccwpck_require__(6357);
exports.StaticRange = StaticRangeImpl_1.StaticRangeImpl;
var TextImpl_1 = __nccwpck_require__(2191);
exports.Text = TextImpl_1.TextImpl;
var TraverserImpl_1 = __nccwpck_require__(9782);
exports.Traverser = TraverserImpl_1.TraverserImpl;
var TreeWalkerImpl_1 = __nccwpck_require__(9261);
exports.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;
var WindowImpl_1 = __nccwpck_require__(9067);
exports.Window = WindowImpl_1.WindowImpl;
var XMLDocumentImpl_1 = __nccwpck_require__(1685);
exports.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;
// Apply mixins
// ChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
// DocumentOrShadowRoot
util_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
util_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
// NonDocumentTypeChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
// NonElementParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
// ParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
// Slotable
util_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines the position of a boundary point relative to another.
 */
var BoundaryPosition;
(function (BoundaryPosition) {
    BoundaryPosition[BoundaryPosition["Before"] = 0] = "Before";
    BoundaryPosition[BoundaryPosition["Equal"] = 1] = "Equal";
    BoundaryPosition[BoundaryPosition["After"] = 2] = "After";
})(BoundaryPosition = exports.BoundaryPosition || (exports.BoundaryPosition = {}));
/**
 * Defines the event phase.
 */
var EventPhase;
(function (EventPhase) {
    EventPhase[EventPhase["None"] = 0] = "None";
    EventPhase[EventPhase["Capturing"] = 1] = "Capturing";
    EventPhase[EventPhase["AtTarget"] = 2] = "AtTarget";
    EventPhase[EventPhase["Bubbling"] = 3] = "Bubbling";
})(EventPhase = exports.EventPhase || (exports.EventPhase = {}));
/**
 * Defines the type of a node object.
 */
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Element"] = 1] = "Element";
    NodeType[NodeType["Attribute"] = 2] = "Attribute";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CData"] = 4] = "CData";
    NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
    NodeType[NodeType["Entity"] = 6] = "Entity";
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType[NodeType["Comment"] = 8] = "Comment";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType[NodeType["Notation"] = 12] = "Notation"; // historical
})(NodeType = exports.NodeType || (exports.NodeType = {}));
/**
 * Defines the position of a node in the document relative to another
 * node.
 */
var Position;
(function (Position) {
    Position[Position["Disconnected"] = 1] = "Disconnected";
    Position[Position["Preceding"] = 2] = "Preceding";
    Position[Position["Following"] = 4] = "Following";
    Position[Position["Contains"] = 8] = "Contains";
    Position[Position["ContainedBy"] = 16] = "ContainedBy";
    Position[Position["ImplementationSpecific"] = 32] = "ImplementationSpecific";
})(Position = exports.Position || (exports.Position = {}));
/**
 * Defines the return value of a filter callback.
 */
var FilterResult;
(function (FilterResult) {
    FilterResult[FilterResult["Accept"] = 1] = "Accept";
    FilterResult[FilterResult["Reject"] = 2] = "Reject";
    FilterResult[FilterResult["Skip"] = 3] = "Skip";
})(FilterResult = exports.FilterResult || (exports.FilterResult = {}));
/**
 * Defines what to show in node filter.
 */
var WhatToShow;
(function (WhatToShow) {
    WhatToShow[WhatToShow["All"] = 4294967295] = "All";
    WhatToShow[WhatToShow["Element"] = 1] = "Element";
    WhatToShow[WhatToShow["Attribute"] = 2] = "Attribute";
    WhatToShow[WhatToShow["Text"] = 4] = "Text";
    WhatToShow[WhatToShow["CDataSection"] = 8] = "CDataSection";
    WhatToShow[WhatToShow["EntityReference"] = 16] = "EntityReference";
    WhatToShow[WhatToShow["Entity"] = 32] = "Entity";
    WhatToShow[WhatToShow["ProcessingInstruction"] = 64] = "ProcessingInstruction";
    WhatToShow[WhatToShow["Comment"] = 128] = "Comment";
    WhatToShow[WhatToShow["Document"] = 256] = "Document";
    WhatToShow[WhatToShow["DocumentType"] = 512] = "DocumentType";
    WhatToShow[WhatToShow["DocumentFragment"] = 1024] = "DocumentFragment";
    WhatToShow[WhatToShow["Notation"] = 2048] = "Notation";
})(WhatToShow = exports.WhatToShow || (exports.WhatToShow = {}));
/**
 * Defines how boundary points are compared.
 */
var HowToCompare;
(function (HowToCompare) {
    HowToCompare[HowToCompare["StartToStart"] = 0] = "StartToStart";
    HowToCompare[HowToCompare["StartToEnd"] = 1] = "StartToEnd";
    HowToCompare[HowToCompare["EndToEnd"] = 2] = "EndToEnd";
    HowToCompare[HowToCompare["EndToStart"] = 3] = "EndToStart";
})(HowToCompare = exports.HowToCompare || (exports.HowToCompare = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 4646:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(633);
dom_1.dom.setFeatures(true);
var dom_2 = __nccwpck_require__(633);
exports.DOMImplementation = dom_2.DOMImplementation;
var parser_1 = __nccwpck_require__(6216);
exports.DOMParser = parser_1.DOMParser;
var serializer_1 = __nccwpck_require__(7119);
exports.XMLSerializer = serializer_1.XMLSerializer;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8845:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var algorithm_1 = __nccwpck_require__(61);
var XMLParserImpl_1 = __nccwpck_require__(4126);
/**
 * Represents a parser for XML and HTML content.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-domparser-interface
 */
var DOMParserImpl = /** @class */ (function () {
    function DOMParserImpl() {
    }
    /** @inheritdoc */
    DOMParserImpl.prototype.parseFromString = function (source, mimeType) {
        if (mimeType === "text/html")
            throw new Error('HTML parser not implemented.');
        try {
            var parser = new XMLParserImpl_1.XMLParserImpl();
            var doc = parser.parse(source);
            doc._contentType = mimeType;
            return doc;
        }
        catch (e) {
            var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
            var doc = algorithm_1.create_xmlDocument();
            var root = doc.createElementNS(errorNS, "parsererror");
            var ele = doc.createElementNS(errorNS, "error");
            ele.setAttribute("message", e.message);
            root.appendChild(ele);
            doc.appendChild(root);
            return doc;
        }
    };
    return DOMParserImpl;
}());
exports.DOMParserImpl = DOMParserImpl;
//# sourceMappingURL=DOMParserImpl.js.map

/***/ }),

/***/ 4126:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLStringLexer_1 = __nccwpck_require__(7061);
var interfaces_1 = __nccwpck_require__(7707);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
var LocalNameSet_1 = __nccwpck_require__(9049);
/**
 * Represents a parser for XML content.
 *
 * See: https://html.spec.whatwg.org/#xml-parser
 */
var XMLParserImpl = /** @class */ (function () {
    function XMLParserImpl() {
    }
    /**
     * Parses XML content.
     *
     * @param source - a string containing XML content
     */
    XMLParserImpl.prototype.parse = function (source) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(source, { skipWhitespaceOnlyText: true });
        var doc = algorithm_1.create_document();
        var context = doc;
        var token = lexer.nextToken();
        while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    if (declaration.version !== "1.0") {
                        throw new Error("Invalid xml version: " + declaration.version);
                    }
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {
                        throw new Error("DocType public identifier does not match PubidChar construct.");
                    }
                    if (!algorithm_1.xml_isLegalChar(doctype.sysId) ||
                        (doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1)) {
                        throw new Error("DocType system identifier contains invalid characters.");
                    }
                    context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    if (!algorithm_1.xml_isLegalChar(cdata.data) ||
                        cdata.data.indexOf("]]>") !== -1) {
                        throw new Error("CDATA contains invalid characters.");
                    }
                    context.appendChild(doc.createCDATASection(cdata.data));
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    if (!algorithm_1.xml_isLegalChar(comment.data) ||
                        comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
                        throw new Error("Comment data contains invalid characters.");
                    }
                    context.appendChild(doc.createComment(comment.data));
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    if (pi.target.indexOf(":") !== -1 || (/^xml$/i).test(pi.target)) {
                        throw new Error("Processing instruction target contains invalid characters.");
                    }
                    if (!algorithm_1.xml_isLegalChar(pi.data) || pi.data.indexOf("?>") !== -1) {
                        throw new Error("Processing instruction data contains invalid characters.");
                    }
                    context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
                    break;
                case interfaces_1.TokenType.Text:
                    var text = token;
                    if (!algorithm_1.xml_isLegalChar(text.data)) {
                        throw new Error("Text data contains invalid characters.");
                    }
                    context.appendChild(doc.createTextNode(this._decodeText(text.data)));
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(element.name), 2), prefix = _c[0], localName = _c[1];
                    if (localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(localName)) {
                        throw new Error("Node local name contains invalid characters.");
                    }
                    if (prefix === "xmlns") {
                        throw new Error("An element cannot have the 'xmlns' prefix.");
                    }
                    var namespace = context.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            if (attName === "xmlns") {
                                namespace = attValue;
                            }
                            else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // create the DOM element node
                    var elementNode = (namespace !== null ?
                        doc.createElementNS(namespace, element.name) :
                        doc.createElement(element.name));
                    context.appendChild(elementNode);
                    // assign attributes
                    var localNameSet = new LocalNameSet_1.LocalNameSet();
                    try {
                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || (attPrefix === null && attLocalName === "xmlns")) {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            }
                            else {
                                attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                }
                                else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (localNameSet.has(attNamespace, attLocalName)) {
                                throw new Error("Element contains duplicate attributes.");
                            }
                            localNameSet.set(attNamespace, attLocalName);
                            if (attNamespace === infra_1.namespace.XMLNS) {
                                if (attValue === infra_1.namespace.XMLNS) {
                                    throw new Error("XMLNS namespace is reserved.");
                                }
                            }
                            if (attLocalName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attLocalName)) {
                                throw new Error("Attribute local name contains invalid characters.");
                            }
                            if (attPrefix === "xmlns" && attValue === "") {
                                throw new Error("Empty XML namespace is not allowed.");
                            }
                            if (attNamespace !== null)
                                elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
                            else
                                elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    var closingTag = token;
                    if (closingTag.name !== context.nodeName) {
                        throw new Error('Closing tag name does not match opening tag name.');
                    }
                    /* istanbul ignore else */
                    if (context._parent) {
                        context = context._parent;
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return doc;
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */
    XMLParserImpl.prototype._decodeText = function (text) {
        return text == null ? text : text.replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */
    XMLParserImpl.prototype._decodeAttributeValue = function (text) {
        return text == null ? text : text.replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&amp;/g, '&');
    };
    return XMLParserImpl;
}());
exports.XMLParserImpl = XMLParserImpl;
//# sourceMappingURL=XMLParserImpl.js.map

/***/ }),

/***/ 7061:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7707);
/**
 * Represents a lexer for XML content in a string.
 */
var XMLStringLexer = /** @class */ (function () {
    /**
     * Initializes a new instance of `XMLStringLexer`.
     *
     * @param str - the string to tokenize and lex
     * @param options - lexer options
     */
    function XMLStringLexer(str, options) {
        this._options = {
            skipWhitespaceOnlyText: false
        };
        this.err = { line: -1, col: -1, index: -1, str: "" };
        this._str = str;
        this._index = 0;
        this._length = str.length;
        if (options) {
            this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
        }
    }
    /**
     * Returns the next token.
     */
    XMLStringLexer.prototype.nextToken = function () {
        if (this.eof()) {
            return { type: interfaces_1.TokenType.EOF };
        }
        var token = (this.skipIfStartsWith('<') ? this.openBracket() : this.text());
        if (this._options.skipWhitespaceOnlyText) {
            if (token.type === interfaces_1.TokenType.Text &&
                XMLStringLexer.isWhiteSpaceToken(token)) {
                token = this.nextToken();
            }
        }
        return token;
    };
    /**
     * Branches from an opening bracket (`<`).
     */
    XMLStringLexer.prototype.openBracket = function () {
        if (this.skipIfStartsWith('?')) {
            if (this.skipIfStartsWith('xml')) {
                if (XMLStringLexer.isSpace(this._str[this._index])) {
                    return this.declaration();
                }
                else {
                    // a processing instruction starting with xml. e.g. <?xml-stylesheet href="doc.xsl" type="text/xsl"?>
                    this.seek(-3);
                    return this.pi();
                }
            }
            else {
                return this.pi();
            }
        }
        else if (this.skipIfStartsWith('!')) {
            if (this.skipIfStartsWith('--')) {
                return this.comment();
            }
            else if (this.skipIfStartsWith('[CDATA[')) {
                return this.cdata();
            }
            else if (this.skipIfStartsWith('DOCTYPE')) {
                return this.doctype();
            }
            else {
                this.throwError("Invalid '!' in opening tag.");
            }
        }
        else if (this.skipIfStartsWith('/')) {
            return this.closeTag();
        }
        else {
            return this.openTag();
        }
    };
    /**
     * Produces an XML declaration token.
     */
    XMLStringLexer.prototype.declaration = function () {
        var version = '';
        var encoding = '';
        var standalone = '';
        while (!this.eof()) {
            this.skipSpace();
            if (this.skipIfStartsWith('?>')) {
                return { type: interfaces_1.TokenType.Declaration, version: version, encoding: encoding, standalone: standalone };
            }
            else {
                // attribute name
                var _a = __read(this.attribute(), 2), attName = _a[0], attValue = _a[1];
                if (attName === 'version')
                    version = attValue;
                else if (attName === 'encoding')
                    encoding = attValue;
                else if (attName === 'standalone')
                    standalone = attValue;
                else
                    this.throwError('Invalid attribute name: ' + attName);
            }
        }
        this.throwError('Missing declaration end symbol `?>`');
    };
    /**
     * Produces a doc type token.
     */
    XMLStringLexer.prototype.doctype = function () {
        var pubId = '';
        var sysId = '';
        // name
        this.skipSpace();
        var name = this.takeUntil2('[', '>', true);
        this.skipSpace();
        if (this.skipIfStartsWith('PUBLIC')) {
            pubId = this.quotedString();
            sysId = this.quotedString();
        }
        else if (this.skipIfStartsWith('SYSTEM')) {
            sysId = this.quotedString();
        }
        // skip internal subset
        this.skipSpace();
        if (this.skipIfStartsWith('[')) {
            // skip internal subset nodes
            this.skipUntil(']');
            if (!this.skipIfStartsWith(']')) {
                this.throwError('Missing end bracket of DTD internal subset');
            }
        }
        this.skipSpace();
        if (!this.skipIfStartsWith('>')) {
            this.throwError('Missing doctype end symbol `>`');
        }
        return { type: interfaces_1.TokenType.DocType, name: name, pubId: pubId, sysId: sysId };
    };
    /**
     * Produces a processing instruction token.
     */
    XMLStringLexer.prototype.pi = function () {
        var target = this.takeUntilStartsWith('?>', true);
        if (this.eof()) {
            this.throwError('Missing processing instruction end symbol `?>`');
        }
        this.skipSpace();
        if (this.skipIfStartsWith('?>')) {
            return { type: interfaces_1.TokenType.PI, target: target, data: '' };
        }
        var data = this.takeUntilStartsWith('?>');
        if (this.eof()) {
            this.throwError('Missing processing instruction end symbol `?>`');
        }
        this.seek(2);
        return { type: interfaces_1.TokenType.PI, target: target, data: data };
    };
    /**
     * Produces a text token.
     *
     */
    XMLStringLexer.prototype.text = function () {
        var data = this.takeUntil('<');
        return { type: interfaces_1.TokenType.Text, data: data };
    };
    /**
     * Produces a comment token.
     *
     */
    XMLStringLexer.prototype.comment = function () {
        var data = this.takeUntilStartsWith('-->');
        if (this.eof()) {
            this.throwError('Missing comment end symbol `-->`');
        }
        this.seek(3);
        return { type: interfaces_1.TokenType.Comment, data: data };
    };
    /**
     * Produces a CDATA token.
     *
     */
    XMLStringLexer.prototype.cdata = function () {
        var data = this.takeUntilStartsWith(']]>');
        if (this.eof()) {
            this.throwError('Missing CDATA end symbol `]>`');
        }
        this.seek(3);
        return { type: interfaces_1.TokenType.CDATA, data: data };
    };
    /**
     * Produces an element token.
     */
    XMLStringLexer.prototype.openTag = function () {
        // element name
        this.skipSpace();
        var name = this.takeUntil2('>', '/', true);
        this.skipSpace();
        if (this.skipIfStartsWith('>')) {
            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: false };
        }
        else if (this.skipIfStartsWith('/>')) {
            return { type: interfaces_1.TokenType.Element, name: name, attributes: [], selfClosing: true };
        }
        // attributes
        var attributes = [];
        while (!this.eof()) {
            // end tag
            this.skipSpace();
            if (this.skipIfStartsWith('>')) {
                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: false };
            }
            else if (this.skipIfStartsWith('/>')) {
                return { type: interfaces_1.TokenType.Element, name: name, attributes: attributes, selfClosing: true };
            }
            var attr = this.attribute();
            attributes.push(attr);
        }
        this.throwError('Missing opening element tag end symbol `>`');
    };
    /**
     * Produces a closing tag token.
     *
     */
    XMLStringLexer.prototype.closeTag = function () {
        this.skipSpace();
        var name = this.takeUntil('>', true);
        this.skipSpace();
        if (!this.skipIfStartsWith('>')) {
            this.throwError('Missing closing element tag end symbol `>`');
        }
        return { type: interfaces_1.TokenType.ClosingTag, name: name };
    };
    /**
     * Reads an attribute name, value pair
     */
    XMLStringLexer.prototype.attribute = function () {
        // attribute name
        this.skipSpace();
        var name = this.takeUntil('=', true);
        this.skipSpace();
        if (!this.skipIfStartsWith('=')) {
            this.throwError('Missing equals sign before attribute value');
        }
        // attribute value
        var value = this.quotedString();
        return [name, value];
    };
    /**
     * Reads a string between double or single quotes.
     */
    XMLStringLexer.prototype.quotedString = function () {
        this.skipSpace();
        var startQuote = this.take(1);
        if (!XMLStringLexer.isQuote(startQuote)) {
            this.throwError('Missing start quote character before quoted value');
        }
        var value = this.takeUntil(startQuote);
        if (!this.skipIfStartsWith(startQuote)) {
            this.throwError('Missing end quote character after quoted value');
        }
        return value;
    };
    /**
     * Determines if the current index is at or past the end of input string.
     */
    XMLStringLexer.prototype.eof = function () { return this._index >= this._length; };
    /**
     * Skips the length of the given string if the string from current position
     * starts with the given string.
     *
     * @param str - the string to match
     */
    XMLStringLexer.prototype.skipIfStartsWith = function (str) {
        var strLength = str.length;
        if (strLength === 1) {
            if (this._str[this._index] === str) {
                this._index++;
                return true;
            }
            else {
                return false;
            }
        }
        for (var i = 0; i < strLength; i++) {
            if (this._str[this._index + i] !== str[i])
                return false;
        }
        this._index += strLength;
        return true;
    };
    /**
     * Seeks a number of character codes.
     *
     * @param count - number of characters to skip
     */
    XMLStringLexer.prototype.seek = function (count) {
        this._index += count;
        if (this._index < 0)
            this._index = 0;
        if (this._index > this._length)
            this._index = this._length;
    };
    /**
     * Skips space characters.
     */
    XMLStringLexer.prototype.skipSpace = function () {
        while (!this.eof() && (XMLStringLexer.isSpace(this._str[this._index]))) {
            this._index++;
        }
    };
    /**
     * Takes a given number of characters.
     *
     * @param count - character count
     */
    XMLStringLexer.prototype.take = function (count) {
        if (count === 1) {
            return this._str[this._index++];
        }
        var startIndex = this._index;
        this.seek(count);
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char`.
     *
     * @param char - a character to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntil = function (char, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            }
            else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char1` or `char1`.
     *
     * @param char1 - a character to match
     * @param char2 - a character to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntil2 = function (char1, char2, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char1 && c !== char2 && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            }
            else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next characters matches `str`.
     *
     * @param str - a string to match
     * @param space - whether a space character stops iteration
     */
    XMLStringLexer.prototype.takeUntilStartsWith = function (str, space) {
        if (space === void 0) { space = false; }
        var startIndex = this._index;
        var strLength = str.length;
        while (this._index < this._length) {
            var match = true;
            for (var i = 0; i < strLength; i++) {
                var c = this._str[this._index + i];
                var char = str[i];
                if (space && XMLStringLexer.isSpace(c)) {
                    return this._str.slice(startIndex, this._index);
                }
                else if (c !== char) {
                    this._index++;
                    match = false;
                    break;
                }
            }
            if (match)
                return this._str.slice(startIndex, this._index);
        }
        this._index = this._length;
        return this._str.slice(startIndex);
    };
    /**
     * Skips characters until the next character matches `char`.
     *
     * @param char - a character to match
     */
    XMLStringLexer.prototype.skipUntil = function (char) {
        while (this._index < this._length) {
            var c = this._str[this._index];
            if (c !== char) {
                this._index++;
            }
            else {
                break;
            }
        }
    };
    /**
     * Determines if the given token is entirely whitespace.
     *
     * @param token - the token to check
     */
    XMLStringLexer.isWhiteSpaceToken = function (token) {
        var str = token.data;
        for (var i = 0; i < str.length; i++) {
            var c = str[i];
            if (c !== ' ' && c !== '\n' && c !== '\r' && c !== '\t' && c !== '\f')
                return false;
        }
        return true;
    };
    /**
     * Determines if the given character is whitespace.
     *
     * @param char - the character to check
     */
    XMLStringLexer.isSpace = function (char) {
        return char === ' ' || char === '\n' || char === '\r' || char === '\t';
    };
    /**
     * Determines if the given character is a quote character.
     *
     * @param char - the character to check
     */
    XMLStringLexer.isQuote = function (char) {
        return (char === '"' || char === '\'');
    };
    /**
     * Throws a parser error and records the line and column numbers in the parsed
     * string.
     *
     * @param msg - error message
     */
    XMLStringLexer.prototype.throwError = function (msg) {
        var regexp = /\r\n|\r|\n/g;
        var match = null;
        var line = 0;
        var firstNewLineIndex = 0;
        var lastNewlineIndex = this._str.length;
        while ((match = regexp.exec(this._str)) !== null) {
            if (match === null)
                break;
            line++;
            if (match.index < this._index)
                firstNewLineIndex = regexp.lastIndex;
            if (match.index > this._index) {
                lastNewlineIndex = match.index;
                break;
            }
        }
        this.err = {
            line: line,
            col: this._index - firstNewLineIndex,
            index: this._index,
            str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
        };
        throw new Error(msg + "\nIndex: " + this.err.index +
            "\nLn: " + this.err.line + ", Col: " + this.err.col +
            "\nInput: " + this.err.str);
    };
    /**
     * Returns an iterator for the lexer.
     */
    XMLStringLexer.prototype[Symbol.iterator] = function () {
        this._index = 0;
        return {
            next: function () {
                var token = this.nextToken();
                if (token.type === interfaces_1.TokenType.EOF) {
                    return { done: true, value: null };
                }
                else {
                    return { done: false, value: token };
                }
            }.bind(this)
        };
    };
    return XMLStringLexer;
}());
exports.XMLStringLexer = XMLStringLexer;
//# sourceMappingURL=XMLStringLexer.js.map

/***/ }),

/***/ 6216:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Export classes
var DOMParserImpl_1 = __nccwpck_require__(8845);
exports.DOMParser = DOMParserImpl_1.DOMParserImpl;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7707:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines the type of a token.
 */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["EOF"] = 0] = "EOF";
    TokenType[TokenType["Declaration"] = 1] = "Declaration";
    TokenType[TokenType["DocType"] = 2] = "DocType";
    TokenType[TokenType["Element"] = 3] = "Element";
    TokenType[TokenType["Text"] = 4] = "Text";
    TokenType[TokenType["CDATA"] = 5] = "CDATA";
    TokenType[TokenType["PI"] = 6] = "PI";
    TokenType[TokenType["Comment"] = 7] = "Comment";
    TokenType[TokenType["ClosingTag"] = 8] = "ClosingTag";
})(TokenType = exports.TokenType || (exports.TokenType = {}));
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 9049:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a set of unique attribute namespaceURI and localName pairs.
 * This set will contain tuples of unique attribute namespaceURI and
 * localName pairs, and is populated as each attr is processed. This set is
 * used to [optionally] enforce the well-formed constraint that an element
 * cannot have two attributes with the same namespaceURI and localName.
 * This can occur when two otherwise identical attributes on the same
 * element differ only by their prefix values.
 */
var LocalNameSet = /** @class */ (function () {
    function LocalNameSet() {
        // tuple storage
        this._items = {};
        this._nullItems = {};
    }
    /**
     * Adds or replaces a tuple.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    LocalNameSet.prototype.set = function (ns, localName) {
        if (ns === null) {
            this._nullItems[localName] = true;
        }
        else if (this._items[ns]) {
            this._items[ns][localName] = true;
        }
        else {
            this._items[ns] = {};
            this._items[ns][localName] = true;
        }
    };
    /**
     * Determines if the given tuple exists in the set.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */
    LocalNameSet.prototype.has = function (ns, localName) {
        if (ns === null) {
            return this._nullItems[localName] === true;
        }
        else if (this._items[ns]) {
            return this._items[ns][localName] === true;
        }
        else {
            return false;
        }
    };
    return LocalNameSet;
}());
exports.LocalNameSet = LocalNameSet;
//# sourceMappingURL=LocalNameSet.js.map

/***/ }),

/***/ 283:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * A namespace prefix map is a map that associates namespaceURI and namespace
 * prefix lists, where namespaceURI values are the map's unique keys (which can
 * include the null value representing no namespace), and ordered lists of
 * associated prefix values are the map's key values. The namespace prefix map
 * will be populated by previously seen namespaceURIs and all their previously
 * encountered prefix associations for a given node and its ancestors.
 *
 * _Note:_ The last seen prefix for a given namespaceURI is at the end of its
 * respective list. The list is searched to find potentially matching prefixes,
 * and if no matches are found for the given namespaceURI, then the last prefix
 * in the list is used. See copy a namespace prefix map and retrieve a preferred
 * prefix string for additional details.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-namespace-prefix-map
 */
var NamespacePrefixMap = /** @class */ (function () {
    function NamespacePrefixMap() {
        this._items = {};
        this._nullItems = [];
    }
    /**
     * Creates a copy of the map.
     */
    NamespacePrefixMap.prototype.copy = function () {
        /**
         * To copy a namespace prefix map map means to copy the map's keys into a
         * new empty namespace prefix map, and to copy each of the values in the
         * namespace prefix list associated with each keys' value into a new list
         * which should be associated with the respective key in the new map.
         */
        var mapCopy = new NamespacePrefixMap();
        for (var key in this._items) {
            mapCopy._items[key] = this._items[key].slice(0);
        }
        mapCopy._nullItems = this._nullItems.slice(0);
        return mapCopy;
    };
    /**
     * Retrieves a preferred prefix string from the namespace prefix map.
     *
     * @param preferredPrefix - preferred prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.get = function (preferredPrefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is no
         * such key, then stop running these steps, and return the null value.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        if (candidatesList === null) {
            return null;
        }
        /**
         * 2. Otherwise, for each prefix value prefix in candidates list, iterating
         * from beginning to end:
         *
         * _Note:_ There will always be at least one prefix value in the list.
         */
        var prefix = null;
        for (var i = 0; i < candidatesList.length; i++) {
            prefix = candidatesList[i];
            /**
             * 2.1. If prefix matches preferred prefix, then stop running these steps
             * and return prefix.
             */
            if (prefix === preferredPrefix) {
                return prefix;
            }
        }
        /**
        * 2.2. If prefix is the last item in the candidates list, then stop
        * running these steps and return prefix.
        */
        return prefix;
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map associated
     * with the given namespace.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.has = function (prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then stop running these steps, and return false.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        if (candidatesList === null) {
            return false;
        }
        /**
         * 2. If the value of prefix occurs at least once in candidates list,
         * return true, otherwise return false.
         */
        return (candidatesList.indexOf(prefix) !== -1);
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map.
     *
     * @param prefix - prefix string
     */
    NamespacePrefixMap.prototype.hasPrefix = function (prefix) {
        if (this._nullItems.indexOf(prefix) !== -1)
            return true;
        for (var key in this._items) {
            if (this._items[key].indexOf(prefix) !== -1)
                return true;
        }
        return false;
    };
    /**
     * Adds a prefix string associated with a namespace to the prefix map.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */
    NamespacePrefixMap.prototype.set = function (prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then let candidates list be null.
         */
        var candidatesList = ns === null ? this._nullItems : (this._items[ns] || null);
        /**
         * 2. If candidates list is null, then create a new list with prefix as the
         * only item in the list, and associate that list with a new key ns in map.
         * 3. Otherwise, append prefix to the end of candidates list.
         *
         * _Note:_ The steps in retrieve a preferred prefix string use the list to
         * track the most recently used (MRU) prefix associated with a given
         * namespace, which will be the prefix at the end of the list. This list
         * may contain duplicates of the same prefix value seen earlier
         * (and that's OK).
         */
        if (ns !== null && candidatesList === null) {
            this._items[ns] = [prefix];
        }
        else {
            candidatesList.push(prefix);
        }
    };
    return NamespacePrefixMap;
}());
exports.NamespacePrefixMap = NamespacePrefixMap;
//# sourceMappingURL=NamespacePrefixMap.js.map

/***/ }),

/***/ 5039:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var LocalNameSet_1 = __nccwpck_require__(9049);
var NamespacePrefixMap_1 = __nccwpck_require__(283);
var DOMException_1 = __nccwpck_require__(3166);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Represents an XML serializer.
 *
 * Implements: https://www.w3.org/TR/DOM-Parsing/#serializing
 */
var XMLSerializerImpl = /** @class */ (function () {
    function XMLSerializerImpl() {
    }
    /** @inheritdoc */
    XMLSerializerImpl.prototype.serializeToString = function (root) {
        /**
         * The serializeToString(root) method must produce an XML serialization
         * of root passing a value of false for the require well-formed parameter,
         * and return the result.
         */
        return this._xmlSerialization(root, false);
    };
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._xmlSerialization = function (node, requireWellFormed) {
        // To increase performance, use a namespace-aware serializer only if the
        // document has namespaced elements
        if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */
            var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = { value: 1 };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */
            try {
                return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
            catch (_a) {
                throw new DOMException_1.InvalidStateError();
            }
        }
        else {
            try {
                return this._serializeNode(node, requireWellFormed);
            }
            catch (_b) {
                throw new DOMException_1.InvalidStateError();
            }
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeNode = function (node, requireWellFormed) {
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                return this._serializeElement(node, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocument(node, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragment(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_1, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var markup = "<";
        var qualifiedName = '';
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */
        if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */
            if (ns === infra_1.namespace.XML) {
                qualifiedName = 'xml:' + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */
            markup += qualifiedName;
        }
        else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */
            var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */
            if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */
                if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */
                candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */
            if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */
                markup += qualifiedName;
                /** 12.5. Otherwise, if prefix is not null, then: */
            }
            else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                markup += qualifiedName;
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */
                markup += " xmlns:" + prefix + "=\"" +
                    this._serializeAttributeValue(ns, requireWellFormed) + "\"";
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */
                markup += qualifiedName;
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */
                markup += " xmlns" + "=\"" +
                    this._serializeAttributeValue(ns, requireWellFormed) + "\"";
                /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                markup += qualifiedName;
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && node.childNodes.length === 0 &&
            XMLSerializerImpl._VoidElementNames.has(node.localName)) {
            markup += " /";
            skipEndTag = true;
        }
        else if (!isHTML && node.childNodes.length === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return markup;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */
        if (isHTML && node.localName === "template") {
            // TODO: serialize template contents
        }
        else {
            try {
                for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */
        markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */
        return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */
        var serializedDocument = "";
        try {
            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeComment = function (node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */
        return "<!--" + node.data + "-->";
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    XMLSerializerImpl.prototype._serializeText = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */
        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */
        var result = "";
        for (var i = 0; i < node.data.length; i++) {
            var c = node.data[i];
            if (c === "&")
                result += "&amp;";
            else if (c === "<")
                result += "&lt;";
            else if (c === ">")
                result += "&gt;";
            else
                result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_3, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */
        var markup = "";
        try {
            for (var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentType = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */
        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */
        if (requireWellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */
        return node.publicId && node.systemId ?
            "<!DOCTYPE " + node.name + " PUBLIC \"" + node.publicId + "\" \"" + node.systemId + "\">"
            : node.publicId ?
                "<!DOCTYPE " + node.name + " PUBLIC \"" + node.publicId + "\">"
                : node.systemId ?
                    "<!DOCTYPE " + node.name + " SYSTEM \"" + node.systemId + "\">"
                    :
                        "<!DOCTYPE " + node.name + ">";
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeProcessingInstruction = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */
        if (requireWellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */
        return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeCData = function (node, requireWellFormed) {
        if (requireWellFormed && (node.data.indexOf("]]>") !== -1)) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        return "<![CDATA[" + node.data + "]]>";
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    XMLSerializerImpl.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_4, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = "";
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
                    result += " " + attr.localName + "=\"" +
                        this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */
                        if (requireWellFormed && attr.value === '') {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */
                        result += " xmlns:" + candidatePrefix + "=\"" +
                            this._serializeAttributeValue(attributeNamespace, requireWellFormed) + "\"";
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                result += " ";
                if (candidatePrefix !== null) {
                    result += candidatePrefix + ':';
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result += attr.localName + "=\"" +
                    this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    XMLSerializerImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_5, _a;
        /**
         * 1. Let default namespace attr value be null.
         */
        var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */
                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */
                var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */
                var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                        /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */
                    }
                    else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */
                        var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */
                        var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */
                        map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */
        return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    XMLSerializerImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */
        var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */
        if (value === null)
            return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */
        var result = "";
        for (var i = 0; i < value.length; i++) {
            var c = value[i];
            if (c === "\"")
                result += "&quot;";
            else if (c === "&")
                result += "&amp;";
            else if (c === "<")
                result += "&lt;";
            else if (c === ">")
                result += "&gt;";
            else
                result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeElement = function (node, requireWellFormed) {
        var e_6, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */
        /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */
        var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */
        var markup = "<" + qualifiedName;
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        markup += this._serializeAttributes(node, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        if (node._children.size === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return markup;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */
        markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */
        return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocument = function (node, requireWellFormed) {
        var e_7, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */
        var serializedDocument = "";
        try {
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                serializedDocument += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeDocumentFragment = function (node, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */
        var markup = "";
        try {
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    XMLSerializerImpl.prototype._serializeAttributes = function (node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = "";
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result += " " + attr.localName + "=\"" +
                    this._serializeAttributeValue(attr.value, requireWellFormed) + "\"";
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    XMLSerializerImpl._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return XMLSerializerImpl;
}());
exports.XMLSerializerImpl = XMLSerializerImpl;
//# sourceMappingURL=XMLSerializerImpl.js.map

/***/ }),

/***/ 7119:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Export classes
var XMLSerializerImpl_1 = __nccwpck_require__(5039);
exports.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5483:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Guard_1 = __nccwpck_require__(6862);
/**
 * Contains type casts for DOM objects.
 */
var Cast = /** @class */ (function () {
    function Cast() {
    }
    /**
     * Casts the given object to a `Node`.
     *
     * @param a - the object to cast
     */
    Cast.asNode = function (a) {
        if (Guard_1.Guard.isNode(a)) {
            return a;
        }
        else {
            throw new Error("Invalid object. Node expected.");
        }
    };
    return Cast;
}());
exports.Cast = Cast;
//# sourceMappingURL=Cast.js.map

/***/ }),

/***/ 8392:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var EmptySet = /** @class */ (function () {
    function EmptySet() {
    }
    Object.defineProperty(EmptySet.prototype, "size", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    EmptySet.prototype.add = function (value) {
        throw new Error("Cannot add to an empty set.");
    };
    EmptySet.prototype.clear = function () {
        // no-op
    };
    EmptySet.prototype.delete = function (value) {
        return false;
    };
    EmptySet.prototype.forEach = function (callbackfn, thisArg) {
        // no-op
    };
    EmptySet.prototype.has = function (value) {
        return false;
    };
    EmptySet.prototype[Symbol.iterator] = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.entries = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.keys = function () {
        return new EmptySetIterator();
    };
    EmptySet.prototype.values = function () {
        return new EmptySetIterator();
    };
    Object.defineProperty(EmptySet.prototype, Symbol.toStringTag, {
        get: function () {
            return "EmptySet";
        },
        enumerable: true,
        configurable: true
    });
    return EmptySet;
}());
exports.EmptySet = EmptySet;
var EmptySetIterator = /** @class */ (function () {
    function EmptySetIterator() {
    }
    EmptySetIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    EmptySetIterator.prototype.next = function () {
        return { done: true, value: null };
    };
    return EmptySetIterator;
}());
//# sourceMappingURL=EmptySet.js.map

/***/ }),

/***/ 6862:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
/**
 * Contains user-defined type guards for DOM objects.
 */
var Guard = /** @class */ (function () {
    function Guard() {
    }
    /**
     * Determines if the given object is a `Node`.
     *
     * @param a - the object to check
     */
    Guard.isNode = function (a) {
        return (!!a && a._nodeType !== undefined);
    };
    /**
     * Determines if the given object is a `Document`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document);
    };
    /**
     * Determines if the given object is a `DocumentType`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentTypeNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType);
    };
    /**
     * Determines if the given object is a `DocumentFragment`.
     *
     * @param a - the object to check
     */
    Guard.isDocumentFragmentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment);
    };
    /**
     * Determines if the given object is a `Attr`.
     *
     * @param a - the object to check
     */
    Guard.isAttrNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute);
    };
    /**
     * Determines if the given node is a `CharacterData` node.
     *
     * @param a - the object to check
     */
    Guard.isCharacterDataNode = function (a) {
        if (!Guard.isNode(a))
            return false;
        var type = a._nodeType;
        return (type === interfaces_1.NodeType.Text ||
            type === interfaces_1.NodeType.ProcessingInstruction ||
            type === interfaces_1.NodeType.Comment ||
            type === interfaces_1.NodeType.CData);
    };
    /**
     * Determines if the given object is a `Text` or a `CDATASection`.
     *
     * @param a - the object to check
     */
    Guard.isTextNode = function (a) {
        return (Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData));
    };
    /**
     * Determines if the given object is a `Text`.
     *
     * @param a - the object to check
     */
    Guard.isExclusiveTextNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text);
    };
    /**
     * Determines if the given object is a `CDATASection`.
     *
     * @param a - the object to check
     */
    Guard.isCDATASectionNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData);
    };
    /**
     * Determines if the given object is a `Comment`.
     *
     * @param a - the object to check
     */
    Guard.isCommentNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment);
    };
    /**
     * Determines if the given object is a `ProcessingInstruction`.
     *
     * @param a - the object to check
     */
    Guard.isProcessingInstructionNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction);
    };
    /**
     * Determines if the given object is an `Element`.
     *
     * @param a - the object to check
     */
    Guard.isElementNode = function (a) {
        return (Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element);
    };
    /**
     * Determines if the given object is a custom `Element`.
     *
     * @param a - the object to check
     */
    Guard.isCustomElementNode = function (a) {
        return (Guard.isElementNode(a) && a._customElementState === "custom");
    };
    /**
     * Determines if the given object is a `ShadowRoot`.
     *
     * @param a - the object to check
     */
    Guard.isShadowRoot = function (a) {
        return (!!a && a.host !== undefined);
    };
    /**
     * Determines if the given object is a `MouseEvent`.
     *
     * @param a - the object to check
     */
    Guard.isMouseEvent = function (a) {
        return (!!a && a.screenX !== undefined && a.screenY != undefined);
    };
    /**
     * Determines if the given object is a slotable.
     *
     * Element and Text nodes are slotables. A slotable has an associated name
     * (a string).
     *
     * @param a - the object to check
     */
    Guard.isSlotable = function (a) {
        return (!!a && a._name !== undefined && a._assignedSlot !== undefined &&
            (Guard.isTextNode(a) || Guard.isElementNode(a)));
    };
    /**
     * Determines if the given object is a slot.
     *
     * @param a - the object to check
     */
    Guard.isSlot = function (a) {
        return (!!a && a._name !== undefined && a._assignedNodes !== undefined &&
            Guard.isElementNode(a));
    };
    /**
     * Determines if the given object is a `Window`.
     *
     * @param a - the object to check
     */
    Guard.isWindow = function (a) {
        return (!!a && a.navigator !== undefined);
    };
    /**
     * Determines if the given object is an `EventListener`.
     *
     * @param a - the object to check
     */
    Guard.isEventListener = function (a) {
        return (!!a && a.handleEvent !== undefined);
    };
    /**
     * Determines if the given object is a `RegisteredObserver`.
     *
     * @param a - the object to check
     */
    Guard.isRegisteredObserver = function (a) {
        return (!!a && a.observer !== undefined && a.options !== undefined);
    };
    /**
   * Determines if the given object is a `TransientRegisteredObserver`.
   *
   * @param a - the object to check
   */
    Guard.isTransientRegisteredObserver = function (a) {
        return (!!a && a.source !== undefined && Guard.isRegisteredObserver(a));
    };
    return Guard;
}());
exports.Guard = Guard;
//# sourceMappingURL=Guard.js.map

/***/ }),

/***/ 5282:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Cast_1 = __nccwpck_require__(5483);
exports.Cast = Cast_1.Cast;
var Guard_1 = __nccwpck_require__(6862);
exports.Guard = Guard_1.Guard;
var EmptySet_1 = __nccwpck_require__(8392);
exports.EmptySet = EmptySet_1.EmptySet;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8585:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CodePoints_1 = __nccwpck_require__(8548);
/**
 * Base-64 encodes the given string.
 *
 * @param input - a string
 */
function forgivingBase64Encode(input) {
    /**
     * To forgiving-base64 encode given a byte sequence data, apply the base64
     * algorithm defined in section 4 of RFC 4648 to data and return the result.
     * [RFC4648]
     */
    return Buffer.from(input).toString('base64');
}
exports.forgivingBase64Encode = forgivingBase64Encode;
/**
 * Decodes a base-64 string.
 *
 * @param input - a string
 */
function forgivingBase64Decode(input) {
    if (input === "")
        return "";
    /**
     * 1. Remove all ASCII whitespace from data.
     */
    input = input.replace(CodePoints_1.ASCIIWhiteSpace, '');
    /**
     * 2. If dataâ€™s length divides by 4 leaving no remainder, then:
     * 2.1. If data ends with one or two U+003D (=) code points, then remove them from data.
     */
    if (input.length % 4 === 0) {
        if (input.endsWith("==")) {
            input = input.substr(0, input.length - 2);
        }
        else if (input.endsWith("=")) {
            input = input.substr(0, input.length - 1);
        }
    }
    /**
     * 3. If dataâ€™s length divides by 4 leaving a remainder of 1, then return failure.
     */
    if (input.length % 4 === 1)
        return null;
    /**
     * 4. If data contains a code point that is not one of
     * - U+002B (+)
     * - U+002F (/)
     * - ASCII alphanumeric
     * then return failure.
     */
    if (!/[0-9A-Za-z+/]/.test(input))
        return null;
    /**
     * 5. Let output be an empty byte sequence.
     * 6. Let buffer be an empty buffer that can have bits appended to it.
     * 7. Let position be a position variable for data, initially pointing at the
     * start of data.
     * 8. While position does not point past the end of data:
     * 8.1. Find the code point pointed to by position in the second column of
     * Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in the
     * first cell of the same row. [RFC4648]
     * 8.2. Append the six bits corresponding to n, most significant bit first,
     * to buffer.
     * 8.3. If buffer has accumulated 24 bits, interpret them as three 8-bit
     * big-endian numbers. Append three bytes with values equal to those numbers
     * to output, in the same order, and then empty buffer.
     * 8.4. Advance position by 1.
     * 9. If buffer is not empty, it contains either 12 or 18 bits. If it contains
     * 12 bits, then discard the last four and interpret the remaining eight as an
     * 8-bit big-endian number. If it contains 18 bits, then discard the last two
     * and interpret the remaining 16 as two 8-bit big-endian numbers. Append the
     * one or two bytes with values equal to those one or two numbers to output,
     * in the same order.
     * 10. Return output.
     */
    return Buffer.from(input, 'base64').toString('utf8');
}
exports.forgivingBase64Decode = forgivingBase64Decode;
//# sourceMappingURL=Base64.js.map

/***/ }),

/***/ 2460:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Determines if the given number is an ASCII byte.
 *
 * @param byte - a byte
 */
function isASCIIByte(byte) {
    /**
     * An ASCII byte is a byte in the range 0x00 (NUL) to 0x7F (DEL), inclusive.
     */
    return byte >= 0x00 && byte <= 0x7F;
}
exports.isASCIIByte = isASCIIByte;
//# sourceMappingURL=Byte.js.map

/***/ }),

/***/ 1627:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Returns the count of bytes in a sequence.
 *
 * @param list - a byte sequence
 */
function length(list) {
    /**
     * A byte sequenceâ€™s length is the number of bytes it contains.
     */
    return list.length;
}
exports.length = length;
/**
 * Converts each byte to lowercase.
 *
 * @param list - a byte sequence
 */
function byteLowercase(list) {
    /**
     * To byte-lowercase a byte sequence, increase each byte it contains, in the
     * range 0x41 (A) to 0x5A (Z), inclusive, by 0x20.
     */
    for (var i = 0; i < list.length; i++) {
        var c = list[i];
        if (c >= 0x41 && c <= 0x5A) {
            list[i] = c + 0x20;
        }
    }
}
exports.byteLowercase = byteLowercase;
/**
 * Converts each byte to uppercase.
 *
 * @param list - a byte sequence
 */
function byteUppercase(list) {
    /**
     * To byte-uppercase a byte sequence, subtract each byte it contains, in the
     * range 0x61 (a) to 0x7A (z), inclusive, by 0x20.
     */
    for (var i = 0; i < list.length; i++) {
        var c = list[i];
        if (c >= 0x61 && c <= 0x7A) {
            list[i] = c - 0x20;
        }
    }
}
exports.byteUppercase = byteUppercase;
/**
 * Compares two byte sequences.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function byteCaseInsensitiveMatch(listA, listB) {
    /**
     * A byte sequence A is a byte-case-insensitive match for a byte sequence B,
     * if the byte-lowercase of A is the byte-lowercase of B.
     */
    if (listA.length !== listB.length)
        return false;
    for (var i = 0; i < listA.length; i++) {
        var a = listA[i];
        var b = listB[i];
        if (a >= 0x41 && a <= 0x5A)
            a += 0x20;
        if (b >= 0x41 && b <= 0x5A)
            b += 0x20;
        if (a !== b)
            return false;
    }
    return true;
}
exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
/**
 * Determines if `listA` starts with `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function startsWith(listA, listB) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aByte be the ith byte of a if i is less than aâ€™s length; otherwise null.
     * 2.3. Let bByte be the ith byte of b if i is less than bâ€™s length; otherwise null.
     * 2.4. If bByte is null, then return true.
     * 2.5. Return false if aByte is not bByte.
     * 2.6. Set i to i + 1.
     */
    var i = 0;
    while (true) {
        if (i >= listA.length)
            return false;
        if (i >= listB.length)
            return true;
        if (listA[i] !== listB[i])
            return false;
        i++;
    }
}
exports.startsWith = startsWith;
/**
 * Determines if `listA` is less than `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */
function byteLessThan(listA, listB) {
    /**
     * 1. If b starts with a, then return false.
     * 2. If a starts with b, then return true.
     * 3. Let n be the smallest index such that the nth byte of a is different
     * from the nth byte of b. (There has to be such an index, since neither byte
     * sequence starts with the other.)
     * 4. If the nth byte of a is less than the nth byte of b, then return true.
     * 5. Return false.
     */
    var i = 0;
    while (true) {
        if (i >= listA.length)
            return false;
        if (i >= listB.length)
            return true;
        var a = listA[i];
        var b = listB[i];
        if (a < b)
            return true;
        else if (a > b)
            return false;
        i++;
    }
}
exports.byteLessThan = byteLessThan;
/**
 * Decodes a byte sequence into a string.
 *
 * @param list - a byte sequence
 */
function isomorphicDecode(list) {
    /**
     * To isomorphic decode a byte sequence input, return a string whose length is
     * equal to inputâ€™s length and whose code points have the same values as
     * inputâ€™s bytes, in the same order.
     */
    return String.fromCodePoint.apply(String, __spread(list));
}
exports.isomorphicDecode = isomorphicDecode;
//# sourceMappingURL=ByteSequence.js.map

/***/ }),

/***/ 8548:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * A surrogate is a code point that is in the range U+D800 to U+DFFF, inclusive.
 */
exports.Surrogate = /[\uD800-\uDFFF]/;
/**
 * A scalar value is a code point that is not a surrogate.
 */
exports.ScalarValue = /[\uD800-\uDFFF]/;
/**
 * A noncharacter is a code point that is in the range U+FDD0 to U+FDEF,
 * inclusive, or U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
 * U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE,
 * U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE,
 * U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE,
 * U+FFFFF, U+10FFFE, or U+10FFFF.
 */
exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
/**
 * An ASCII code point is a code point in the range U+0000 NULL to U+007F
 * DELETE, inclusive.
 */
exports.ASCIICodePoint = /[\u0000-\u007F]/;
/**
 * An ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.
 */
exports.ASCIITabOrNewLine = /[\t\n\r]/;
/**
 * ASCII whitespace is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or
 * U+0020 SPACE.
 */
exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
/**
 * A C0 control is a code point in the range U+0000 NULL to U+001F
 * INFORMATION SEPARATOR ONE, inclusive.
 */
exports.C0Control = /[\u0000-\u001F]/;
/**
 * A C0 control or space is a C0 control or U+0020 SPACE.
 */
exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
/**
 * A control is a C0 control or a code point in the range U+007F DELETE to
 * U+009F APPLICATION PROGRAM COMMAND, inclusive.
 */
exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
/**
 * An ASCII digit is a code point in the range U+0030 (0) to U+0039 (9),
 * inclusive.
 */
exports.ASCIIDigit = /[0-9]/;
/**
 * An ASCII upper hex digit is an ASCII digit or a code point in the range
 * U+0041 (A) to U+0046 (F), inclusive.
 */
exports.ASCIIUpperHexDigit = /[0-9A-F]/;
/**
 * An ASCII lower hex digit is an ASCII digit or a code point in the range
 * U+0061 (a) to U+0066 (f), inclusive.
 */
exports.ASCIILowerHexDigit = /[0-9a-f]/;
/**
 * An ASCII hex digit is an ASCII upper hex digit or ASCII lower hex digit.
 */
exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
/**
 * An ASCII upper alpha is a code point in the range U+0041 (A) to U+005A (Z),
 * inclusive.
 */
exports.ASCIIUpperAlpha = /[A-Z]/;
/**
 * An ASCII lower alpha is a code point in the range U+0061 (a) to U+007A (z),
 * inclusive.
 */
exports.ASCIILowerAlpha = /[a-z]/;
/**
 * An ASCII alpha is an ASCII upper alpha or ASCII lower alpha.
 */
exports.ASCIIAlpha = /[A-Za-z]/;
/**
 * An ASCII alphanumeric is an ASCII digit or ASCII alpha.
 */
exports.ASCIIAlphanumeric = /[0-9A-Za-z]/;
//# sourceMappingURL=CodePoints.js.map

/***/ }),

/***/ 9387:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
/**
 * Parses the given byte sequence representing a JSON string into an object.
 *
 * @param bytes - a byte sequence
 */
function parseJSONFromBytes(bytes) {
    /**
     * 1. Let jsonText be the result of running UTF-8 decode on bytes. [ENCODING]
     * 2. Return ? Call(%JSONParse%, undefined, Â« jsonText Â»).
     */
    var jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(undefined, jsonText);
}
exports.parseJSONFromBytes = parseJSONFromBytes;
/**
 * Serialize the given JavaScript value into a byte sequence.
 *
 * @param value - a JavaScript value
 */
function serializeJSONToBytes(value) {
    /**
     * 1. Let jsonString be ? Call(%JSONStringify%, undefined, Â« value Â»).
     * 2. Return the result of running UTF-8 encode on jsonString. [ENCODING]
     */
    var jsonString = JSON.stringify.call(undefined, value);
    return util_1.utf8Encode(jsonString);
}
exports.serializeJSONToBytes = serializeJSONToBytes;
/**
 * Parses the given JSON string into a Realm-independent JavaScript value.
 *
 * @param jsonText - a JSON string
 */
function parseJSONIntoInfraValues(jsonText) {
    /**
     * 1. Let jsValue be ? Call(%JSONParse%, undefined, Â« jsonText Â»).
     * 2. Return the result of converting a JSON-derived JavaScript value to an
     * Infra value, given jsValue.
     */
    var jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
}
exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
/**
 * Parses the value into a Realm-independent JavaScript value.
 *
 * @param jsValue - a JavaScript value
 */
function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    var e_1, _a;
    /**
     * 1. If Type(jsValue) is Null, String, or Number, then return jsValue.
     */
    if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue))
        return jsValue;
    /**
     * 2. If IsArray(jsValue) is true, then:
     * 2.1. Let result be an empty list.
     * 2.2. Let length be ! ToLength(! Get(jsValue, "length")).
     * 2.3. For each index of the range 0 to length âˆ’ 1, inclusive:
     * 2.3.1. Let indexName be ! ToString(index).
     * 2.3.2. Let jsValueAtIndex be ! Get(jsValue, indexName).
     * 2.3.3. Let infraValueAtIndex be the result of converting a JSON-derived
     * JavaScript value to an Infra value, given jsValueAtIndex.
     * 2.3.4. Append infraValueAtIndex to result.
     * 2.8. Return result.
     */
    if (util_1.isArray(jsValue)) {
        var result = new Array();
        try {
            for (var jsValue_1 = __values(jsValue), jsValue_1_1 = jsValue_1.next(); !jsValue_1_1.done; jsValue_1_1 = jsValue_1.next()) {
                var jsValueAtIndex = jsValue_1_1.value;
                result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (jsValue_1_1 && !jsValue_1_1.done && (_a = jsValue_1.return)) _a.call(jsValue_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    else if (util_1.isObject(jsValue)) {
        /**
         * 3. Let result be an empty ordered map.
         * 4. For each key of ! jsValue.[[OwnPropertyKeys]]():
         * 4.1. Let jsValueAtKey be ! Get(jsValue, key).
         * 4.2. Let infraValueAtKey be the result of converting a JSON-derived
         * JavaScript value to an Infra value, given jsValueAtKey.
         * 4.3. Set result[key] to infraValueAtKey.
         * 5. Return result.
         */
        var result = new Map();
        for (var key in jsValue) {
            /* istanbul ignore else */
            if (jsValue.hasOwnProperty(key)) {
                var jsValueAtKey = jsValue[key];
                result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
            }
        }
        return result;
    }
    /* istanbul ignore next */
    return jsValue;
}
exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue;
//# sourceMappingURL=JSON.js.map

/***/ }),

/***/ 340:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
/**
 * Adds the given item to the end of the list.
 *
 * @param list - a list
 * @param item - an item
 */
function append(list, item) {
    list.push(item);
}
exports.append = append;
/**
 * Extends a list by appending all items from another list.
 *
 * @param listA - a list to extend
 * @param listB - a list containing items to append to `listA`
 */
function extend(listA, listB) {
    listA.push.apply(listA, __spread(listB));
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the list.
 *
 * @param list - a list
 * @param item - an item
 */
function prepend(list, item) {
    list.unshift(item);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param list - a list
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */
function replace(list, conditionOrItem, newItem) {
    var e_1, _a;
    var i = 0;
    try {
        for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
            var oldItem = list_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    list[i] = newItem;
                }
            }
            else if (oldItem === conditionOrItem) {
                list[i] = newItem;
                return;
            }
            i++;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param list - a list
 * @param item - an item
 */
function insert(list, item, index) {
    list.splice(index, 0, item);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */
function remove(list, conditionOrItem) {
    var i = list.length;
    while (i--) {
        var oldItem = list[i];
        if (util_1.isFunction(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
                list.splice(i, 1);
            }
        }
        else if (oldItem === conditionOrItem) {
            list.splice(i, 1);
            return;
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the list.
 */
function empty(list) {
    list.length = 0;
}
exports.empty = empty;
/**
 * Determines if the list contains the given item or any items matching
 * condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to a condition to match
 */
function contains(list, conditionOrItem) {
    var e_2, _a;
    try {
        for (var list_2 = __values(list), list_2_1 = list_2.next(); !list_2_1.done; list_2_1 = list_2.next()) {
            var oldItem = list_2_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            }
            else if (oldItem === conditionOrItem) {
                return true;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (list_2_1 && !list_2_1.done && (_a = list_2.return)) _a.call(list_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the list matching the given condition.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */
function size(list, condition) {
    var e_3, _a;
    if (condition === undefined) {
        return list.length;
    }
    else {
        var count = 0;
        try {
            for (var list_3 = __values(list), list_3_1 = list_3.next(); !list_3_1.done; list_3_1 = list_3.next()) {
                var item = list_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (list_3_1 && !list_3_1.done && (_a = list_3.return)) _a.call(list_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the list is empty.
 *
 * @param list - a list
 */
function isEmpty(list) {
    return list.length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the list.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */
function forEach(list, condition) {
    var list_4, list_4_1, item, e_4_1;
    var e_4, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(list)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                list_4 = __values(list), list_4_1 = list_4.next();
                _b.label = 3;
            case 3:
                if (!!list_4_1.done) return [3 /*break*/, 6];
                item = list_4_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                list_4_1 = list_4.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_4_1 = _b.sent();
                e_4 = { error: e_4_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (list_4_1 && !list_4_1.done && (_a = list_4.return)) _a.call(list_4);
                }
                finally { if (e_4) throw e_4.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of list.
 *
 * @param list - a list
 */
function clone(list) {
    return new (Array.bind.apply(Array, __spread([void 0], list)))();
}
exports.clone = clone;
/**
 * Returns a new list containing items from the list sorted in ascending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new list containing items from the list sorted in descending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
}
exports.sortInDescendingOrder = sortInDescendingOrder;
//# sourceMappingURL=List.js.map

/***/ }),

/***/ 2298:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
/**
 * Gets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 */
function get(map, key) {
    return map.get(key);
}
exports.get = get;
/**
 * Sets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 * @param val - a value
 */
function set(map, key, val) {
    map.set(key, val);
}
exports.set = set;
/**
 * Removes the item with the given key or all items matching condition.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to remove or a condition matching
 * items to remove
 */
function remove(map, conditionOrItem) {
    var e_1, _a, e_2, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        map.delete(conditionOrItem);
    }
    else {
        var toRemove = [];
        try {
            for (var map_1 = __values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()) {
                var item = map_1_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item[0]);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
                var key = toRemove_1_1.value;
                map.delete(key);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
exports.remove = remove;
/**
 * Determines if the map contains a value with the given key.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to match or a condition matching
 * items
 */
function contains(map, conditionOrItem) {
    var e_3, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return map.has(conditionOrItem);
    }
    else {
        try {
            for (var map_2 = __values(map), map_2_1 = map_2.next(); !map_2_1.done; map_2_1 = map_2.next()) {
                var item = map_2_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    return true;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (map_2_1 && !map_2_1.done && (_a = map_2.return)) _a.call(map_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return false;
    }
}
exports.contains = contains;
/**
 * Gets the keys of the map.
 *
 * @param map - a map
 */
function keys(map) {
    return new Set(map.keys());
}
exports.keys = keys;
/**
 * Gets the values of the map.
 *
 * @param map - a map
 */
function values(map) {
    return __spread(map.values());
}
exports.values = values;
/**
 * Gets the size of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */
function size(map, condition) {
    var e_4, _a;
    if (condition === undefined) {
        return map.size;
    }
    else {
        var count = 0;
        try {
            for (var map_3 = __values(map), map_3_1 = map_3.next(); !map_3_1.done; map_3_1 = map_3.next()) {
                var item = map_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (map_3_1 && !map_3_1.done && (_a = map_3.return)) _a.call(map_3);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the map is empty.
 *
 * @param map - a map
 */
function isEmpty(map) {
    return map.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */
function forEach(map, condition) {
    var map_4, map_4_1, item, e_5_1;
    var e_5, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(map)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                map_4 = __values(map), map_4_1 = map_4.next();
                _b.label = 3;
            case 3:
                if (!!map_4_1.done) return [3 /*break*/, 6];
                item = map_4_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                map_4_1 = map_4.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_5_1 = _b.sent();
                e_5 = { error: e_5_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (map_4_1 && !map_4_1.done && (_a = map_4.return)) _a.call(map_4);
                }
                finally { if (e_5) throw e_5.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of map.
 *
 * @param map - a map
 */
function clone(map) {
    return new Map(map);
}
exports.clone = clone;
/**
 * Returns a new map containing items from the map sorted in ascending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Map(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new map containing items from the map sorted in descending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], map)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Map(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder;
//# sourceMappingURL=Map.js.map

/***/ }),

/***/ 3764:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTML = "http://www.w3.org/1999/xhtml";
exports.XML = "http://www.w3.org/XML/1998/namespace";
exports.XMLNS = "http://www.w3.org/2000/xmlns/";
exports.MathML = "http://www.w3.org/1998/Math/MathML";
exports.SVG = "http://www.w3.org/2000/svg";
exports.XLink = "http://www.w3.org/1999/xlink";
//# sourceMappingURL=Namespace.js.map

/***/ }),

/***/ 9201:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Appends the given item to the queue.
 *
 * @param list - a list
 * @param item - an item
 */
function enqueue(list, item) {
    list.push(item);
}
exports.enqueue = enqueue;
/**
 * Removes and returns an item from the queue.
 *
 * @param list - a list
 */
function dequeue(list) {
    return list.shift() || null;
}
exports.dequeue = dequeue;
//# sourceMappingURL=Queue.js.map

/***/ }),

/***/ 5931:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
/**
 * Adds the given item to the end of the set.
 *
 * @param set - a set
 * @param item - an item
 */
function append(set, item) {
    set.add(item);
}
exports.append = append;
/**
 * Extends a set by appending all items from another set.
 *
 * @param setA - a list to extend
 * @param setB - a list containing items to append to `setA`
 */
function extend(setA, setB) {
    setB.forEach(setA.add, setA);
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the set.
 *
 * @param set - a set
 * @param item - an item
 */
function prepend(set, item) {
    var cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param set - a set
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */
function replace(set, conditionOrItem, newItem) {
    var e_1, _a;
    var newSet = new Set();
    try {
        for (var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()) {
            var oldItem = set_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    newSet.add(newItem);
                }
                else {
                    newSet.add(oldItem);
                }
            }
            else if (oldItem === conditionOrItem) {
                newSet.add(newItem);
            }
            else {
                newSet.add(oldItem);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param set - a set
 * @param item - an item
 */
function insert(set, item, index) {
    var e_2, _a;
    var newSet = new Set();
    var i = 0;
    try {
        for (var set_2 = __values(set), set_2_1 = set_2.next(); !set_2_1.done; set_2_1 = set_2.next()) {
            var oldItem = set_2_1.value;
            if (i === index)
                newSet.add(item);
            newSet.add(oldItem);
            i++;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (set_2_1 && !set_2_1.done && (_a = set_2.return)) _a.call(set_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */
function remove(set, conditionOrItem) {
    var e_3, _a, e_4, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        set.delete(conditionOrItem);
    }
    else {
        var toRemove = [];
        try {
            for (var set_3 = __values(set), set_3_1 = set_3.next(); !set_3_1.done; set_3_1 = set_3.next()) {
                var item = set_3_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (set_3_1 && !set_3_1.done && (_a = set_3.return)) _a.call(set_3);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()) {
                var oldItem = toRemove_1_1.value;
                set.delete(oldItem);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the set.
 */
function empty(set) {
    set.clear();
}
exports.empty = empty;
/**
 * Determines if the set contains the given item or any items matching
 * condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to a condition to match
 */
function contains(set, conditionOrItem) {
    var e_5, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return set.has(conditionOrItem);
    }
    else {
        try {
            for (var set_4 = __values(set), set_4_1 = set_4.next(); !set_4_1.done; set_4_1 = set_4.next()) {
                var oldItem = set_4_1.value;
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (set_4_1 && !set_4_1.done && (_a = set_4.return)) _a.call(set_4);
            }
            finally { if (e_5) throw e_5.error; }
        }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the set matching the given condition.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */
function size(set, condition) {
    var e_6, _a;
    if (condition === undefined) {
        return set.size;
    }
    else {
        var count = 0;
        try {
            for (var set_5 = __values(set), set_5_1 = set_5.next(); !set_5_1.done; set_5_1 = set_5.next()) {
                var item = set_5_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (set_5_1 && !set_5_1.done && (_a = set_5.return)) _a.call(set_5);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the set is empty.
 *
 * @param set - a set
 */
function isEmpty(set) {
    return set.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the set.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */
function forEach(set, condition) {
    var set_6, set_6_1, item, e_7_1;
    var e_7, _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!(condition === undefined)) return [3 /*break*/, 2];
                return [5 /*yield**/, __values(set)];
            case 1:
                _b.sent();
                return [3 /*break*/, 9];
            case 2:
                _b.trys.push([2, 7, 8, 9]);
                set_6 = __values(set), set_6_1 = set_6.next();
                _b.label = 3;
            case 3:
                if (!!set_6_1.done) return [3 /*break*/, 6];
                item = set_6_1.value;
                if (!!!condition.call(null, item)) return [3 /*break*/, 5];
                return [4 /*yield*/, item];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                set_6_1 = set_6.next();
                return [3 /*break*/, 3];
            case 6: return [3 /*break*/, 9];
            case 7:
                e_7_1 = _b.sent();
                e_7 = { error: e_7_1 };
                return [3 /*break*/, 9];
            case 8:
                try {
                    if (set_6_1 && !set_6_1.done && (_a = set_6.return)) _a.call(set_6);
                }
                finally { if (e_7) throw e_7.error; }
                return [7 /*endfinally*/];
            case 9: return [2 /*return*/];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of set.
 *
 * @param set - a set
 */
function clone(set) {
    return new Set(set);
}
exports.clone = clone;
/**
 * Returns a new set containing items from the set sorted in ascending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInAscendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Set(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new set containing items from the set sorted in descending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */
function sortInDescendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([void 0], set)))();
    list.sort(function (itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Set(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder;
/**
 * Determines if a set is a subset of another set.
 *
 * @param subset - a set
 * @param superset - a superset possibly containing all items from `subset`.
 */
function isSubsetOf(subset, superset) {
    var e_8, _a;
    try {
        for (var subset_1 = __values(subset), subset_1_1 = subset_1.next(); !subset_1_1.done; subset_1_1 = subset_1.next()) {
            var item = subset_1_1.value;
            if (!superset.has(item))
                return false;
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return)) _a.call(subset_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return true;
}
exports.isSubsetOf = isSubsetOf;
/**
 * Determines if a set is a superset of another set.
 *
 * @param superset - a set
 * @param subset - a subset possibly contained within `superset`.
 */
function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
}
exports.isSupersetOf = isSupersetOf;
/**
 * Returns a new set with items that are contained in both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */
function intersection(setA, setB) {
    var e_9, _a;
    var newSet = new Set();
    try {
        for (var setA_1 = __values(setA), setA_1_1 = setA_1.next(); !setA_1_1.done; setA_1_1 = setA_1.next()) {
            var item = setA_1_1.value;
            if (setB.has(item))
                newSet.add(item);
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (setA_1_1 && !setA_1_1.done && (_a = setA_1.return)) _a.call(setA_1);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return newSet;
}
exports.intersection = intersection;
/**
 * Returns a new set with items from both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */
function union(setA, setB) {
    var newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
}
exports.union = union;
/**
 * Returns a set of integers from `n` to `m` inclusive.
 *
 * @param n - starting number
 * @param m - ending number
 */
function range(n, m) {
    var newSet = new Set();
    for (var i = n; i <= m; i++) {
        newSet.add(i);
    }
    return newSet;
}
exports.range = range;
//# sourceMappingURL=Set.js.map

/***/ }),

/***/ 8784:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Pushes the given item to the stack.
 *
 * @param list - a list
 * @param item - an item
 */
function push(list, item) {
    list.push(item);
}
exports.push = push;
/**
 * Pops and returns an item from the stack.
 *
 * @param list - a list
 */
function pop(list) {
    return list.pop() || null;
}
exports.pop = pop;
//# sourceMappingURL=Stack.js.map

/***/ }),

/***/ 3203:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var CodePoints_1 = __nccwpck_require__(8548);
var ByteSequence_1 = __nccwpck_require__(1627);
var Byte_1 = __nccwpck_require__(2460);
var util_1 = __nccwpck_require__(6195);
/**
 * Determines if the string `a` is a code unit prefix of string `b`.
 *
 * @param a - a string
 * @param b - a string
 */
function isCodeUnitPrefix(a, b) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aCodeUnit be the ith code unit of a if i is less than aâ€™s length;
     * otherwise null.
     * 2.2. Let bCodeUnit be the ith code unit of b if i is less than bâ€™s length;
     * otherwise null.
     * 2.3. If bCodeUnit is null, then return true.
     * 2.4. Return false if aCodeUnit is different from bCodeUnit.
     * 2.5. Set i to i + 1.
     */
    var i = 0;
    while (true) {
        var aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
        var bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
        if (aCodeUnit === null)
            return true;
        if (aCodeUnit !== bCodeUnit)
            return false;
        i++;
    }
}
exports.isCodeUnitPrefix = isCodeUnitPrefix;
/**
 * Determines if the string `a` is a code unit less than string `b`.
 *
 * @param a - a string
 * @param b - a string
 */
function isCodeUnitLessThan(a, b) {
    /**
     * 1. If b is a code unit prefix of a, then return false.
     * 2. If a is a code unit prefix of b, then return true.
     * 3. Let n be the smallest index such that the nth code unit of a is
     * different from the nth code unit of b. (There has to be such an index,
     * since neither string is a prefix of the other.)
     * 4. If the nth code unit of a is less than the nth code unit of b, then
     * return true.
     * 5. Return false.
     */
    if (isCodeUnitPrefix(b, a))
        return false;
    if (isCodeUnitPrefix(a, b))
        return true;
    for (var i = 0; i < Math.min(a.length, b.length); i++) {
        var aCodeUnit = a.charCodeAt(i);
        var bCodeUnit = b.charCodeAt(i);
        if (aCodeUnit === bCodeUnit)
            continue;
        return (aCodeUnit < bCodeUnit);
    }
    /* istanbul ignore next */
    return false;
}
exports.isCodeUnitLessThan = isCodeUnitLessThan;
/**
 * Isomorphic encodes the given string.
 *
 * @param str - a string
 */
function isomorphicEncode(str) {
    var e_1, _a;
    /**
     * 1. Assert: input contains no code points greater than U+00FF.
     * 2. Return a byte sequence whose length is equal to inputâ€™s length and whose
     * bytes have the same values as inputâ€™s code points, in the same order.
     */
    var codePoints = Array.from(str);
    var bytes = new Uint8Array(codePoints.length);
    var i = 0;
    try {
        for (var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()) {
            var codePoint = str_1_1.value;
            var byte = codePoint.codePointAt(0);
            console.assert(byte !== undefined && byte <= 0x00FF, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
            if (byte !== undefined && byte <= 0x00FF) {
                bytes[i++] = byte;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return bytes;
}
exports.isomorphicEncode = isomorphicEncode;
/**
 * Determines if the given string is An ASCII string.
 *
 * @param str - a string
 */
function isASCIIString(str) {
    /**
     * An ASCII string is a string whose code points are all ASCII code points.
     */
    return /^[\u0000-\u007F]*$/.test(str);
}
exports.isASCIIString = isASCIIString;
/**
 * Converts all uppercase ASCII code points to lowercase.
 *
 * @param str - a string
 */
function asciiLowercase(str) {
    var e_2, _a;
    /**
     * To ASCII lowercase a string, replace all ASCII upper alphas in the string
     * with their corresponding code point in ASCII lower alpha.
     */
    var result = "";
    try {
        for (var str_2 = __values(str), str_2_1 = str_2.next(); !str_2_1.done; str_2_1 = str_2.next()) {
            var c = str_2_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x41 && code <= 0x5A) {
                result += String.fromCodePoint(code + 0x20);
            }
            else {
                result += c;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (str_2_1 && !str_2_1.done && (_a = str_2.return)) _a.call(str_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return result;
}
exports.asciiLowercase = asciiLowercase;
/**
 * Converts all uppercase ASCII code points to uppercase.
 *
 * @param str - a string
 */
function asciiUppercase(str) {
    var e_3, _a;
    /**
     * To ASCII uppercase a string, replace all ASCII lower alphas in the string
     * with their corresponding code point in ASCII upper alpha.
     */
    var result = "";
    try {
        for (var str_3 = __values(str), str_3_1 = str_3.next(); !str_3_1.done; str_3_1 = str_3.next()) {
            var c = str_3_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x61 && code <= 0x7A) {
                result += String.fromCodePoint(code - 0x20);
            }
            else {
                result += c;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (str_3_1 && !str_3_1.done && (_a = str_3.return)) _a.call(str_3);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return result;
}
exports.asciiUppercase = asciiUppercase;
/**
 * Compares two ASCII strings case-insensitively.
 *
 * @param a - a string
 * @param b - a string
 */
function asciiCaseInsensitiveMatch(a, b) {
    /**
     * A string A is an ASCII case-insensitive match for a string B, if the ASCII
     * lowercase of A is the ASCII lowercase of B.
     */
    return asciiLowercase(a) === asciiLowercase(b);
}
exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
/**
 * ASCII encodes a string.
 *
 * @param str - a string
 */
function asciiEncode(str) {
    /**
     * 1. Assert: input is an ASCII string.
     * 2. Return the isomorphic encoding of input.
     */
    console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
}
exports.asciiEncode = asciiEncode;
/**
 * ASCII decodes a byte sequence.
 *
 * @param bytes - a byte sequence
 */
function asciiDecode(bytes) {
    var e_4, _a;
    try {
        /**
         * 1. Assert: All bytes in input are ASCII bytes.
         * 2. Return the isomorphic decoding of input.
         */
        for (var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
            var byte = bytes_1_1.value;
            console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return ByteSequence_1.isomorphicDecode(bytes);
}
exports.asciiDecode = asciiDecode;
/**
 * Strips newline characters from a string.
 *
 * @param str - a string
 */
function stripNewlines(str) {
    /**
     * To strip newlines from a string, remove any U+000A LF and U+000D CR code
     * points from the string.
     */
    return str.replace(/[\n\r]/g, "");
}
exports.stripNewlines = stripNewlines;
/**
 * Normalizes newline characters in a string by converting consecutive
 * carriage-return newline characters and also single carriage return characters
 * into a single newline.
 *
 * @param str - a string
 */
function normalizeNewlines(str) {
    /**
     * To normalize newlines in a string, replace every U+000D CR U+000A LF code
     * point pair with a single U+000A LF code point, and then replace every
     * remaining U+000D CR code point with a U+000A LF code point.
     */
    return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
exports.normalizeNewlines = normalizeNewlines;
/**
 * Removes leading and trailing whitespace characters from a string.
 *
 * @param str - a string
 */
function stripLeadingAndTrailingASCIIWhitespace(str) {
    /**
     * To strip leading and trailing ASCII whitespace from a string, remove all
     * ASCII whitespace that are at the start or the end of the string.
     */
    return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
}
exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
/**
 * Removes consecutive newline characters from a string.
 *
 * @param str - a string
 */
function stripAndCollapseASCIIWhitespace(str) {
    /**
     * To strip and collapse ASCII whitespace in a string, replace any sequence of
     * one or more consecutive code points that are ASCII whitespace in the string
     * with a single U+0020 SPACE code point, and then remove any leading and
     * trailing ASCII whitespace from that string.
     */
    return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
}
exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
/**
 * Collects a sequence of code points matching a given condition from the input
 * string.
 *
 * @param condition - a condition to match
 * @param input - a string
 * @param options - starting position
 */
function collectASequenceOfCodePoints(condition, input, options) {
    /**
     * 1. Let result be the empty string.
     * 2. While position doesnâ€™t point past the end of input and the code point at
     * position within input meets the condition condition:
     * 2.1. Append that code point to the end of result.
     * 2.2. Advance position by 1.
     * 3. Return result.
     */
    if (!util_1.isArray(input))
        return collectASequenceOfCodePoints(condition, Array.from(input), options);
    var result = "";
    while (options.position < input.length && !!condition.call(null, input[options.position])) {
        result += input[options.position];
        options.position++;
    }
    return result;
}
exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
/**
 * Skips over ASCII whitespace.
 *
 * @param input - input string
 * @param options - starting position
 */
function skipASCIIWhitespace(input, options) {
    /**
     * To skip ASCII whitespace within a string input given a position variable
     * position, collect a sequence of code points that are ASCII whitespace from
     * input given position. The collected code points are not used, but position
     * is still updated.
     */
    collectASequenceOfCodePoints(function (str) { return CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);
}
exports.skipASCIIWhitespace = skipASCIIWhitespace;
/**
 * Solits a string at the given delimiter.
 *
 * @param input - input string
 * @param delimiter - a delimiter string
 */
function strictlySplit(input, delimiter) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Let token be the result of collecting a sequence of code points that are
     * not equal to delimiter from input, given position.
     * 4. Append token to tokens.
     * 5. While position is not past the end of input:
     * 5.1. Assert: the code point at position within input is delimiter.
     * 5.2. Advance position by 1.
     * 5.3. Let token be the result of collecting a sequence of code points that
     * are not equal to delimiter from input, given position.
     * 5.4. Append token to tokens.
     * 6. Return tokens.
     */
    if (!util_1.isArray(input))
        return strictlySplit(Array.from(input), delimiter);
    var options = { position: 0 };
    var tokens = [];
    var token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);
    tokens.push(token);
    while (options.position < input.length) {
        console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
        options.position++;
        token = collectASequenceOfCodePoints(function (str) { return delimiter !== str; }, input, options);
        tokens.push(token);
    }
    return tokens;
}
exports.strictlySplit = strictlySplit;
/**
 * Splits a string on ASCII whitespace.
 *
 * @param input - a string
 */
function splitAStringOnASCIIWhitespace(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Skip ASCII whitespace within input given position.
     * 4. While position is not past the end of input:
     * 4.1. Let token be the result of collecting a sequence of code points that
     * are not ASCII whitespace from input, given position.
     * 4.2. Append token to tokens.
     * 4.3. Skip ASCII whitespace within input given position.
     * 5. Return tokens.
     */
    if (!util_1.isArray(input))
        return splitAStringOnASCIIWhitespace(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    skipASCIIWhitespace(input, options);
    while (options.position < input.length) {
        var token = collectASequenceOfCodePoints(function (str) { return !CodePoints_1.ASCIIWhiteSpace.test(str); }, input, options);
        tokens.push(token);
        skipASCIIWhitespace(input, options);
    }
    return tokens;
}
exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
/**
 * Splits a string on commas.
 *
 * @param input - a string
 */
function splitAStringOnCommas(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. While position is not past the end of input:
     * 3.1. Let token be the result of collecting a sequence of code points that
     * are not U+002C (,) from input, given position.
     * 3.2. Strip leading and trailing ASCII whitespace from token.
     * 3.3. Append token to tokens.
     * 3.4. If position is not past the end of input, then:
     * 3.4.1. Assert: the code point at position within input is U+002C (,).
     * 3.4.2. Advance position by 1.
     * 4. Return tokens.
     */
    if (!util_1.isArray(input))
        return splitAStringOnCommas(Array.from(input));
    var options = { position: 0 };
    var tokens = [];
    while (options.position < input.length) {
        var token = collectASequenceOfCodePoints(function (str) { return str !== ','; }, input, options);
        tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
        if (options.position < input.length) {
            console.assert(input[options.position] === ',', "splitAStringOnCommas found no delimiter in input string.");
            options.position++;
        }
    }
    return tokens;
}
exports.splitAStringOnCommas = splitAStringOnCommas;
/**
 * Concatenates a list of strings with the given separator.
 *
 * @param list - a list of strings
 * @param separator - a separator string
 */
function concatenate(list, separator) {
    if (separator === void 0) { separator = ""; }
    /**
     * 1. If list is empty, then return the empty string.
     * 2. If separator is not given, then set separator to the empty string.
     * 3. Return a string whose contents are listâ€™s items, in order, separated
     * from each other by separator.
     */
    if (list.length === 0)
        return "";
    return list.join(separator);
}
exports.concatenate = concatenate;
//# sourceMappingURL=String.js.map

/***/ }),

/***/ 4251:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var base64 = __importStar(__nccwpck_require__(8585));
exports.base64 = base64;
var byte = __importStar(__nccwpck_require__(2460));
exports.byte = byte;
var byteSequence = __importStar(__nccwpck_require__(1627));
exports.byteSequence = byteSequence;
var codePoint = __importStar(__nccwpck_require__(8548));
exports.codePoint = codePoint;
var json = __importStar(__nccwpck_require__(9387));
exports.json = json;
var list = __importStar(__nccwpck_require__(340));
exports.list = list;
var map = __importStar(__nccwpck_require__(2298));
exports.map = map;
var namespace = __importStar(__nccwpck_require__(3764));
exports.namespace = namespace;
var queue = __importStar(__nccwpck_require__(9201));
exports.queue = queue;
var set = __importStar(__nccwpck_require__(5931));
exports.set = set;
var stack = __importStar(__nccwpck_require__(8784));
exports.stack = stack;
var string = __importStar(__nccwpck_require__(3203));
exports.string = string;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3568:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var interfaces_1 = __nccwpck_require__(1752);
var infra_1 = __nccwpck_require__(4251);
var url_1 = __nccwpck_require__(7310);
var _validationErrorCallback;
/**
 * Default ports for a special URL scheme.
 */
var _defaultPorts = {
    "ftp": 21,
    "file": null,
    "http": 80,
    "https": 443,
    "ws": 80,
    "wss": 443
};
/**
 * The C0 control percent-encode set are the C0 controls and all code points
 * greater than U+007E (~).
 */
var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The fragment percent-encode set is the C0 control percent-encode set and
 * U+0020 SPACE, U+0022 ("), U+003C (<), U+003E (>), and U+0060 (`).
 */
var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The path percent-encode set is the fragment percent-encode set and
 * U+0023 (#), U+003F (?), U+007B ({), and U+007D (}).
 */
var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The userinfo percent-encode set is the path percent-encode set and
 * U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([),
 * U+005C (\), U+005D (]), U+005E (^), and U+007C (|).
 */
var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The URL code points are ASCII alphanumeric, U+0021 (!), U+0024 ($),
 * U+0026 (&), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS,
 * U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/),
 * U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_),
 * U+007E (~), and code points in the range U+00A0 to U+10FFFD, inclusive,
 * excluding surrogates and noncharacters.
 */
var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
/**
 * A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF,
 * U+000D CR, U+0020 SPACE, U+0023 (#), U+0025 (%), U+002F (/), U+003A (:),
 * U+003F (?), U+0040 (@), U+005B ([), U+005C (\), or U+005D (]).
 */
var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
/**
 * Sets the callback function for validation errors.
 *
 * @param validationErrorCallback - a callback function to be called when a
 * validation error occurs
 */
function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
}
exports.setValidationErrorCallback = setValidationErrorCallback;
/**
 * Generates a validation error.
 *
 * @param message - error message
 */
function validationError(message) {
    if (_validationErrorCallback !== undefined) {
        _validationErrorCallback.call(null, "Validation Error: " + message);
    }
}
/**
 * Creates a new URL.
 */
function newURL() {
    return {
        scheme: '',
        username: '',
        password: '',
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        _cannotBeABaseURLFlag: false,
        _blobURLEntry: null
    };
}
exports.newURL = newURL;
/**
 * Determines if the scheme is a special scheme.
 *
 * @param scheme - a scheme
 */
function isSpecialScheme(scheme) {
    return (scheme in _defaultPorts);
}
exports.isSpecialScheme = isSpecialScheme;
/**
 * Determines if the URL has a special scheme.
 *
 * @param url - an URL
 */
function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
exports.isSpecial = isSpecial;
/**
 * Returns the default port for a special scheme.
 *
 * @param scheme - a scheme
 */
function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
}
exports.defaultPort = defaultPort;
/**
 * Determines if the URL has credentials.
 *
 * @param url - an URL
 */
function includesCredentials(url) {
    return url.username !== '' || url.password !== '';
}
exports.includesCredentials = includesCredentials;
/**
 * Determines if an URL cannot have credentials.
 *
 * @param url - an URL
 */
function cannotHaveAUsernamePasswordPort(url) {
    /**
     * A URL cannot have a username/password/port if its host is null or the
     * empty string, its cannot-be-a-base-URL flag is set, or its scheme is
     * "file".
     */
    return (url.host === null || url.host === "" || url._cannotBeABaseURLFlag ||
        url.scheme === "file");
}
exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
/**
 * Serializes an URL into a string.
 *
 * @param url - an URL
 */
function urlSerializer(url, excludeFragmentFlag) {
    var e_1, _a;
    if (excludeFragmentFlag === void 0) { excludeFragmentFlag = false; }
    /**
     * 1. Let output be urlâ€™s scheme and U+003A (:) concatenated.
     */
    var output = url.scheme + ':';
    /**
     * 2. If urlâ€™s host is non-null:
     */
    if (url.host !== null) {
        /**
         * 2.1. Append "//" to output.
         */
        output += '//';
        /**
         * 2.2. If url includes credentials, then:
         */
        if (includesCredentials(url)) {
            /**
             * 2.2.1. Append urlâ€™s username to output.
             * 2.2.2. If urlâ€™s password is not the empty string, then append U+003A (:),
             * followed by urlâ€™s password, to output.
             * 2.2.3. Append U+0040 (@) to output.
             */
            output += url.username;
            if (url.password !== '') {
                output += ':' + url.password;
            }
            output += '@';
        }
        /**
         * 2.3. Append urlâ€™s host, serialized, to output.
         * 2.4. If urlâ€™s port is non-null, append U+003A (:) followed by urlâ€™s port,
         * serialized, to output.
         */
        output += hostSerializer(url.host);
        if (url.port !== null) {
            output += ':' + url.port;
        }
    }
    else if (url.host === null && url.scheme === "file") {
        /**
         * 3. Otherwise, if urlâ€™s host is null and urlâ€™s scheme is "file", append "//" to output.
         */
        output += '//';
    }
    /**
     * 4. If urlâ€™s cannot-be-a-base-URL flag is set, append urlâ€™s path[0] to
     * output.
     * 5. Otherwise, then for each string in urlâ€™s path, append U+002F (/)
     * followed by the string to output.
     */
    if (url._cannotBeABaseURLFlag) {
        output += url.path[0];
    }
    else {
        try {
            for (var _b = __values(url.path), _c = _b.next(); !_c.done; _c = _b.next()) {
                var str = _c.value;
                output += '/' + str;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * 6. If urlâ€™s query is non-null, append U+003F (?), followed by urlâ€™s
     * query, to output.
     * 7. If the exclude fragment flag is unset and urlâ€™s fragment is non-null,
     * append U+0023 (#), followed by urlâ€™s fragment, to output.
     * 8. Return output.
     */
    if (url.query !== null) {
        output += '?' + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
        output += '#' + url.fragment;
    }
    return output;
}
exports.urlSerializer = urlSerializer;
/**
 * Serializes a host into a string.
 *
 * @param host - a host
 */
function hostSerializer(host) {
    /**
     * 1. If host is an IPv4 address, return the result of running the IPv4
     * serializer on host.
     * 2. Otherwise, if host is an IPv6 address, return U+005B ([), followed
     * by the result of running the IPv6 serializer on host, followed by
     * U+005D (]).
     * 3. Otherwise, host is a domain, opaque host, or empty host, return host.
     */
    if (util_1.isNumber(host)) {
        return iPv4Serializer(host);
    }
    else if (util_1.isArray(host)) {
        return '[' + iPv6Serializer(host) + ']';
    }
    else {
        return host;
    }
}
exports.hostSerializer = hostSerializer;
/**
 * Serializes an IPv4 address into a string.
 *
 * @param address  - an IPv4 address
 */
function iPv4Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let n be the value of address.
     * 3. For each i in the range 1 to 4, inclusive:
     * 3.1. Prepend n % 256, serialized, to output.
     * 3.2. If i is not 4, then prepend U+002E (.) to output.
     * 3.3. Set n to floor(n / 256).
     * 4. Return output.
     */
    var output = "";
    var n = address;
    for (var i = 1; i <= 4; i++) {
        output = (n % 256).toString() + output;
        if (i !== 4) {
            output = '.' + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
exports.iPv4Serializer = iPv4Serializer;
/**
 * Serializes an IPv6 address into a string.
 *
 * @param address  - an IPv6 address represented as a list of eight numbers
 */
function iPv6Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let compress be an index to the first IPv6 piece in the first longest
     * sequences of addressâ€™s IPv6 pieces that are 0.
     * In 0:f:0:0:f:f:0:0 it would point to the second 0.
     * 3. If there is no sequence of addressâ€™s IPv6 pieces that are 0 that is
     * longer than 1, then set compress to null.
     */
    var output = "";
    var compress = null;
    var lastIndex = -1;
    var count = 0;
    var lastCount = 0;
    for (var i = 0; i < 8; i++) {
        if (address[i] !== 0)
            continue;
        count = 1;
        for (var j = i + 1; j < 8; j++) {
            if (address[j] !== 0)
                break;
            count++;
            continue;
        }
        if (count > lastCount) {
            lastCount = count;
            lastIndex = i;
        }
    }
    if (lastCount > 1)
        compress = lastIndex;
    /**
     * 4. Let ignore0 be false.
     * 5. For each pieceIndex in the range 0 to 7, inclusive:
     */
    var ignore0 = false;
    for (var pieceIndex = 0; pieceIndex < 8; pieceIndex++) {
        /**
         * 5.1. If ignore0 is true and address[pieceIndex] is 0, then continue.
         * 5.2. Otherwise, if ignore0 is true, set ignore0 to false.
         * 5.3. If compress is pieceIndex, then:
         */
        if (ignore0 && address[pieceIndex] === 0)
            continue;
        if (ignore0)
            ignore0 = false;
        if (compress === pieceIndex) {
            /**
             * 5.3.1. Let separator be "::" if pieceIndex is 0, and U+003A (:) otherwise.
             * 5.3.2. Append separator to output.
             * 5.3.3. Set ignore0 to true and continue.
             */
            output += (pieceIndex === 0 ? '::' : ':');
            ignore0 = true;
            continue;
        }
        /**
         * 5.4. Append address[pieceIndex], represented as the shortest possible
         * lowercase hexadecimal number, to output.
         * 5.5. If pieceIndex is not 7, then append U+003A (:) to output.
         */
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7)
            output += ':';
    }
    /**
     * 6. Return output.
     */
    return output;
}
exports.iPv6Serializer = iPv6Serializer;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */
function urlParser(input, baseURL, encodingOverride) {
    /**
     * 1. Let url be the result of running the basic URL parser on input with
     * base, and encoding override as provided.
     * 2. If url is failure, return failure.
     * 3. If urlâ€™s scheme is not "blob", return url.
     * 4. Set urlâ€™s blob URL entry to the result of resolving the blob URL url,
     * if that did not return failure, and null otherwise.
     * 5. Return url.
     */
    var url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null)
        return null;
    if (url.scheme !== "blob")
        return url;
    var entry = resolveABlobURL(url);
    if (entry !== null) {
        url._blobURLEntry = entry;
    }
    else {
        url._blobURLEntry = null;
    }
    return url;
}
exports.urlParser = urlParser;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */
function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    var e_2, _a, e_3, _b;
    /**
     * 1. If url is not given:
     * 1.1. Set url to a new URL.
     * 1.2. If input contains any leading or trailing C0 control or space,
     * validation error.
     * 1.3. Remove any leading and trailing C0 control or space from input.
     */
    if (url === undefined) {
        url = newURL();
        // leading
        var leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
        var trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
        if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
            validationError("Input string contains leading or trailing control characters or space.");
        }
        input = input.replace(leadingControlOrSpace, '');
        input = input.replace(trailingControlOrSpace, '');
    }
    /**
     * 2. If input contains any ASCII tab or newline, validation error.
     * 3. Remove all ASCII tab or newline from input.
     */
    var tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
        validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, '');
    /**
     * 4. Let state be state override if given, or scheme start state otherwise.
     * 5. If base is not given, set it to null.
     * 6. Let encoding be UTF-8.
     * 7. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */
    var state = (stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride);
    if (baseURL === undefined)
        baseURL = null;
    var encoding = (encodingOverride === undefined ||
        encodingOverride === "replacement" || encodingOverride === "UTF-16BE" ||
        encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride);
    /**
     * 8. Let buffer be the empty string.
     * 9. Let the @ flag, [] flag, and passwordTokenSeenFlag be unset.
     * 10. Let pointer be a pointer to first code point in input.
     */
    var buffer = "";
    var atFlag = false;
    var arrayFlag = false;
    var passwordTokenSeenFlag = false;
    var EOF = "";
    var walker = new util_1.StringWalker(input);
    /**
     * 11. Keep running the following state machine by switching on state. If
     * after a run pointer points to the EOF code point, go to the next step.
     * Otherwise, increase pointer by one and continue with the state machine.
     */
    while (true) {
        switch (state) {
            case interfaces_1.ParserState.SchemeStart:
                /**
                 * 1. If c is an ASCII alpha, append c, lowercased, to buffer, and set
                 * state to scheme state.
                 * 2. Otherwise, if state override is not given, set state to no scheme
                 * state, and decrease pointer by one.
                 * 3. Otherwise, validation error, return failure.
                 */
                if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
                    buffer += walker.c().toLowerCase();
                    state = interfaces_1.ParserState.Scheme;
                }
                else if (stateOverride === undefined) {
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer--;
                }
                else {
                    validationError("Invalid scheme start character.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.Scheme:
                /**
                 * 1. If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E
                 * (.), append c, lowercased, to buffer.
                 */
                if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) ||
                    walker.c() === '+' || walker.c() === '-' || walker.c() === '.') {
                    buffer += walker.c().toLowerCase();
                }
                else if (walker.c() === ':') {
                    /**
                     * 2. Otherwise, if c is U+003A (:), then:
                     * 2.1. If state override is given, then:
                     * 2.1.1. If urlâ€™s scheme is a special scheme and buffer is not a
                     * special scheme, then return.
                     * 2.1.2. If urlâ€™s scheme is not a special scheme and buffer is a
                     * special scheme, then return.
                     * 2.1.3. If url includes credentials or has a non-null port, and
                     * buffer is "file", then return.
                     * 2.1.4. If urlâ€™s scheme is "file" and its host is an empty host or
                     * null, then return.
                     */
                    if (stateOverride !== undefined) {
                        if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer))
                            return url;
                        if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer))
                            return url;
                        if ((includesCredentials(url) || url.port !== null) && buffer === "file")
                            return url;
                        if (url.scheme === "file" && (url.host === "" || url.host === null))
                            return url;
                    }
                    /**
                     * 2.2. Set urlâ€™s scheme to buffer.
                     */
                    url.scheme = buffer;
                    /**
                     * 2.3. If state override is given, then:
                     * 2.3.1. If urlâ€™s port is urlâ€™s schemeâ€™s default port, then set
                     * urlâ€™s port to null.
                     * 2.3.2. Return.
                     */
                    if (stateOverride !== undefined) {
                        if (url.port === defaultPort(url.scheme)) {
                            url.port = null;
                        }
                        return url;
                    }
                    /**
                     * 2.4. Set buffer to the empty string.
                     */
                    buffer = "";
                    if (url.scheme === "file") {
                        /**
                         * 2.5. If urlâ€™s scheme is "file", then:
                         * 2.5.1. If remaining does not start with "//", validation error.
                         * 2.5.2. Set state to file state.
                         */
                        if (!walker.remaining().startsWith("//")) {
                            validationError("Invalid file URL scheme, '//' expected.");
                        }
                        state = interfaces_1.ParserState.File;
                    }
                    else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
                        /**
                         * 2.6. Otherwise, if url is special, base is non-null, and baseâ€™s
                         * scheme is equal to urlâ€™s scheme, set state to special relative
                         * or authority state.
                         */
                        state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
                    }
                    else if (isSpecial(url)) {
                        /**
                         * 2.7. Otherwise, if url is special, set state to special
                         * authority slashes state.
                         */
                        state = interfaces_1.ParserState.SpecialAuthoritySlashes;
                    }
                    else if (walker.remaining().startsWith("/")) {
                        /**
                         * 2.8. Otherwise, if remaining starts with an U+002F (/), set state
                         * to path or authority state and increase pointer by one.
                         */
                        state = interfaces_1.ParserState.PathOrAuthority;
                        walker.pointer++;
                    }
                    else {
                        /**
                         * 2.9. Otherwise, set urlâ€™s cannot-be-a-base-URL flag, append an
                         * empty string to urlâ€™s path, and set state to
                         * cannot-be-a-base-URL path state.
                         */
                        url._cannotBeABaseURLFlag = true;
                        url.path.push("");
                        state = interfaces_1.ParserState.CannotBeABaseURLPath;
                    }
                }
                else if (stateOverride === undefined) {
                    /**
                     * 3. Otherwise, if state override is not given, set buffer to the
                     * empty string, state to no scheme state, and start over (from the
                     * first code point in input).
                     */
                    buffer = "";
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer = 0;
                    continue;
                }
                else {
                    /**
                     * 4. Otherwise, validation error, return failure.
                     */
                    validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.NoScheme:
                /**
                 * 1. If base is null, or baseâ€™s cannot-be-a-base-URL flag is set
                 * and c is not U+0023 (#), validation error, return failure.
                 * 2. Otherwise, if baseâ€™s cannot-be-a-base-URL flag is set and
                 * c is U+0023 (#), set urlâ€™s scheme to baseâ€™s scheme, urlâ€™s path to
                 * a copy of baseâ€™s path, urlâ€™s query to baseâ€™s query, urlâ€™s
                 * fragment to the empty string, set urlâ€™s cannot-be-a-base-URL
                 * flag, and set state to fragment state.
                 * 3. Otherwise, if baseâ€™s scheme is not "file", set state to
                 * relative state and decrease pointer by one.
                 * 4. Otherwise, set state to file state and decrease pointer by one.
                 */
                if (baseURL === null || (baseURL._cannotBeABaseURLFlag && walker.c() !== '#')) {
                    validationError("Invalid input string.");
                    return null;
                }
                else if (baseURL._cannotBeABaseURLFlag && walker.c() === '#') {
                    url.scheme = baseURL.scheme;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = baseURL.query;
                    url.fragment = "";
                    url._cannotBeABaseURLFlag = true;
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (baseURL.scheme !== "file") {
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                }
                else {
                    state = interfaces_1.ParserState.File;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialRelativeOrAuthority:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to relative state and
                 * decrease pointer by one.
                 */
                if (walker.c() === '/' && walker.remaining().startsWith('/')) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                }
                else {
                    validationError("Invalid input string.");
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.PathOrAuthority:
                /**
                 * If c is U+002F (/), then set state to authority state.
                 * Otherwise, set state to path state, and decrease pointer by one.
                 */
                if (walker.c() === '/') {
                    state = interfaces_1.ParserState.Authority;
                }
                else {
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Relative:
                /**
                 * Set urlâ€™s scheme to baseâ€™s scheme, and then, switching on c:
                 */
                if (baseURL === null) {
                    throw new Error("Invalid parser state. Base URL is null.");
                }
                url.scheme = baseURL.scheme;
                switch (walker.c()) {
                    case EOF: // EOF
                        /**
                         * Set urlâ€™s username to baseâ€™s username, urlâ€™s password to baseâ€™s
                         * password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s port,
                         * urlâ€™s path to a copy of baseâ€™s path, and urlâ€™s query to baseâ€™s
                         * query.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        break;
                    case '/':
                        /**
                         * Set state to relative slash state.
                         */
                        state = interfaces_1.ParserState.RelativeSlash;
                        break;
                    case '?':
                        /**
                         * Set urlâ€™s username to baseâ€™s username, urlâ€™s password to baseâ€™s
                         * password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s port,
                         * urlâ€™s path to a copy of baseâ€™s path, urlâ€™s query to the empty
                         * string, and state to query state.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                        break;
                    case '#':
                        /**
                         * Set urlâ€™s username to baseâ€™s username, urlâ€™s password to baseâ€™s
                         * password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s port,
                         * urlâ€™s path to a copy of baseâ€™s path, urlâ€™s query to baseâ€™s
                         * query, urlâ€™s fragment to the empty string, and state to
                         * fragment state.
                         */
                        url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                        break;
                    default:
                        /**
                         * If url is special and c is U+005C (\), validation error,
                         * set state to relative slash state.
                         * Otherwise, run these steps:
                         * 1. Set urlâ€™s username to baseâ€™s username, urlâ€™s password to
                         * baseâ€™s password, urlâ€™s host to baseâ€™s host, urlâ€™s port to
                         * baseâ€™s port, urlâ€™s path to a copy of baseâ€™s path, and then
                         * remove urlâ€™s pathâ€™s last item, if any.
                         * 2. Set state to path state, and decrease pointer by one.
                         */
                        if (isSpecial(url) && walker.c() === '\\') {
                            validationError("Invalid input string.");
                            state = interfaces_1.ParserState.RelativeSlash;
                        }
                        else {
                            url.username = baseURL.username;
                            url.password = baseURL.password;
                            url.host = baseURL.host;
                            url.port = baseURL.port;
                            url.path = infra_1.list.clone(baseURL.path);
                            if (url.path.length !== 0)
                                url.path.splice(url.path.length - 1, 1);
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                        }
                        break;
                }
                break;
            case interfaces_1.ParserState.RelativeSlash:
                /**
                 * 1. If url is special and c is U+002F (/) or U+005C (\), then:
                 * 1.1. If c is U+005C (\), validation error.
                 * 1.2. Set state to special authority ignore slashes state.
                 * 2. Otherwise, if c is U+002F (/), then set state to authority state.
                 * 3. Otherwise, set urlâ€™s username to baseâ€™s username, urlâ€™s password
                 * to baseâ€™s password, urlâ€™s host to baseâ€™s host, urlâ€™s port to baseâ€™s
                 * port, state to path state, and then, decrease pointer by one.
                 */
                if (isSpecial(url) && (walker.c() === '/' || walker.c() === '\\')) {
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                }
                else if (walker.c() === '/') {
                    state = interfaces_1.ParserState.Authority;
                }
                else {
                    if (baseURL === null) {
                        throw new Error("Invalid parser state. Base URL is null.");
                    }
                    url.username = baseURL.username;
                    url.password = baseURL.password;
                    url.host = baseURL.host;
                    url.port = baseURL.port;
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthoritySlashes:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to special authority ignore
                 * slashes state, and decrease pointer by one.
                 */
                if (walker.c() === '/' && walker.remaining().startsWith('/')) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                }
                else {
                    validationError("Expected '//'.");
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
                /**
                 * If c is neither U+002F (/) nor U+005C (\), then set state to
                 * authority state and decrease pointer by one.
                 * Otherwise, validation error.
                 */
                if (walker.c() !== '/' && walker.c() !== '\\') {
                    state = interfaces_1.ParserState.Authority;
                    walker.pointer--;
                }
                else {
                    validationError("Unexpected '/' or '\\'.");
                }
                break;
            case interfaces_1.ParserState.Authority:
                /**
                 * 1. If c is U+0040 (@), then:
                 */
                if (walker.c() === '@') {
                    /**
                     * 1.1. Validation error.
                     * 1.2. If the @ flag is set, prepend "%40" to buffer.
                     * 1.3. Set the @ flag.
                     * 1.4. For each codePoint in buffer:
                     */
                    validationError("Unexpected '@'.");
                    if (atFlag)
                        buffer = '%40' + buffer;
                    atFlag = true;
                    try {
                        for (var buffer_1 = (e_2 = void 0, __values(buffer)), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                            var codePoint = buffer_1_1.value;
                            /**
                             * 1.4.1. If codePoint is U+003A (:) and passwordTokenSeenFlag is
                             * unset, then set passwordTokenSeenFlag and continue.
                             * 1.4.2. Let encodedCodePoints be the result of running UTF-8
                             * percent encode codePoint using the userinfo percent-encode set.
                             * 1.4.3. If passwordTokenSeenFlag is set, then append
                             * encodedCodePoints to urlâ€™s password.
                             * 1.4.4. Otherwise, append encodedCodePoints to urlâ€™s username.
                             */
                            if (codePoint === ':' && !passwordTokenSeenFlag) {
                                passwordTokenSeenFlag = true;
                                continue;
                            }
                            var encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
                            if (passwordTokenSeenFlag) {
                                url.password += encodedCodePoints;
                            }
                            else {
                                url.username += encodedCodePoints;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */
                    buffer = "";
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\')) {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then:
                     * 2.1. If @ flag is set and buffer is the empty string, validation
                     * error, return failure.
                     * 2.2. Decrease pointer by the number of code points in buffer plus
                     * one, set buffer to the empty string, and set state to host state.
                     */
                    if (atFlag && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    walker.pointer -= (buffer.length + 1);
                    buffer = "";
                    state = interfaces_1.ParserState.Host;
                }
                else {
                    /**
                     * 3. Otherwise, append c to buffer.
                     */
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Host:
            case interfaces_1.ParserState.Hostname:
                if (stateOverride !== undefined && url.scheme === "file") {
                    /**
                     * 1. If state override is given and urlâ€™s scheme is "file", then
                     * decrease pointer by one and set state to file host state.
                     */
                    walker.pointer--;
                    state = interfaces_1.ParserState.FileHost;
                }
                else if (walker.c() === ':' && !arrayFlag) {
                    /**
                     * 2. Otherwise, if c is U+003A (:) and the [] flag is unset, then:
                     * 2.1. If buffer is the empty string, validation error, return
                     * failure.
                     * 2.2. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 2.3. If host is failure, then return failure.
                     * 2.4. Set urlâ€™s host to host, buffer to the empty string, and
                     * state to port state.
                     * 2.5. If state override is given and state override is hostname
                     * state, then return.
                     */
                    if (buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null)
                        return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.Port;
                    if (stateOverride === interfaces_1.ParserState.Hostname)
                        return url;
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\')) {
                    /**
                     * 3. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then decrease pointer by one, and then:
                     * 3.1. If url is special and buffer is the empty string, validation
                     * error, return failure.
                     * 3.2. Otherwise, if state override is given, buffer is the empty
                     * string, and either url includes credentials or urlâ€™s port is
                     * non-null, validation error, return.
                     * 3.3. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 3.4. If host is failure, then return failure.
                     * 3.5. Set urlâ€™s host to host, buffer to the empty string, and
                     * state to path start state.
                     * 3.6. If state override is given, then return.
                     */
                    walker.pointer--;
                    if (isSpecial(url) && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    else if (stateOverride !== undefined && buffer === "" &&
                        (includesCredentials(url) || url.port !== null)) {
                        validationError("Invalid input string.");
                        return url;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null)
                        return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.PathStart;
                    if (stateOverride !== undefined)
                        return url;
                }
                else {
                    /**
                     * 4. Otherwise:
                     * 4.1. If c is U+005B ([), then set the [] flag.
                     * 4.2. If c is U+005D (]), then unset the [] flag.
                     * 4.3. Append c to buffer.
                     */
                    if (walker.c() === '[')
                        arrayFlag = true;
                    if (walker.c() === ']')
                        arrayFlag = false;
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Port:
                if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    /**
                     * 1. If c is an ASCII digit, append c to buffer.
                     */
                    buffer += walker.c();
                }
                else if (walker.c() === EOF || walker.c() === '/' || walker.c() === '?' || walker.c() === '#' ||
                    (isSpecial(url) && walker.c() === '\\') || stateOverride) {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * - state override is given
                     * then:
                     */
                    if (buffer !== "") {
                        /**
                         * 2.1. If buffer is not the empty string, then:
                         * 2.1.1. Let port be the mathematical integer value that is
                         * represented by buffer in radix-10 using ASCII digits for digits
                         * with values 0 through 9.
                         * 2.1.2. If port is greater than 2**16 âˆ’ 1, validation error,
                         * return failure.
                         * 2.1.3. Set urlâ€™s port to null, if port is urlâ€™s schemeâ€™s default
                         * port, and to port otherwise.
                         * 2.1.4. Set buffer to the empty string.
                         */
                        if (buffer !== "") {
                            var port = parseInt(buffer, 10);
                            if (port > Math.pow(2, 16) - 1) {
                                validationError("Invalid port number.");
                                return null;
                            }
                            url.port = (port === defaultPort(url.scheme) ? null : port);
                            buffer = "";
                        }
                    }
                    /**
                     * 2.2. If state override is given, then return.
                     * 2.3. Set state to path start state, and decrease pointer by one.
                     */
                    if (stateOverride !== undefined) {
                        return url;
                    }
                    state = interfaces_1.ParserState.PathStart;
                    walker.pointer--;
                }
                else {
                    /**
                     * 3. Otherwise, validation error, return failure.
                     */
                    validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.File:
                /**
                 * 1. Set urlâ€™s scheme to "file".
                 */
                url.scheme = "file";
                if (walker.c() === '/' || walker.c() === '\\') {
                    /**
                     * 2. If c is U+002F (/) or U+005C (\), then:
                     * 2.1. If c is U+005C (\), validation error.
                     * 2.2. Set state to file slash state.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileSlash;
                }
                else if (baseURL !== null && baseURL.scheme === "file") {
                    /**
                     * 3. Otherwise, if base is non-null and baseâ€™s scheme is "file",
                     * switch on c:
                     */
                    switch (walker.c()) {
                        case EOF:
                            /**
                             * Set urlâ€™s host to baseâ€™s host, urlâ€™s path to a copy of baseâ€™s
                             * path, and urlâ€™s query to baseâ€™s query.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            break;
                        case '?':
                            /**
                             * Set urlâ€™s host to baseâ€™s host, urlâ€™s path to a copy of baseâ€™s
                             * path, urlâ€™s query to the empty string, and state to query
                             * state.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = "";
                            state = interfaces_1.ParserState.Query;
                            break;
                        case '#':
                            /**
                             * Set urlâ€™s host to baseâ€™s host, urlâ€™s path to a copy of baseâ€™s
                             * path, urlâ€™s query to baseâ€™s query, urlâ€™s fragment to the
                             * empty string, and state to fragment state.
                             */
                            url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            url.fragment = "";
                            state = interfaces_1.ParserState.Fragment;
                            break;
                        default:
                            /**
                             * 1. If the substring from pointer in input does not start
                             * with a Windows drive letter, then set urlâ€™s host to baseâ€™s
                             * host, urlâ€™s path to a copy of baseâ€™s path, and then shorten
                             * urlâ€™s path.
                             * _Note:_ is a (platform-independent) Windows drive letter
                             * quirk.
                             * 2. Otherwise, validation error.
                             * 3. Set state to path state, and decrease pointer by one.
                             */
                            if (!startsWithAWindowsDriveLetter(walker.substring())) {
                                url.host = baseURL.host;
                                url.path = infra_1.list.clone(baseURL.path);
                                shorten(url);
                            }
                            else {
                                validationError("Unexpected windows drive letter in input string.");
                            }
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                            break;
                    }
                }
                else {
                    /**
                     * 4. Otherwise, set state to path state, and decrease pointer by
                     * one.
                     */
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileSlash:
                if (walker.c() === '/' || walker.c() === '\\') {
                    /**
                     * 1. If c is U+002F (/) or U+005C (\), then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to file host state.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileHost;
                }
                else {
                    /**
                     * 2. Otherwise:
                     * 2.1. If base is non-null, baseâ€™s scheme is "file", and the
                     * substring from pointer in input does not start with a Windows
                     * drive letter, then:
                     * 2.1.1. If baseâ€™s path[0] is a normalized Windows drive letter,
                     * then append baseâ€™s path[0] to urlâ€™s path.
                     * _Note:_ is a (platform-independent) Windows drive letter
                     * quirk. Both urlâ€™s and baseâ€™s host are null under these conditions
                     * and therefore not copied.
                     * 2.1.2. Otherwise, set urlâ€™s host to baseâ€™s host.
                     * 2.2. Set state to path state, and decrease pointer by one.
                     */
                    if (baseURL !== null && baseURL.scheme === "file" &&
                        !startsWithAWindowsDriveLetter(walker.substring())) {
                        if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                            url.path.push(baseURL.path[0]);
                        }
                        else {
                            url.host = baseURL.host;
                        }
                    }
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileHost:
                if (walker.c() === EOF || walker.c() === '/' || walker.c() === '\\' ||
                    walker.c() === '?' || walker.c() === '#') {
                    /**
                     * 1. If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?),
                     * or U+0023 (#), then decrease pointer by one and then:
                     */
                    walker.pointer--;
                    if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {
                        /**
                         * 1.1. If state override is not given and buffer is a Windows drive
                         * letter, validation error, set state to path state.
                         * _Note:_ is a (platform-independent) Windows drive letter
                         * quirk. buffer is not reset here and instead used in the path state.
                         */
                        validationError("Unexpected windows drive letter in input string.");
                        state = interfaces_1.ParserState.Path;
                    }
                    else if (buffer === "") {
                        /**
                         * 1.2. Otherwise, if buffer is the empty string, then:
                         * 1.2.1. Set urlâ€™s host to the empty string.
                         * 1.2.2. If state override is given, then return.
                         * 1.2.3. Set state to path start state.
                         */
                        url.host = "";
                        if (stateOverride !== undefined)
                            return url;
                        state = interfaces_1.ParserState.PathStart;
                    }
                    else {
                        /**
                         * 1.3. Otherwise, run these steps:
                         * 1.3.1. Let host be the result of host parsing buffer with url
                         * is not special.
                         * 1.3.2. If host is failure, then return failure.
                         * 1.3.3. If host is "localhost", then set host to the empty
                         * string.
                         * 1.3.4. Set urlâ€™s host to host.
                         * 1.3.5. If state override is given, then return.
                         * 1.3.6. Set buffer to the empty string and state to path start
                         * state.
                         */
                        var host = hostParser(buffer, !isSpecial(url));
                        if (host === null)
                            return null;
                        if (host === "localhost")
                            host = "";
                        url.host = host;
                        if (stateOverride !== undefined)
                            return url;
                        buffer = "";
                        state = interfaces_1.ParserState.PathStart;
                    }
                }
                else {
                    /**
                     * 2. Otherwise, append c to buffer.
                     */
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.PathStart:
                if (isSpecial(url)) {
                    /**
                     * 1. If url is special, then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to path state.
                     * 1.3. If c is neither U+002F (/) nor U+005C (\), then decrease
                     * pointer by one.
                     */
                    if (walker.c() === '\\') {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.Path;
                    if (walker.c() !== '/' && walker.c() !== '\\')
                        walker.pointer--;
                }
                else if (stateOverride === undefined && walker.c() === '?') {
                    /**
                     * 2. Otherwise, if state override is not given and c is U+003F (?),
                     * set urlâ€™s query to the empty string and state to query state.
                     */
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                }
                else if (stateOverride === undefined && walker.c() === '#') {
                    /**
                     * 3. Otherwise, if state override is not given and c is U+0023 (#),
                     * set urlâ€™s fragment to the empty string and state to fragment
                     * state.
                     */
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (walker.c() !== EOF) {
                    /**
                     * 4. Otherwise, if c is not the EOF code point:
                     * 4.1. Set state to path state.
                     * 4.2. If c is not U+002F (/), then decrease pointer by one.
                     */
                    state = interfaces_1.ParserState.Path;
                    if (walker.c() !== '/')
                        walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Path:
                if ((walker.c() === EOF || walker.c() === '/') ||
                    (isSpecial(url) && walker.c() === '\\') ||
                    (stateOverride === undefined && (walker.c() === '?' || walker.c() === '#'))) {
                    /**
                     * 1. If one of the following is true
                     * - c is the EOF code point or U+002F (/)
                     * - url is special and c is U+005C (\)
                     * - state override is not given and c is U+003F (?) or U+0023 (#)
                     * then:
                     */
                    if (isSpecial(url) && walker.c() === '\\') {
                        /**
                         * 1.1 If url is special and c is U+005C (\), validation error.
                         */
                        validationError("Invalid input string.");
                    }
                    if (isDoubleDotPathSegment(buffer)) {
                        /**
                         * 1.2. If buffer is a double-dot path segment, shorten urlâ€™s path,
                         * and then if neither c is U+002F (/), nor url is special and c is
                         * U+005C (\), append the empty string to urlâ€™s path.
                         */
                        shorten(url);
                        if (walker.c() !== '/' && !(isSpecial(url) && walker.c() === '\\')) {
                            url.path.push("");
                        }
                    }
                    else if (isSingleDotPathSegment(buffer) && walker.c() !== '/' &&
                        !(isSpecial(url) && walker.c() === '\\')) {
                        /**
                         * 1.3. Otherwise, if buffer is a single-dot path segment and if
                         * neither c is U+002F (/), nor url is special and c is U+005C (\),
                         * append the empty string to urlâ€™s path.
                         */
                        url.path.push("");
                    }
                    else if (!isSingleDotPathSegment(buffer)) {
                        /**
                         * 1.4. Otherwise, if buffer is not a single-dot path segment, then:
                         */
                        if (url.scheme === "file" && url.path.length === 0 &&
                            isWindowsDriveLetter(buffer)) {
                            /**
                             * 1.4.1. If urlâ€™s scheme is "file", urlâ€™s path is empty, and
                             * buffer is a Windows drive letter, then:
                             * 1.4.1.1. If urlâ€™s host is neither the empty string nor null,
                             * validation error, set urlâ€™s host to the empty string.
                             * 1.4.1.2. Replace the second code point in buffer with U+003A (:).
                             * _Note:_ is a (platform-independent) Windows drive letter quirk.
                             */
                            if (url.host !== null && url.host !== "") {
                                validationError("Invalid input string.");
                                url.host = "";
                            }
                            var bufferCodePoints = Array.from(buffer);
                            buffer = bufferCodePoints.slice(0, 1) + ':' + bufferCodePoints.slice(2);
                        }
                        /**
                         * 1.4.2. Append buffer to urlâ€™s path.
                         */
                        url.path.push(buffer);
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */
                    buffer = "";
                    /**
                     * 1.6. If urlâ€™s scheme is "file" and c is the EOF code point,
                     * U+003F (?), or U+0023 (#), then while urlâ€™s pathâ€™s size is
                     * greater than 1 and urlâ€™s path[0] is the empty string, validation
                     * error, remove the first item from urlâ€™s path.
                     */
                    if (url.scheme === "file" && (walker.c() === EOF || walker.c() === '?' || walker.c() === '#')) {
                        while (url.path.length > 1 && url.path[0] === "") {
                            validationError("Invalid input string.");
                            url.path.splice(0, 1);
                        }
                    }
                    /**
                     * 1.7. If c is U+003F (?), then set urlâ€™s query to the empty string
                     * and state to query state.
                     * 1.8. If c is U+0023 (#), then set urlâ€™s fragment to the empty
                     * string and state to fragment state.
                     */
                    if (walker.c() === '?') {
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                    }
                    if (walker.c() === '#') {
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                    }
                }
                else {
                    /**
                     * 2. Otherwise, run these steps:
                     * 2.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     * 2.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     * 2.3. UTF-8 percent encode c using the path percent-encode set,
                     * and append the result to buffer.
                     */
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
                }
                break;
            case interfaces_1.ParserState.CannotBeABaseURLPath:
                /**
                 * 1. If c is U+003F (?), then set urlâ€™s query to the empty string and
                 * state to query state.
                 * 2. Otherwise, if c is U+0023 (#), then set urlâ€™s fragment to the
                 * empty string and state to fragment state.
                 * 3. Otherwise:
                 * 3.1. If c is not the EOF code point, not a URL code point, and not
                 * U+0025 (%), validation error.
                 * 3.2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3.3. If c is not the EOF code point, UTF-8 percent encode c using
                 * the C0 control percent-encode set, and append the result to urlâ€™s
                 * path[0].
                 */
                if (walker.c() === '?') {
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                }
                else if (walker.c() === '#') {
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else {
                    if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    if (walker.c() !== EOF) {
                        url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
                    }
                }
                break;
            case interfaces_1.ParserState.Query:
                /**
                 * 1. If encoding is not UTF-8 and one of the following is true
                 * - url is not special
                 * - urlâ€™s scheme is "ws" or "wss"
                 * then set encoding to UTF-8.
                 */
                if (encoding !== "UTF-8" && (!isSpecial(url) ||
                    url.scheme === "ws" || url.scheme === "wss")) {
                    encoding = "UTF-8";
                }
                if (stateOverride === undefined && walker.c() === '#') {
                    /**
                     * 2. If state override is not given and c is U+0023 (#), then set
                     * urlâ€™s fragment to the empty string and state to fragment state.
                     */
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                }
                else if (walker.c() !== EOF) {
                    /**
                     * 3. Otherwise, if c is not the EOF code point:
                     * 3.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     */
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    /**
                     * 3.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     */
                    if (walker.c() === '%' && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    /**
                     * 3.3. Let bytes be the result of encoding c using encoding.
                     */
                    if (encoding.toUpperCase() !== "UTF-8") {
                        throw new Error("Only UTF-8 encoding is supported.");
                    }
                    var bytes = util_1.utf8Encode(walker.c());
                    /**
                     * 3.4. If bytes starts with `&#` and ends with 0x3B (;), then:
                     */
                    if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 &&
                        bytes[bytes.length - 1] === 59) {
                        /**
                         * 3.4.1. Replace `&#` at the start of bytes with `%26%23`.
                         * 3.4.2. Replace 0x3B (;) at the end of bytes with `%3B`.
                         * 3.4.4. Append bytes, isomorphic decoded, to urlâ€™s query.
                         * _Note:_ can happen when encoding code points using a
                         * non-UTF-8 encoding.
                         */
                        bytes = bytes.subarray(2, bytes.length - 1);
                        url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
                    }
                    else {
                        try {
                            /**
                             * 3.5. Otherwise, for each byte in bytes:
                             * 3.5.1. If one of the following is true
                             * - byte is less than 0x21 (!)
                             * - byte is greater than 0x7E (~)
                             * - byte is 0x22 ("), 0x23 (#), 0x3C (<), or 0x3E (>)
                             * - byte is 0x27 (') and url is special
                             * then append byte, percent encoded, to urlâ€™s query.
                             * 3.5.2. Otherwise, append a code point whose value is byte to
                             * urlâ€™s query.
                             */
                            for (var bytes_1 = (e_3 = void 0, __values(bytes)), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
                                var byte = bytes_1_1.value;
                                if (byte < 0x21 || byte > 0x7E || byte === 0x22 ||
                                    byte === 0x23 || byte === 0x3C || byte === 0x3E ||
                                    (byte === 0x27 && isSpecial(url))) {
                                    url.query += percentEncode(byte);
                                }
                                else {
                                    url.query += String.fromCharCode(byte);
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (bytes_1_1 && !bytes_1_1.done && (_b = bytes_1.return)) _b.call(bytes_1);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                    }
                }
                break;
            case interfaces_1.ParserState.Fragment:
                /**
                 * Switching on c:
                 * - The EOF code point
                 * Do nothing.
                 * - U+0000 NULL
                 * Validation error.
                 * - Otherwise
                 * 1. If c is not a URL code point and not U+0025 (%), validation
                 * error.
                 * 2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3. UTF-8 percent encode c using the fragment percent-encode set and
                 * append the result to urlâ€™s fragment.
                 */
                if (walker.c() === EOF) {
                    //
                }
                else if (walker.c() === "\u0000") {
                    validationError("NULL character in input string.");
                }
                else {
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== '%') {
                        validationError("Unexpected character in fragment string.");
                    }
                    if (walker.c() === '%' && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
                        validationError("Unexpected character in fragment string.");
                    }
                    url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
                }
                break;
        }
        if (walker.eof)
            break;
        else
            walker.pointer++;
    }
    /**
     * 12. Return url.
     */
    return url;
}
exports.basicURLParser = basicURLParser;
/**
 * Sets a URL's username.
 *
 * @param url - a URL
 * @param username - username string
 */
function setTheUsername(url, username) {
    var e_4, _a;
    /**
     * 1. Set urlâ€™s username to the empty string.
     * 2. For each code point in username, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to urlâ€™s username.
     */
    var result = "";
    try {
        for (var username_1 = __values(username), username_1_1 = username_1.next(); !username_1_1.done; username_1_1 = username_1.next()) {
            var codePoint = username_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (username_1_1 && !username_1_1.done && (_a = username_1.return)) _a.call(username_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    url.username = result;
}
exports.setTheUsername = setTheUsername;
/**
 * Sets a URL's password.
 *
 * @param url - a URL
 * @param username - password string
 */
function setThePassword(url, password) {
    var e_5, _a;
    /**
     * 1. Set urlâ€™s password to the empty string.
     * 2. For each code point in password, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to urlâ€™s password.
     */
    var result = "";
    try {
        for (var password_1 = __values(password), password_1_1 = password_1.next(); !password_1_1.done; password_1_1 = password_1.next()) {
            var codePoint = password_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (password_1_1 && !password_1_1.done && (_a = password_1.return)) _a.call(password_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    url.password = result;
}
exports.setThePassword = setThePassword;
/**
 * Determines if the string represents a single dot path.
 *
 * @param str - a string
 */
function isSingleDotPathSegment(str) {
    return str === '.' || str.toLowerCase() === "%2e";
}
exports.isSingleDotPathSegment = isSingleDotPathSegment;
/**
 * Determines if the string represents a double dot path.
 *
 * @param str - a string
 */
function isDoubleDotPathSegment(str) {
    var lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" ||
        lowerStr === "%2e." || lowerStr === "%2e%2e";
}
exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
/**
 * Shorten's URL's path.
 *
 * @param url - an URL
 */
function shorten(url) {
    /**
     * 1. Let path be urlâ€™s path.
     * 2. If path is empty, then return.
     * 3. If urlâ€™s scheme is "file", pathâ€™s size is 1, and path[0] is a
     * normalized Windows drive letter, then return.
     * 4. Remove pathâ€™s last item.
     */
    var path = url.path;
    if (path.length === 0)
        return;
    if (url.scheme === "file" && path.length === 1 &&
        isNormalizedWindowsDriveLetter(path[0]))
        return;
    url.path.splice(url.path.length - 1, 1);
}
exports.shorten = shorten;
/**
 * Determines if a string is a normalized Windows drive letter.
 *
 * @param str - a string
 */
function isNormalizedWindowsDriveLetter(str) {
    /**
     * A normalized Windows drive letter is a Windows drive letter of which the
     * second code point is U+003A (:).
     */
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&
        str[1] === ':';
}
exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
/**
 * Determines if a string is a Windows drive letter.
 *
 * @param str - a string
 */
function isWindowsDriveLetter(str) {
    /**
     * A Windows drive letter is two code points, of which the first is an ASCII
     * alpha and the second is either U+003A (:) or U+007C (|).
     */
    return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) &&
        (str[1] === ':' || str[1] === '|');
}
exports.isWindowsDriveLetter = isWindowsDriveLetter;
/**
 * Determines if a string starts with a Windows drive letter.
 *
 * @param str - a string
 */
function startsWithAWindowsDriveLetter(str) {
    /**
     * A string starts with a Windows drive letter if all of the following are
     * true:
     * - its length is greater than or equal to 2
     * - its first two code points are a Windows drive letter
     * - its length is 2 or its third code point is U+002F (/), U+005C (\),
     * U+003F (?), or U+0023 (#).
     */
    return str.length >= 2 && isWindowsDriveLetter(str) &&
        (str.length === 2 || (str[2] === '/' || str[2] === '\\' ||
            str[2] === '?' || str[2] === '#'));
}
exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
/**
 * Parses a host string.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */
function hostParser(input, isNotSpecial) {
    if (isNotSpecial === void 0) { isNotSpecial = false; }
    /**
     * 1. If isNotSpecial is not given, then set isNotSpecial to false.
     * 2. If input starts with U+005B ([), then:
     * 2.1. If input does not end with U+005D (]), validation error, return
     * failure.
     * 2.2. Return the result of IPv6 parsing input with its leading U+005B ([)
     * and trailing U+005D (]) removed.
     */
    if (input.startsWith('[')) {
        if (!input.endsWith(']')) {
            validationError("Expected ']' after '['.");
            return null;
        }
        return iPv6Parser(input.substring(1, input.length - 1));
    }
    /**
     * 3. If isNotSpecial is true, then return the result of opaque-host parsing
     * input.
     */
    if (isNotSpecial) {
        return opaqueHostParser(input);
    }
    /**
     * 4. Let domain be the result of running UTF-8 decode without BOM on the
     * string percent decoding of input.
     * _Note:_ Alternatively UTF-8 decode without BOM or fail can be used,
     * coupled with an early return for failure, as domain to ASCII fails
     * on U+FFFD REPLACEMENT CHARACTER.
     */
    var domain = util_1.utf8Decode(stringPercentDecode(input));
    /**
     * 5. Let asciiDomain be the result of running domain to ASCII on domain.
     * 6. If asciiDomain is failure, validation error, return failure.
     * 7. If asciiDomain contains a forbidden host code point, validation error,
     * return failure.
     */
    var asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
        validationError("Invalid domain.");
        return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
        validationError("Invalid domain.");
        return null;
    }
    /**
     * 8. Let ipv4Host be the result of IPv4 parsing asciiDomain.
     * 9. If ipv4Host is an IPv4 address or failure, return ipv4Host.
     * 10. Return asciiDomain.
     */
    var ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || util_1.isNumber(ipv4Host))
        return ipv4Host;
    return asciiDomain;
}
exports.hostParser = hostParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */
function iPv4NumberParser(input, validationErrorFlag) {
    if (validationErrorFlag === void 0) { validationErrorFlag = { value: false }; }
    /**
     * 1. Let R be 10.
     */
    var R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
        /**
         * 2. If input contains at least two code points and the first two code
         * points are either "0x" or "0X", then:
         * 2.1. Set validationErrorFlag.
         * 2.2. Remove the first two code points from input.
         * 2.3. Set R to 16.
         */
        validationErrorFlag.value = true;
        input = input.substr(2);
        R = 16;
    }
    else if (input.length >= 2 && input[0] === '0') {
        /**
         * 3. Otherwise, if input contains at least two code points and the first
         * code point is U+0030 (0), then:
         * 3.1. Set validationErrorFlag.
         * 3.2. Remove the first code point from input.
         * 3.3. Set R to 8.
         */
        validationErrorFlag.value = true;
        input = input.substr(1);
        R = 8;
    }
    /**
     * 4. If input is the empty string, then return zero.
     * 5. If input contains a code point that is not a radix-R digit, then
     * return failure.
     */
    if (input === "")
        return 0;
    var radixRDigits = (R === 10 ? /^[0-9]+$/ : (R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/));
    if (!radixRDigits.test(input))
        return null;
    /**
     * 6. Return the mathematical integer value that is represented by input in
     * radix-R notation, using ASCII hex digits for digits with values
     * 0 through 15.
     */
    return parseInt(input, R);
}
exports.iPv4NumberParser = iPv4NumberParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 */
function iPv4Parser(input) {
    var e_6, _a, e_7, _b;
    /**
     * 1. Let validationErrorFlag be unset.
     * 2. Let parts be input split on U+002E (.).
     */
    var validationErrorFlag = { value: false };
    var parts = input.split('.');
    /**
     * 3. If the last item in parts is the empty string, then:
     * 3.1. Set validationErrorFlag.
     * 3.2. If parts has more than one item, then remove the last item from
     * parts.
     */
    if (parts[parts.length - 1] === "") {
        validationErrorFlag.value = true;
        if (parts.length > 1)
            parts.pop();
    }
    /**
     * 4. If parts has more than four items, return input.
     */
    if (parts.length > 4)
        return input;
    /**
     * 5. Let numbers be the empty list.
     * 6. For each part in parts:
     * 6.1. If part is the empty string, return input.
     * 6.2. Let n be the result of parsing part using validationErrorFlag.
     * 6.3. If n is failure, return input.
     * 6.4. Append n to numbers.
     */
    var numbers = [];
    try {
        for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
            var part = parts_1_1.value;
            if (part === "")
                return input;
            var n = iPv4NumberParser(part, validationErrorFlag);
            if (n === null)
                return input;
            numbers.push(n);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    /**
     * 7. If validationErrorFlag is set, validation error.
     * 8. If any item in numbers is greater than 255, validation error.
     * 9. If any but the last item in numbers is greater than 255, return
     * failure.
     * 10. If the last item in numbers is greater than or equal to
     * 256**(5 âˆ’ the number of items in numbers), validation error, return failure.
     */
    if (validationErrorFlag.value)
        validationError("Invalid IP v4 address.");
    for (var i = 0; i < numbers.length; i++) {
        var item = numbers[i];
        if (item > 255) {
            validationError("Invalid IP v4 address.");
            if (i < numbers.length - 1)
                return null;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        validationError("Invalid IP v4 address.");
        return null;
    }
    /**
     * 11. Let ipv4 be the last item in numbers.
     * 12. Remove the last item from numbers.
     */
    var ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    /**
     * 13. Let counter be zero.
     * 14. For each n in numbers:
     * 14.2. Increment ipv4 by n Ã— 256**(3 âˆ’ counter).
     * 14.2. Increment counter by 1.
     */
    var counter = 0;
    try {
        for (var numbers_1 = __values(numbers), numbers_1_1 = numbers_1.next(); !numbers_1_1.done; numbers_1_1 = numbers_1.next()) {
            var n = numbers_1_1.value;
            ipv4 += n * Math.pow(256, 3 - counter);
            counter++;
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (numbers_1_1 && !numbers_1_1.done && (_b = numbers_1.return)) _b.call(numbers_1);
        }
        finally { if (e_7) throw e_7.error; }
    }
    /**
     * 15. Return ipv4.
     */
    return ipv4;
}
exports.iPv4Parser = iPv4Parser;
/**
 * Parses a string containing an IP v6 address.
 *
 * @param input - input string
 */
function iPv6Parser(input) {
    var _a;
    /**
     * 1. Let address be a new IPv6 address whose IPv6 pieces are all 0.
     * 2. Let pieceIndex be 0.
     * 3. Let compress be null.
     * 4. Let pointer be a pointer into input, initially 0 (pointing to the
     * first code point).
     */
    var EOF = "";
    var address = [0, 0, 0, 0, 0, 0, 0, 0];
    var pieceIndex = 0;
    var compress = null;
    var walker = new util_1.StringWalker(input);
    /**
     * 5. If c is U+003A (:), then:
     * 5.1. If remaining does not start with U+003A (:), validation error,
     * return failure.
     * 5.2. Increase pointer by 2.
     * 5.3. Increase pieceIndex by 1 and then set compress to pieceIndex.
     */
    if (walker.c() === ':') {
        if (!walker.remaining().startsWith(':')) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        walker.pointer += 2;
        pieceIndex += 1;
        compress = pieceIndex;
    }
    /**
     * 6. While c is not the EOF code point:
     */
    while (walker.c() !== EOF) {
        /**
         * 6.1. If pieceIndex is 8, validation error, return failure.
         */
        if (pieceIndex === 8) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.2. If c is U+003A (:), then:
         * 6.2.1. If compress is non-null, validation error, return failure.
         * 6.2.2. Increase pointer and pieceIndex by 1, set compress to pieceIndex,
         * and then continue.
         */
        if (walker.c() === ':') {
            if (compress !== null) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
        }
        /**
         * 6.3. Let value and length be 0.
         * 6.4. While length is less than 4 and c is an ASCII hex digit, set value
         * to value Ã— 0x10 + c interpreted as hexadecimal number, and increase
         * pointer and length by 1.
         */
        var value = 0;
        var length = 0;
        while (length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())) {
            value = value * 0x10 + parseInt(walker.c(), 16);
            walker.pointer++;
            length++;
        }
        /**
         * 6.5. If c is U+002E (.), then:
         */
        if (walker.c() === '.') {
            /**
             * 6.5.1. If length is 0, validation error, return failure.
             * 6.5.2. Decrease pointer by length.
             * 6.5.3. If pieceIndex is greater than 6, validation error, return
             * failure.
             * 6.5.4. Let numbersSeen be 0.
             */
            if (length === 0) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer -= length;
            if (pieceIndex > 6) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            var numbersSeen = 0;
            /**
             * 6.5.5. While c is not the EOF code point:
             */
            while (walker.c() !== EOF) {
                /**
                 * 6.5.5.1. Let ipv4Piece be null.
                 */
                var ipv4Piece = null;
                /**
                 * 6.5.5.2. If numbersSeen is greater than 0, then:
                 * 6.5.5.2.1. If c is a U+002E (.) and numbersSeen is less than 4, then
                 * increase pointer by 1.
                 * 6.5.5.2.1. Otherwise, validation error, return failure.
                 */
                if (numbersSeen > 0) {
                    if (walker.c() === '.' && numbersSeen < 4) {
                        walker.pointer++;
                    }
                    else {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                }
                /**
                 * 6.5.5.3. If c is not an ASCII digit, validation error, return
                 * failure.
                 */
                if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                /**
                 * 6.5.5.4. While c is an ASCII digit:
                 */
                while (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    /**
                     * 6.5.5.4.1. Let number be c interpreted as decimal number.
                     */
                    var number = parseInt(walker.c(), 10);
                    /**
                     * 6.5.5.4.2. If ipv4Piece is null, then set ipv4Piece to number.
                     * Otherwise, if ipv4Piece is 0, validation error, return failure.
                     * Otherwise, set ipv4Piece to ipv4Piece Ã— 10 + number.
                     */
                    if (ipv4Piece === null) {
                        ipv4Piece = number;
                    }
                    else if (ipv4Piece === 0) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                    else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    /**
                     * 6.5.5.4.3. If ipv4Piece is greater than 255, validation error, return failure.
                     * 6.5.5.4.4. Increase pointer by 1.
                     */
                    if (ipv4Piece > 255) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                    walker.pointer++;
                }
                /**
                 * 6.5.5.5. Set address[pieceIndex] to address[pieceIndex] Ã— 0x100 + ipv4Piece.
                 * 6.5.5.6. Increase numbersSeen by 1.
                 * 6.5.5.7. If numbersSeen is 2 or 4, then increase pieceIndex by 1.
                 */
                if (ipv4Piece === null) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen === 2 || numbersSeen === 4)
                    pieceIndex++;
            }
            /**
             * 6.5.6. If numbersSeen is not 4, validation error, return failure.
             */
            if (numbersSeen !== 4) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            /**
             * 6.5.7. Break.
             */
            break;
        }
        else if (walker.c() === ':') {
            /**
             * 6.6. Otherwise, if c is U+003A (:):
             * 6.6.1. Increase pointer by 1.
             * 6.6.2. If c is the EOF code point, validation error, return failure.
             */
            walker.pointer++;
            if (walker.c() === EOF) {
                validationError("Invalid IP v6 address.");
                return null;
            }
        }
        else if (walker.c() !== EOF) {
            /**
             * 6.7. Otherwise, if c is not the EOF code point, validation error,
             * return failure.
             */
            validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.8. Set address[pieceIndex] to value.
         * 6.9. Increase pieceIndex by 1.
         */
        address[pieceIndex] = value;
        pieceIndex++;
    }
    /**
     * 7. If compress is non-null, then:
     * 7.1. Let swaps be pieceIndex âˆ’ compress.
     * 7.2. Set pieceIndex to 7.
     * 7.3. While pieceIndex is not 0 and swaps is greater than 0, swap
     * address[pieceIndex] with address[compress + swaps âˆ’ 1], and then decrease
     * both pieceIndex and swaps by 1.
     */
    if (compress !== null) {
        var swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
            _a = __read([address[compress + swaps - 1], address[pieceIndex]], 2), address[pieceIndex] = _a[0], address[compress + swaps - 1] = _a[1];
            pieceIndex--;
            swaps--;
        }
    }
    else if (compress === null && pieceIndex !== 8) {
        /**
         * 8. Otherwise, if compress is null and pieceIndex is not 8,
         * validation error, return failure.
         */
        validationError("Invalid IP v6 address.");
        return null;
    }
    /**
     * 9. Return address.
     */
    return address;
}
exports.iPv6Parser = iPv6Parser;
/**
 * Parses an opaque host string.
 *
 * @param input - a string
 */
function opaqueHostParser(input) {
    var e_8, _a;
    /**
     * 1. If input contains a forbidden host code point excluding U+0025 (%),
     * validation error, return failure.
     * 2. Let output be the empty string.
     * 3. For each code point in input, UTF-8 percent encode it using the C0
     * control percent-encode set, and append the result to output.
     * 4. Return output.
     */
    var forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
        validationError("Invalid host string.");
        return null;
    }
    var output = "";
    try {
        for (var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {
            var codePoint = input_1_1.value;
            output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return output;
}
exports.opaqueHostParser = opaqueHostParser;
/**
 * Resolves a Blob URL from the user agent's Blob URL store.
 * function is not implemented.
 * See: https://w3c.github.io/FileAPI/#blob-url-resolve
 *
 * @param url - an url
 */
function resolveABlobURL(url) {
    return null;
}
exports.resolveABlobURL = resolveABlobURL;
/**
 * Percent encodes a byte.
 *
 * @param value - a byte
 */
function percentEncode(value) {
    /**
     * To percent encode a byte into a percent-encoded byte, return a string
     * consisting of U+0025 (%), followed by two ASCII upper hex digits
     * representing byte.
     */
    return '%' + ('00' + value.toString(16).toUpperCase()).slice(-2);
}
exports.percentEncode = percentEncode;
/**
 * Percent decodes a byte sequence input.
 *
 * @param input - a byte sequence
 */
function percentDecode(input) {
    var isHexDigit = function (byte) {
        return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) ||
            (byte >= 0x61 && byte <= 0x66);
    };
    /**
     * 1. Let output be an empty byte sequence.
     * 2. For each byte byte in input:
     */
    var output = new Uint8Array(input.length);
    var n = 0;
    for (var i = 0; i < input.length; i++) {
        var byte = input[i];
        /**
         * 2.1. If byte is not 0x25 (%), then append byte to output.
         * 2.2. Otherwise, if byte is 0x25 (%) and the next two bytes after byte
         * in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A)
         * to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte
         * to output.
         * 2.3. Otherwise:
         * 2.3.1. Let bytePoint be the two bytes after byte in input, decoded,
         * and then interpreted as hexadecimal number.
         * 2.3.2. Append a byte whose value is bytePoint to output.
         * 2.3.3. Skip the next two bytes in input.
         */
        if (byte !== 0x25) {
            output[n] = byte;
            n++;
        }
        else if (byte === 0x25 && i >= input.length - 2) {
            output[n] = byte;
            n++;
        }
        else if (byte === 0x25 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
            output[n] = byte;
            n++;
        }
        else {
            var bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);
            output[n] = bytePoint;
            n++;
            i += 2;
        }
    }
    return output.subarray(0, n);
}
exports.percentDecode = percentDecode;
/**
 * String percent decodes a string.
 *
 * @param input - a string
 */
function stringPercentDecode(input) {
    /**
     * 1. Let bytes be the UTF-8 encoding of input.
     * 2. Return the percent decoding of bytes.
     */
    return percentDecode(util_1.utf8Encode(input));
}
exports.stringPercentDecode = stringPercentDecode;
/**
 * UTF-8 percent encodes a code point, using a percent encode set.
 *
 * @param codePoint - a code point
 * @param percentEncodeSet - a percent encode set
 */
function utf8PercentEncode(codePoint, percentEncodeSet) {
    var e_9, _a;
    /**
     * 1. If codePoint is not in percentEncodeSet, then return codePoint.
     * 2. Let bytes be the result of running UTF-8 encode on codePoint.
     * 3. Percent encode each byte in bytes, and then return the results
     * concatenated, in the same order.
     */
    if (!percentEncodeSet.test(codePoint))
        return codePoint;
    var bytes = util_1.utf8Encode(codePoint);
    var result = "";
    try {
        for (var bytes_2 = __values(bytes), bytes_2_1 = bytes_2.next(); !bytes_2_1.done; bytes_2_1 = bytes_2.next()) {
            var byte = bytes_2_1.value;
            result += percentEncode(byte);
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (bytes_2_1 && !bytes_2_1.done && (_a = bytes_2.return)) _a.call(bytes_2);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return result;
}
exports.utf8PercentEncode = utf8PercentEncode;
/**
 * Determines if two hosts are considered equal.
 *
 * @param hostA - a host
 * @param hostB - a host
 */
function hostEquals(hostA, hostB) {
    return hostA === hostB;
}
exports.hostEquals = hostEquals;
/**
 * Determines if two URLs are considered equal.
 *
 * @param urlA - a URL
 * @param urlB - a URL
 * @param excludeFragmentsFlag - whether to ignore fragments while comparing
 */
function urlEquals(urlA, urlB, excludeFragmentsFlag) {
    if (excludeFragmentsFlag === void 0) { excludeFragmentsFlag = false; }
    /**
     * 1. Let serializedA be the result of serializing A, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 2. Let serializedB be the result of serializing B, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 3. Return true if serializedA is serializedB, and false otherwise.
     */
    return urlSerializer(urlA, excludeFragmentsFlag) ===
        urlSerializer(urlB, excludeFragmentsFlag);
}
exports.urlEquals = urlEquals;
/**
 * Parses an `application/x-www-form-urlencoded` string.
 *
 * @param input - a string
 */
function urlEncodedStringParser(input) {
    /**
     * The application/x-www-form-urlencoded string parser takes a string input,
     * UTF-8 encodes it, and then returns the result of
     * application/x-www-form-urlencoded parsing it.
     */
    return urlEncodedParser(util_1.utf8Encode(input));
}
exports.urlEncodedStringParser = urlEncodedStringParser;
/**
 * Parses `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */
function urlEncodedParser(input) {
    var e_10, _a, e_11, _b;
    /**
     * 1. Let sequences be the result of splitting input on 0x26 (&).
     */
    var sequences = [];
    var currentSequence = [];
    try {
        for (var input_2 = __values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()) {
            var byte = input_2_1.value;
            if (byte === 0x26) {
                sequences.push(Uint8Array.from(currentSequence));
                currentSequence = [];
            }
            else {
                currentSequence.push(byte);
            }
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);
        }
        finally { if (e_10) throw e_10.error; }
    }
    if (currentSequence.length !== 0) {
        sequences.push(Uint8Array.from(currentSequence));
    }
    /**
     * 2. Let output be an initially empty list of name-value tuples where both name and value hold a string.
     */
    var output = [];
    try {
        /**
         * 3. For each byte sequence bytes in sequences:
         */
        for (var sequences_1 = __values(sequences), sequences_1_1 = sequences_1.next(); !sequences_1_1.done; sequences_1_1 = sequences_1.next()) {
            var bytes = sequences_1_1.value;
            /**
             * 3.1. If bytes is the empty byte sequence, then continue.
             */
            if (bytes.length === 0)
                continue;
            /**
             * 3.2. If bytes contains a 0x3D (=), then let name be the bytes from the
             * start of bytes up to but excluding its first 0x3D (=), and let value be
             * the bytes, if any, after the first 0x3D (=) up to the end of bytes.
             * If 0x3D (=) is the first byte, then name will be the empty byte
             * sequence. If it is the last, then value will be the empty byte sequence.
             * 3.3. Otherwise, let name have the value of bytes and let value be the
             * empty byte sequence.
             */
            var index = bytes.indexOf(0x3D);
            var name = (index !== -1 ? bytes.slice(0, index) : bytes);
            var value = (index !== -1 ? bytes.slice(index + 1) : new Uint8Array());
            /**
             * 3.4. Replace any 0x2B (+) in name and value with 0x20 (SP).
             */
            for (var i = 0; i < name.length; i++)
                if (name[i] === 0x2B)
                    name[i] = 0x20;
            for (var i = 0; i < value.length; i++)
                if (value[i] === 0x2B)
                    value[i] = 0x20;
            /**
             * 3.5. Let nameString and valueString be the result of running UTF-8
             * decode without BOM on the percent decoding of name and value,
             * respectively.
             */
            var nameString = util_1.utf8Decode(name);
            var valueString = util_1.utf8Decode(value);
            /**
             * 3.6. Append (nameString, valueString) to output.
             */
            output.push([nameString, valueString]);
        }
    }
    catch (e_11_1) { e_11 = { error: e_11_1 }; }
    finally {
        try {
            if (sequences_1_1 && !sequences_1_1.done && (_b = sequences_1.return)) _b.call(sequences_1);
        }
        finally { if (e_11) throw e_11.error; }
    }
    /**
     * 4. Return output.
     */
    return output;
}
exports.urlEncodedParser = urlEncodedParser;
/**
 * Serializes `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */
function urlEncodedByteSerializer(input) {
    var e_12, _a;
    /**
     * 1. Let output be the empty string.
     * 2. For each byte in input, depending on byte:
     * 0x20 (SP)
     * Append U+002B (+) to output.
     *
     * 0x2A (*)
     * 0x2D (-)
     * 0x2E (.)
     * 0x30 (0) to 0x39 (9)
     * 0x41 (A) to 0x5A (Z)
     * 0x5F (_)
     * 0x61 (a) to 0x7A (z)
     * Append a code point whose value is byte to output.
     *
     * Otherwise
     * Append byte, percent encoded, to output.
     * 3. Return output.
     */
    var output = "";
    try {
        for (var input_3 = __values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()) {
            var byte = input_3_1.value;
            if (byte === 0x20) {
                output += '+';
            }
            else if (byte === 0x2A || byte === 0x2D || byte === 0x2E ||
                (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x5A) ||
                byte === 0x5F || (byte >= 0x61 && byte <= 0x7A)) {
                output += String.fromCodePoint(byte);
            }
            else {
                output += percentEncode(byte);
            }
        }
    }
    catch (e_12_1) { e_12 = { error: e_12_1 }; }
    finally {
        try {
            if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);
        }
        finally { if (e_12) throw e_12.error; }
    }
    return output;
}
exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
/**
 * Serializes `application/x-www-form-urlencoded` tuples.
 *
 * @param input - input tuple of name/value pairs
 * @param encodingOverride: encoding override
 */
function urlEncodedSerializer(tuples, encodingOverride) {
    var e_13, _a;
    /**
     * 1. Let encoding be UTF-8.
     * 2. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */
    var encoding = (encodingOverride === undefined ||
        encodingOverride === "replacement" || encodingOverride === "UTF-16BE" ||
        encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride);
    if (encoding.toUpperCase() !== "UTF-8") {
        throw new Error("Only UTF-8 encoding is supported.");
    }
    /**
     * 3. Let output be the empty string.
     */
    var output = "";
    try {
        /**
         * 4. For each tuple in tuples:
         */
        for (var tuples_1 = __values(tuples), tuples_1_1 = tuples_1.next(); !tuples_1_1.done; tuples_1_1 = tuples_1.next()) {
            var tuple = tuples_1_1.value;
            /**
             * 4.1. Let name be the result of serializing the result of encoding
             * tupleâ€™s name, using encoding.
             */
            var name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));
            /**
             * 4.2. Let value be tupleâ€™s value.
             */
            var value = tuple[1];
            /**
             * TODO:
             * 4.3. If value is a file, then set value to valueâ€™s filename.
             */
            /**
             * 4.4. Set value to the result of serializing the result of encoding
             * value, using encoding.
             */
            value = urlEncodedByteSerializer(util_1.utf8Encode(value));
            /**
             * 4.5. If tuple is not the first pair in tuples, then append U+0026 (&)
             * to output.
             */
            if (output !== "")
                output += '&';
            /**
             * 4.6. Append name, followed by U+003D (=), followed by value, to output.
             */
            output += name + '=' + value;
        }
    }
    catch (e_13_1) { e_13 = { error: e_13_1 }; }
    finally {
        try {
            if (tuples_1_1 && !tuples_1_1.done && (_a = tuples_1.return)) _a.call(tuples_1);
        }
        finally { if (e_13) throw e_13.error; }
    }
    /**
     * 5. Return output.
     */
    return output;
}
exports.urlEncodedSerializer = urlEncodedSerializer;
/**
 * Returns a URL's origin.
 *
 * @param url - a URL
 */
function origin(url) {
    /**
     * A URLâ€™s origin is the origin returned by running these steps, switching
     * on URLâ€™s scheme:
     * "blob"
     * 1. If URLâ€™s blob URL entry is non-null, then return URLâ€™s blob URL
     * entryâ€™s environmentâ€™s origin.
     * 2. Let url be the result of parsing URLâ€™s path[0].
     * 3. Return a new opaque origin, if url is failure, and urlâ€™s origin
     * otherwise.
     * "ftp"
     * "http"
     * "https"
     * "ws"
     * "wss"
     * Return a tuple consisting of URLâ€™s scheme, URLâ€™s host, URLâ€™s port, and
     * null.
     * "file"
     * Unfortunate as it is, is left as an exercise to the reader. When in
     * doubt, return a new opaque origin.
     * Otherwise
     * Return a new opaque origin.
     */
    switch (url.scheme) {
        case "blob":
            if (url._blobURLEntry !== null) {
                // TODO: return URLâ€™s blob URL entryâ€™s environmentâ€™s origin.
            }
            var parsedURL = basicURLParser(url.path[0]);
            if (parsedURL === null)
                return interfaces_1.OpaqueOrigin;
            else
                return origin(parsedURL);
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return [url.scheme, url.host === null ? "" : url.host, url.port, null];
        case "file":
            return interfaces_1.OpaqueOrigin;
        default:
            return interfaces_1.OpaqueOrigin;
    }
}
exports.origin = origin;
/**
 * Converts a domain string to ASCII.
 *
 * @param domain - a domain string
 */
function domainToASCII(domain, beStrict) {
    if (beStrict === void 0) { beStrict = false; }
    /**
     * 1. If beStrict is not given, set it to false.
     * 2. Let result be the result of running Unicode ToASCII with domain_name
     * set to domain, UseSTD3ASCIIRules set to beStrict, CheckHyphens set to
     * false, CheckBidi set to true, CheckJoiners set to true,
     * Transitional_Processing set to false, and VerifyDnsLength set to beStrict.
     * 3. If result is a failure value, validation error, return failure.
     * 4. Return result.
     */
    // Use node.js function
    var result = url_1.domainToASCII(domain);
    if (result === "") {
        validationError("Invalid domain name.");
        return null;
    }
    return result;
}
exports.domainToASCII = domainToASCII;
/**
 * Converts a domain string to Unicode.
 *
 * @param domain - a domain string
 */
function domainToUnicode(domain, beStrict) {
    if (beStrict === void 0) { beStrict = false; }
    /**
     * 1. Let result be the result of running Unicode ToUnicode with domain_name
     * set to domain, CheckHyphens set to false, CheckBidi set to true,
     * CheckJoiners set to true, UseSTD3ASCIIRules set to false, and
     * Transitional_Processing set to false.
     * 2. Signify validation errors for any returned errors, and then,
     * return result.
     */
    // Use node.js function
    var result = url_1.domainToUnicode(domain);
    if (result === "") {
        validationError("Invalid domain name.");
    }
    return result;
}
exports.domainToUnicode = domainToUnicode;
/**
 * Serializes an origin.
 * function is from the HTML spec:
 * https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
 *
 * @param origin - an origin
 */
function asciiSerializationOfAnOrigin(origin) {
    /**
     * 1. If origin is an opaque origin, then return "null".
     * 2. Otherwise, let result be origin's scheme.
     * 3. Append "://" to result.
     * 4. Append origin's host, serialized, to result.
     * 5. If origin's port is non-null, append a U+003A COLON character (:),
     * and origin's port, serialized, to result.
     * 6. Return result.
     */
    if (origin[0] === "" && origin[1] === "" && origin[2] === null && origin[3] === null) {
        return "null";
    }
    var result = origin[0] + "://" + hostSerializer(origin[1]);
    if (origin[2] !== null)
        result += ":" + origin[2].toString();
    return result;
}
exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin;
//# sourceMappingURL=URLAlgorithm.js.map

/***/ }),

/***/ 1752:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents the state of the URL parser.
 */
var ParserState;
(function (ParserState) {
    ParserState[ParserState["SchemeStart"] = 0] = "SchemeStart";
    ParserState[ParserState["Scheme"] = 1] = "Scheme";
    ParserState[ParserState["NoScheme"] = 2] = "NoScheme";
    ParserState[ParserState["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
    ParserState[ParserState["PathOrAuthority"] = 4] = "PathOrAuthority";
    ParserState[ParserState["Relative"] = 5] = "Relative";
    ParserState[ParserState["RelativeSlash"] = 6] = "RelativeSlash";
    ParserState[ParserState["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
    ParserState[ParserState["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
    ParserState[ParserState["Authority"] = 9] = "Authority";
    ParserState[ParserState["Host"] = 10] = "Host";
    ParserState[ParserState["Hostname"] = 11] = "Hostname";
    ParserState[ParserState["Port"] = 12] = "Port";
    ParserState[ParserState["File"] = 13] = "File";
    ParserState[ParserState["FileSlash"] = 14] = "FileSlash";
    ParserState[ParserState["FileHost"] = 15] = "FileHost";
    ParserState[ParserState["PathStart"] = 16] = "PathStart";
    ParserState[ParserState["Path"] = 17] = "Path";
    ParserState[ParserState["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
    ParserState[ParserState["Query"] = 19] = "Query";
    ParserState[ParserState["Fragment"] = 20] = "Fragment";
})(ParserState = exports.ParserState || (exports.ParserState = {}));
exports.OpaqueOrigin = ["", "", null, null];
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 7561:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a cache for storing order between equal objects.
 *
 * This cache is used when an algorithm compares two objects and finds them to
 * be equal but still needs to establish an order between those two objects.
 * When two such objects `a` and `b` are passed to the `check` method, a random
 * number is generated with `Math.random()`. If the random number is less than
 * `0.5` it is assumed that `a < b` otherwise `a > b`. The random number along
 * with `a` and `b` is stored in the cache, so that subsequent checks result
 * in the same consistent result.
 *
 * The cache has a size limit which is defined on initialization.
 */
var CompareCache = /** @class */ (function () {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    function CompareCache(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */
    CompareCache.prototype.check = function (objA, objB) {
        if (this._items.get(objA) === objB)
            return true;
        else if (this._items.get(objB) === objA)
            return false;
        var result = (Math.random() < 0.5);
        if (result) {
            this._items.set(objA, objB);
        }
        else {
            this._items.set(objB, objA);
        }
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return result;
    };
    return CompareCache;
}());
exports.CompareCache = CompareCache;
//# sourceMappingURL=CompareCache.js.map

/***/ }),

/***/ 6006:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a set of objects with a size limit.
 */
var FixedSizeSet = /** @class */ (function () {
    /**
     * Initializes a new instance of `FixedSizeSet`.
     *
     * @param limit - maximum number of items to keep in the set. When the limit
     * is exceeded the first item is removed from the set.
     */
    function FixedSizeSet(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Set();
        this._limit = limit;
    }
    /**
     * Adds a new item to the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.add = function (item) {
        this._items.add(item);
        if (this._items.size > this._limit) {
            var it_1 = this._items.values().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return this;
    };
    /**
     * Removes an item from the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.delete = function (item) {
        return this._items.delete(item);
    };
    /**
     * Determines if an item is in the set.
     *
     * @param item - an item
     */
    FixedSizeSet.prototype.has = function (item) {
        return this._items.has(item);
    };
    /**
     * Removes all items from the set.
     */
    FixedSizeSet.prototype.clear = function () {
        this._items.clear();
    };
    Object.defineProperty(FixedSizeSet.prototype, "size", {
        /**
         * Gets the number of items in the set.
         */
        get: function () { return this._items.size; },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the set.
     */
    FixedSizeSet.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        this._items.forEach(function (e) { return callback.call(thisArg, e, e, _this); });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.keys = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.keys())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.values = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.values())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype.entries = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.entries())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    FixedSizeSet.prototype[Symbol.iterator] = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    Object.defineProperty(FixedSizeSet.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the set.
         */
        get: function () {
            return "FixedSizeSet";
        },
        enumerable: true,
        configurable: true
    });
    return FixedSizeSet;
}());
exports.FixedSizeSet = FixedSizeSet;
//# sourceMappingURL=FixedSizeSet.js.map

/***/ }),

/***/ 1857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents an object with lazy initialization.
 */
var Lazy = /** @class */ (function () {
    /**
     * Initializes a new instance of `Lazy`.
     *
     * @param initFunc - initializer function
     */
    function Lazy(initFunc) {
        this._initialized = false;
        this._value = undefined;
        this._initFunc = initFunc;
    }
    Object.defineProperty(Lazy.prototype, "value", {
        /**
         * Gets the value of the object.
         */
        get: function () {
            if (!this._initialized) {
                this._value = this._initFunc();
                this._initialized = true;
            }
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return Lazy;
}());
exports.Lazy = Lazy;
//# sourceMappingURL=Lazy.js.map

/***/ }),

/***/ 5798:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents a cache of objects with a size limit.
 */
var ObjectCache = /** @class */ (function () {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */
    function ObjectCache(limit) {
        if (limit === void 0) { limit = 1000; }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Gets an item from the cache.
     *
     * @param key - object key
     */
    ObjectCache.prototype.get = function (key) {
        return this._items.get(key);
    };
    /**
     * Adds a new item to the cache.
     *
     * @param key - object key
     * @param value - object value
     */
    ObjectCache.prototype.set = function (key, value) {
        this._items.set(key, value);
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */
            if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
    };
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */
    ObjectCache.prototype.delete = function (key) {
        return this._items.delete(key);
    };
    /**
     * Determines if an item is in the cache.
     *
     * @param item - an item
     */
    ObjectCache.prototype.has = function (key) {
        return this._items.has(key);
    };
    /**
     * Removes all items from the cache.
     */
    ObjectCache.prototype.clear = function () {
        this._items.clear();
    };
    Object.defineProperty(ObjectCache.prototype, "size", {
        /**
         * Gets the number of items in the cache.
         */
        get: function () { return this._items.size; },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the cache.
     */
    ObjectCache.prototype.forEach = function (callback, thisArg) {
        this._items.forEach(function (v, k) { return callback.call(thisArg, k, v); });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.keys = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.keys())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.values = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.values())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype.entries = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items.entries())];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */
    ObjectCache.prototype[Symbol.iterator] = function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [5 /*yield**/, __values(this._items)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    };
    Object.defineProperty(ObjectCache.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the cache.
         */
        get: function () {
            return "ObjectCache";
        },
        enumerable: true,
        configurable: true
    });
    return ObjectCache;
}());
exports.ObjectCache = ObjectCache;
//# sourceMappingURL=ObjectCache.js.map

/***/ }),

/***/ 4145:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Walks through the code points of a string.
 */
var StringWalker = /** @class */ (function () {
    /**
     * Initializes a new `StringWalker`.
     *
     * @param input - input string
     */
    function StringWalker(input) {
        this._pointer = 0;
        this._chars = Array.from(input);
        this._length = this._chars.length;
    }
    Object.defineProperty(StringWalker.prototype, "eof", {
        /**
         * Determines if the current position is beyond the end of string.
         */
        get: function () { return this._pointer >= this._length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StringWalker.prototype, "length", {
        /**
         * Returns the number of code points in the input string.
         */
        get: function () { return this._length; },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the current code point. Returns `-1` if the position is beyond
     * the end of string.
     */
    StringWalker.prototype.codePoint = function () {
        if (this._codePoint === undefined) {
            if (this.eof) {
                this._codePoint = -1;
            }
            else {
                var cp = this._chars[this._pointer].codePointAt(0);
                /* istanbul ignore else */
                if (cp !== undefined) {
                    this._codePoint = cp;
                }
                else {
                    this._codePoint = -1;
                }
            }
        }
        return this._codePoint;
    };
    /**
     * Returns the current character. Returns an empty string if the position is
     * beyond the end of string.
     */
    StringWalker.prototype.c = function () {
        if (this._c === undefined) {
            this._c = (this.eof ? "" : this._chars[this._pointer]);
        }
        return this._c;
    };
    /**
     * Returns the remaining string.
     */
    StringWalker.prototype.remaining = function () {
        if (this._remaining === undefined) {
            this._remaining = (this.eof ?
                "" : this._chars.slice(this._pointer + 1).join(''));
        }
        return this._remaining;
    };
    /**
     * Returns the substring from the current character to the end of string.
     */
    StringWalker.prototype.substring = function () {
        if (this._substring === undefined) {
            this._substring = (this.eof ?
                "" : this._chars.slice(this._pointer).join(''));
        }
        return this._substring;
    };
    Object.defineProperty(StringWalker.prototype, "pointer", {
        /**
         * Gets or sets the current position.
         */
        get: function () { return this._pointer; },
        set: function (val) {
            if (val === this._pointer)
                return;
            this._pointer = val;
            this._codePoint = undefined;
            this._c = undefined;
            this._remaining = undefined;
            this._substring = undefined;
        },
        enumerable: true,
        configurable: true
    });
    return StringWalker;
}());
exports.StringWalker = StringWalker;
//# sourceMappingURL=StringWalker.js.map

/***/ }),

/***/ 6195:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var FixedSizeSet_1 = __nccwpck_require__(6006);
exports.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
var ObjectCache_1 = __nccwpck_require__(5798);
exports.ObjectCache = ObjectCache_1.ObjectCache;
var CompareCache_1 = __nccwpck_require__(7561);
exports.CompareCache = CompareCache_1.CompareCache;
var Lazy_1 = __nccwpck_require__(1857);
exports.Lazy = Lazy_1.Lazy;
var StringWalker_1 = __nccwpck_require__(4145);
exports.StringWalker = StringWalker_1.StringWalker;
/**
 * Applies the mixin to a given class.
 *
 * @param baseClass - class to receive the mixin
 * @param mixinClass - mixin class
 * @param overrides - an array with names of function overrides. Base class
 * functions whose names are in this array will be kept by prepending an
 * underscore to their names.
 */
function applyMixin(baseClass, mixinClass) {
    var overrides = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        overrides[_i - 2] = arguments[_i];
    }
    Object.getOwnPropertyNames(mixinClass.prototype).forEach(function (name) {
        if (name !== "constructor") {
            if (overrides.indexOf(name) !== -1) {
                var orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
                /* istanbul ignore else */
                if (orgPropDesc) {
                    Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
                }
            }
            var propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
            /* istanbul ignore else */
            if (propDesc) {
                Object.defineProperty(baseClass.prototype, name, propDesc);
            }
        }
    });
}
exports.applyMixin = applyMixin;
/**
 * Applies default values to the given object.
 *
 * @param obj - an object
 * @param defaults - an object with default values
 * @param overwrite - if set to `true` defaults object always overwrites object
 * values, whether they are `undefined` or not.
 */
function applyDefaults(obj, defaults, overwrite) {
    if (overwrite === void 0) { overwrite = false; }
    var result = clone(obj || {});
    forEachObject(defaults, function (key, val) {
        if (isPlainObject(val)) {
            result[key] = applyDefaults(result[key], val, overwrite);
        }
        else if (overwrite || result[key] === undefined) {
            result[key] = val;
        }
    });
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Iterates over items of an array or set.
 *
 * @param arr - array or set to iterate
 * @param callback - a callback function which receives each array item as its
 * single argument
 * @param thisArg - the value of this inside callback
 */
function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
}
exports.forEachArray = forEachArray;
/**
 * Iterates over key/value pairs of a map or object.
 *
 * @param obj - map or object to iterate
 * @param callback - a callback function which receives object key as its first
 * argument and object value as its second argument
 * @param thisArg - the value of this inside callback
 */
function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
        obj.forEach(function (value, key) { return callback.call(thisArg, key, value); });
    }
    else {
        for (var key in obj) {
            /* istanbul ignore else */
            if (obj.hasOwnProperty(key)) {
                callback.call(thisArg, key, obj[key]);
            }
        }
    }
}
exports.forEachObject = forEachObject;
/**
 * Returns the number of entries in an array or set.
 *
 * @param arr - array or set
 */
function arrayLength(obj) {
    if (isSet(obj)) {
        return obj.size;
    }
    else {
        return obj.length;
    }
}
exports.arrayLength = arrayLength;
/**
 * Returns the number of entries in a map or object.
 *
 * @param obj - map or object
 */
function objectLength(obj) {
    if (isMap(obj)) {
        return obj.size;
    }
    else {
        return Object.keys(obj).length;
    }
}
exports.objectLength = objectLength;
/**
 * Gets the value of a key from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to retrieve
 */
function getObjectValue(obj, key) {
    if (isMap(obj)) {
        return obj.get(key);
    }
    else {
        return obj[key];
    }
}
exports.getObjectValue = getObjectValue;
/**
 * Removes a property from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to remove
 */
function removeObjectValue(obj, key) {
    if (isMap(obj)) {
        obj.delete(key);
    }
    else {
        delete obj[key];
    }
}
exports.removeObjectValue = removeObjectValue;
/**
 * Deep clones the given object.
 *
 * @param obj - an object
 */
function clone(obj) {
    var e_1, _a;
    if (isFunction(obj)) {
        return obj;
    }
    else if (isArray(obj)) {
        var result = [];
        try {
            for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                var item = obj_1_1.value;
                result.push(clone(item));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    else if (isObject(obj)) {
        var result = {};
        for (var key in obj) {
            /* istanbul ignore next */
            if (obj.hasOwnProperty(key)) {
                var val = obj[key];
                result[key] = clone(val);
            }
        }
        return result;
    }
    else {
        return obj;
    }
}
exports.clone = clone;
/**
 * Type guard for boolean types
 *
 * @param x - a variable to type check
 */
function isBoolean(x) {
    return typeof x === "boolean";
}
exports.isBoolean = isBoolean;
/**
 * Type guard for numeric types
 *
 * @param x - a variable to type check
 */
function isNumber(x) {
    return typeof x === "number";
}
exports.isNumber = isNumber;
/**
 * Type guard for strings
 *
 * @param x - a variable to type check
 */
function isString(x) {
    return typeof x === "string";
}
exports.isString = isString;
/**
 * Type guard for function objects
 *
 * @param x - a variable to type check
 */
function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === '[object Function]';
}
exports.isFunction = isFunction;
/**
 * Type guard for JS objects
 *
 * _Note:_ Functions are objects too
 *
 * @param x - a variable to type check
 */
function isObject(x) {
    var type = typeof x;
    return !!x && (type === 'function' || type === 'object');
}
exports.isObject = isObject;
/**
 * Type guard for arrays
 *
 * @param x - a variable to type check
 */
function isArray(x) {
    return Array.isArray(x);
}
exports.isArray = isArray;
/**
 * Type guard for sets.
 *
 * @param x - a variable to check
 */
function isSet(x) {
    return x instanceof Set;
}
exports.isSet = isSet;
/**
 * Type guard for maps.
 *
 * @param x - a variable to check
 */
function isMap(x) {
    return x instanceof Map;
}
exports.isMap = isMap;
/**
 * Determines if `x` is an empty Array or an Object with no own properties.
 *
 * @param x - a variable to check
 */
function isEmpty(x) {
    if (isArray(x)) {
        return !x.length;
    }
    else if (isSet(x)) {
        return !x.size;
    }
    else if (isMap(x)) {
        return !x.size;
    }
    else if (isObject(x)) {
        for (var key in x) {
            if (x.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
exports.isEmpty = isEmpty;
/**
 * Determines if `x` is a plain Object.
 *
 * @param x - a variable to check
 */
function isPlainObject(x) {
    if (isObject(x)) {
        var proto = Object.getPrototypeOf(x);
        var ctor = proto.constructor;
        return proto && ctor &&
            (typeof ctor === 'function') && (ctor instanceof ctor) &&
            (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
    }
    return false;
}
exports.isPlainObject = isPlainObject;
/**
 * Determines if `x` is an iterable Object.
 *
 * @param x - a variable to check
 */
function isIterable(x) {
    return x && (typeof x[Symbol.iterator] === 'function');
}
exports.isIterable = isIterable;
/**
 * Gets the primitive value of an object.
 */
function getValue(obj) {
    if (isFunction(obj.valueOf)) {
        return obj.valueOf();
    }
    else {
        return obj;
    }
}
exports.getValue = getValue;
/**
 * UTF-8 encodes the given string.
 *
 * @param input - a string
 */
function utf8Encode(input) {
    var bytes = new Uint8Array(input.length * 4);
    var byteIndex = 0;
    for (var i = 0; i < input.length; i++) {
        var char = input.charCodeAt(i);
        if (char < 128) {
            bytes[byteIndex++] = char;
            continue;
        }
        else if (char < 2048) {
            bytes[byteIndex++] = char >> 6 | 192;
        }
        else {
            if (char > 0xd7ff && char < 0xdc00) {
                if (++i >= input.length) {
                    throw new Error("Incomplete surrogate pair.");
                }
                var c2 = input.charCodeAt(i);
                if (c2 < 0xdc00 || c2 > 0xdfff) {
                    throw new Error("Invalid surrogate character.");
                }
                char = 0x10000 + ((char & 0x03ff) << 10) + (c2 & 0x03ff);
                bytes[byteIndex++] = char >> 18 | 240;
                bytes[byteIndex++] = char >> 12 & 63 | 128;
            }
            else {
                bytes[byteIndex++] = char >> 12 | 224;
            }
            bytes[byteIndex++] = char >> 6 & 63 | 128;
        }
        bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
}
exports.utf8Encode = utf8Encode;
/**
 * UTF-8 decodes the given byte sequence into a string.
 *
 * @param bytes - a byte sequence
 */
function utf8Decode(bytes) {
    var result = "";
    var i = 0;
    while (i < bytes.length) {
        var c = bytes[i++];
        if (c > 127) {
            if (c > 191 && c < 224) {
                if (i >= bytes.length) {
                    throw new Error("Incomplete 2-byte sequence.");
                }
                c = (c & 31) << 6 | bytes[i++] & 63;
            }
            else if (c > 223 && c < 240) {
                if (i + 1 >= bytes.length) {
                    throw new Error("Incomplete 3-byte sequence.");
                }
                c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            }
            else if (c > 239 && c < 248) {
                if (i + 2 >= bytes.length) {
                    throw new Error("Incomplete 4-byte sequence.");
                }
                c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            }
            else {
                throw new Error("Unknown multi-byte start.");
            }
        }
        if (c <= 0xffff) {
            result += String.fromCharCode(c);
        }
        else if (c <= 0x10ffff) {
            c -= 0x10000;
            result += String.fromCharCode(c >> 10 | 0xd800);
            result += String.fromCharCode(c & 0x3FF | 0xdc00);
        }
        else {
            throw new Error("Code point exceeds UTF-16 limit.");
        }
    }
    return result;
}
exports.utf8Decode = utf8Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7678:
/***/ ((module, exports) => {

"use strict";

/// <reference lib="es2018"/>
/// <reference lib="dom"/>
/// <reference types="node"/>
Object.defineProperty(exports, "__esModule", ({ value: true }));
const typedArrayTypeNames = [
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Uint16Array',
    'Int32Array',
    'Uint32Array',
    'Float32Array',
    'Float64Array',
    'BigInt64Array',
    'BigUint64Array'
];
function isTypedArrayName(name) {
    return typedArrayTypeNames.includes(name);
}
const objectTypeNames = [
    'Function',
    'Generator',
    'AsyncGenerator',
    'GeneratorFunction',
    'AsyncGeneratorFunction',
    'AsyncFunction',
    'Observable',
    'Array',
    'Buffer',
    'Blob',
    'Object',
    'RegExp',
    'Date',
    'Error',
    'Map',
    'Set',
    'WeakMap',
    'WeakSet',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'DataView',
    'Promise',
    'URL',
    'FormData',
    'URLSearchParams',
    'HTMLElement',
    ...typedArrayTypeNames
];
function isObjectTypeName(name) {
    return objectTypeNames.includes(name);
}
const primitiveTypeNames = [
    'null',
    'undefined',
    'string',
    'number',
    'bigint',
    'boolean',
    'symbol'
];
function isPrimitiveTypeName(name) {
    return primitiveTypeNames.includes(name);
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isOfType(type) {
    return (value) => typeof value === type;
}
const { toString } = Object.prototype;
const getObjectType = (value) => {
    const objectTypeName = toString.call(value).slice(8, -1);
    if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value)) {
        return 'HTMLElement';
    }
    if (isObjectTypeName(objectTypeName)) {
        return objectTypeName;
    }
    return undefined;
};
const isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
    if (value === null) {
        return 'null';
    }
    switch (typeof value) {
        case 'undefined':
            return 'undefined';
        case 'string':
            return 'string';
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'function':
            return 'Function';
        case 'bigint':
            return 'bigint';
        case 'symbol':
            return 'symbol';
        default:
    }
    if (is.observable(value)) {
        return 'Observable';
    }
    if (is.array(value)) {
        return 'Array';
    }
    if (is.buffer(value)) {
        return 'Buffer';
    }
    const tagType = getObjectType(value);
    if (tagType) {
        return tagType;
    }
    if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError('Please don\'t use object wrappers for primitive types');
    }
    return 'Object';
}
is.undefined = isOfType('undefined');
is.string = isOfType('string');
const isNumberType = isOfType('number');
is.number = (value) => isNumberType(value) && !is.nan(value);
is.bigint = isOfType('bigint');
// eslint-disable-next-line @typescript-eslint/ban-types
is.function_ = isOfType('function');
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');
is.boolean = (value) => value === true || value === false;
is.symbol = isOfType('symbol');
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => {
    if (!Array.isArray(value)) {
        return false;
    }
    if (!is.function_(assertion)) {
        return true;
    }
    return value.every(assertion);
};
is.buffer = (value) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false; };
is.blob = (value) => isObjectOfType('Blob')(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value));
is.iterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]); };
is.asyncIterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]); };
is.generator = (value) => { var _a, _b; return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw); };
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType('Promise')(value);
const hasPromiseAPI = (value) => {
    var _a, _b;
    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) &&
        is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);
};
is.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);
is.generatorFunction = isObjectOfType('GeneratorFunction');
is.asyncGeneratorFunction = (value) => getObjectType(value) === 'AsyncGeneratorFunction';
is.asyncFunction = (value) => getObjectType(value) === 'AsyncFunction';
// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');
is.regExp = isObjectOfType('RegExp');
is.date = isObjectOfType('Date');
is.error = isObjectOfType('Error');
is.map = (value) => isObjectOfType('Map')(value);
is.set = (value) => isObjectOfType('Set')(value);
is.weakMap = (value) => isObjectOfType('WeakMap')(value);
is.weakSet = (value) => isObjectOfType('WeakSet')(value);
is.int8Array = isObjectOfType('Int8Array');
is.uint8Array = isObjectOfType('Uint8Array');
is.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');
is.int16Array = isObjectOfType('Int16Array');
is.uint16Array = isObjectOfType('Uint16Array');
is.int32Array = isObjectOfType('Int32Array');
is.uint32Array = isObjectOfType('Uint32Array');
is.float32Array = isObjectOfType('Float32Array');
is.float64Array = isObjectOfType('Float64Array');
is.bigInt64Array = isObjectOfType('BigInt64Array');
is.bigUint64Array = isObjectOfType('BigUint64Array');
is.arrayBuffer = isObjectOfType('ArrayBuffer');
is.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');
is.dataView = isObjectOfType('DataView');
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType('URL')(value);
is.urlString = (value) => {
    if (!is.string(value)) {
        return false;
    }
    try {
        new URL(value); // eslint-disable-line no-new
        return true;
    }
    catch (_a) {
        return false;
    }
};
// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`
is.truthy = (value) => Boolean(value);
// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js
    if (toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.getPrototypeOf({});
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
const isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.inRange = (value, range) => {
    if (is.number(range)) {
        return value >= Math.min(0, range) && value <= Math.max(range, 0);
    }
    if (is.array(range) && range.length === 2) {
        return value >= Math.min(...range) && value <= Math.max(...range);
    }
    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
const NODE_TYPE_ELEMENT = 1;
const DOM_PROPERTIES_TO_CHECK = [
    'innerHTML',
    'ownerDocument',
    'style',
    'attributes',
    'nodeValue'
];
is.domElement = (value) => {
    return is.object(value) &&
        value.nodeType === NODE_TYPE_ELEMENT &&
        is.string(value.nodeName) &&
        !is.plainObject(value) &&
        DOM_PROPERTIES_TO_CHECK.every(property => property in value);
};
is.observable = (value) => {
    var _a, _b, _c, _d;
    if (!value) {
        return false;
    }
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {
        return true;
    }
    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {
        return true;
    }
    return false;
};
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Infinity || value === -Infinity;
const isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
const isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
// TODO: Use `not ''` when the `not` operator is available.
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:
// - https://github.com/Microsoft/TypeScript/pull/29317
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType('FormData')(value);
is.urlSearchParams = (value) => isObjectOfType('URLSearchParams')(value);
const predicateOnArray = (method, predicate, values) => {
    if (!is.function_(predicate)) {
        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
    }
    if (values.length === 0) {
        throw new TypeError('Invalid number of values');
    }
    return method.call(values, predicate);
};
is.any = (predicate, ...values) => {
    const predicates = is.array(predicate) ? predicate : [predicate];
    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));
};
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
const assertType = (condition, description, value, options = {}) => {
    if (!condition) {
        const { multipleValues } = options;
        const valuesMessage = multipleValues ?
            `received values of types ${[
                ...new Set(value.map(singleValue => `\`${is(singleValue)}\``))
            ].join(', ')}` :
            `received value of type \`${is(value)}\``;
        throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
    }
};
exports.assert = {
    // Unknowns.
    undefined: (value) => assertType(is.undefined(value), 'undefined', value),
    string: (value) => assertType(is.string(value), 'string', value),
    number: (value) => assertType(is.number(value), 'number', value),
    bigint: (value) => assertType(is.bigint(value), 'bigint', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: (value) => assertType(is.function_(value), 'Function', value),
    null_: (value) => assertType(is.null_(value), 'null', value),
    class_: (value) => assertType(is.class_(value), "Class" /* class_ */, value),
    boolean: (value) => assertType(is.boolean(value), 'boolean', value),
    symbol: (value) => assertType(is.symbol(value), 'symbol', value),
    numericString: (value) => assertType(is.numericString(value), "string with a number" /* numericString */, value),
    array: (value, assertion) => {
        const assert = assertType;
        assert(is.array(value), 'Array', value);
        if (assertion) {
            value.forEach(assertion);
        }
    },
    buffer: (value) => assertType(is.buffer(value), 'Buffer', value),
    blob: (value) => assertType(is.blob(value), 'Blob', value),
    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined" /* nullOrUndefined */, value),
    object: (value) => assertType(is.object(value), 'Object', value),
    iterable: (value) => assertType(is.iterable(value), "Iterable" /* iterable */, value),
    asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable" /* asyncIterable */, value),
    generator: (value) => assertType(is.generator(value), 'Generator', value),
    asyncGenerator: (value) => assertType(is.asyncGenerator(value), 'AsyncGenerator', value),
    nativePromise: (value) => assertType(is.nativePromise(value), "native Promise" /* nativePromise */, value),
    promise: (value) => assertType(is.promise(value), 'Promise', value),
    generatorFunction: (value) => assertType(is.generatorFunction(value), 'GeneratorFunction', value),
    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: (value) => assertType(is.asyncFunction(value), 'AsyncFunction', value),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: (value) => assertType(is.boundFunction(value), 'Function', value),
    regExp: (value) => assertType(is.regExp(value), 'RegExp', value),
    date: (value) => assertType(is.date(value), 'Date', value),
    error: (value) => assertType(is.error(value), 'Error', value),
    map: (value) => assertType(is.map(value), 'Map', value),
    set: (value) => assertType(is.set(value), 'Set', value),
    weakMap: (value) => assertType(is.weakMap(value), 'WeakMap', value),
    weakSet: (value) => assertType(is.weakSet(value), 'WeakSet', value),
    int8Array: (value) => assertType(is.int8Array(value), 'Int8Array', value),
    uint8Array: (value) => assertType(is.uint8Array(value), 'Uint8Array', value),
    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),
    int16Array: (value) => assertType(is.int16Array(value), 'Int16Array', value),
    uint16Array: (value) => assertType(is.uint16Array(value), 'Uint16Array', value),
    int32Array: (value) => assertType(is.int32Array(value), 'Int32Array', value),
    uint32Array: (value) => assertType(is.uint32Array(value), 'Uint32Array', value),
    float32Array: (value) => assertType(is.float32Array(value), 'Float32Array', value),
    float64Array: (value) => assertType(is.float64Array(value), 'Float64Array', value),
    bigInt64Array: (value) => assertType(is.bigInt64Array(value), 'BigInt64Array', value),
    bigUint64Array: (value) => assertType(is.bigUint64Array(value), 'BigUint64Array', value),
    arrayBuffer: (value) => assertType(is.arrayBuffer(value), 'ArrayBuffer', value),
    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),
    dataView: (value) => assertType(is.dataView(value), 'DataView', value),
    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), 'EnumCase', value),
    urlInstance: (value) => assertType(is.urlInstance(value), 'URL', value),
    urlString: (value) => assertType(is.urlString(value), "string with a URL" /* urlString */, value),
    truthy: (value) => assertType(is.truthy(value), "truthy" /* truthy */, value),
    falsy: (value) => assertType(is.falsy(value), "falsy" /* falsy */, value),
    nan: (value) => assertType(is.nan(value), "NaN" /* nan */, value),
    primitive: (value) => assertType(is.primitive(value), "primitive" /* primitive */, value),
    integer: (value) => assertType(is.integer(value), "integer" /* integer */, value),
    safeInteger: (value) => assertType(is.safeInteger(value), "integer" /* safeInteger */, value),
    plainObject: (value) => assertType(is.plainObject(value), "plain object" /* plainObject */, value),
    typedArray: (value) => assertType(is.typedArray(value), "TypedArray" /* typedArray */, value),
    arrayLike: (value) => assertType(is.arrayLike(value), "array-like" /* arrayLike */, value),
    domElement: (value) => assertType(is.domElement(value), "HTMLElement" /* domElement */, value),
    observable: (value) => assertType(is.observable(value), 'Observable', value),
    nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream" /* nodeStream */, value),
    infinite: (value) => assertType(is.infinite(value), "infinite number" /* infinite */, value),
    emptyArray: (value) => assertType(is.emptyArray(value), "empty array" /* emptyArray */, value),
    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array" /* nonEmptyArray */, value),
    emptyString: (value) => assertType(is.emptyString(value), "empty string" /* emptyString */, value),
    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace" /* emptyStringOrWhitespace */, value),
    nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string" /* nonEmptyString */, value),
    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace" /* nonEmptyStringAndNotWhitespace */, value),
    emptyObject: (value) => assertType(is.emptyObject(value), "empty object" /* emptyObject */, value),
    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object" /* nonEmptyObject */, value),
    emptySet: (value) => assertType(is.emptySet(value), "empty set" /* emptySet */, value),
    nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set" /* nonEmptySet */, value),
    emptyMap: (value) => assertType(is.emptyMap(value), "empty map" /* emptyMap */, value),
    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map" /* nonEmptyMap */, value),
    propertyKey: (value) => assertType(is.propertyKey(value), 'PropertyKey', value),
    formData: (value) => assertType(is.formData(value), 'FormData', value),
    urlSearchParams: (value) => assertType(is.urlSearchParams(value), 'URLSearchParams', value),
    // Numbers.
    evenInteger: (value) => assertType(is.evenInteger(value), "even integer" /* evenInteger */, value),
    oddInteger: (value) => assertType(is.oddInteger(value), "odd integer" /* oddInteger */, value),
    // Two arguments.
    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T" /* directInstanceOf */, instance),
    inRange: (value, range) => assertType(is.inRange(value, range), "in range" /* inRange */, value),
    // Variadic functions.
    any: (predicate, ...values) => {
        return assertType(is.any(predicate, ...values), "predicate returns truthy for any value" /* any */, values, { multipleValues: true });
    },
    all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values" /* all */, values, { multipleValues: true })
};
// Some few keywords are reserved, but we'll populate them for Node.js users
// See https://github.com/Microsoft/TypeScript/issues/2536
Object.defineProperties(is, {
    class: {
        value: is.class_
    },
    function: {
        value: is.function_
    },
    null: {
        value: is.null_
    }
});
Object.defineProperties(exports.assert, {
    class: {
        value: exports.assert.class_
    },
    function: {
        value: exports.assert.function_
    },
    null: {
        value: exports.assert.null_
    }
});
exports["default"] = is;
// For CommonJS default export support
module.exports = is;
module.exports["default"] = is;
module.exports.assert = exports.assert;


/***/ }),

/***/ 1705:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromisePoolError = void 0;
class PromisePoolError extends Error {
    /**
     * Create a new instance for the given `message` and `item`.
     *
     * @param error  The original error
     * @param item   The item causing the error
     */
    constructor(error, item) {
        super();
        this.raw = error;
        this.item = item;
        this.name = this.constructor.name;
        this.message = this.messageFrom(error);
        Error.captureStackTrace(this, this.constructor);
    }
    /**
     * Returns a new promise pool error instance wrapping the `error` and `item`.
     *
     * @param {*} error
     * @param {*} item
     *
     * @returns {PromisePoolError}
     */
    static createFrom(error, item) {
        return new this(error, item);
    }
    /**
     * Returns the error message from the given `error`.
     *
     * @param {*} error
     *
     * @returns {String}
     */
    messageFrom(error) {
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'object') {
            return error.message;
        }
        if (typeof error === 'string' || typeof error === 'number') {
            return error.toString();
        }
        return '';
    }
}
exports.PromisePoolError = PromisePoolError;


/***/ }),

/***/ 6331:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromisePoolExecutor = void 0;
const promise_pool_error_1 = __nccwpck_require__(1705);
const stop_the_promise_pool_error_1 = __nccwpck_require__(4983);
const validation_error_1 = __nccwpck_require__(9657);
class PromisePoolExecutor {
    /**
     * Creates a new promise pool executer instance with a default concurrency of 10.
     */
    constructor() {
        this.meta = {
            tasks: [],
            items: [],
            errors: [],
            results: [],
            stopped: false,
            concurrency: 10,
            processedItems: [],
        };
        this.handler = () => { };
        this.errorHandler = undefined;
        this.onTaskStartedHandlers = [];
        this.onTaskFinishedHandlers = [];
    }
    /**
     * Set the number of tasks to process concurrently the promise pool.
     *
     * @param {Integer} concurrency
     *
     * @returns {PromisePoolExecutor}
     */
    useConcurrency(concurrency) {
        if (!this.isValidConcurrency(concurrency)) {
            throw validation_error_1.ValidationError.createFrom(`"concurrency" must be a number, 1 or up. Received "${concurrency}" (${typeof concurrency})`);
        }
        this.meta.concurrency = concurrency;
        return this;
    }
    /**
     * Determine whether the given `concurrency` value is valid.
     *
     * @param {Number} concurrency
     *
     * @returns {Boolean}
     */
    isValidConcurrency(concurrency) {
        return typeof concurrency === 'number' && concurrency >= 1;
    }
    /**
     * Returns the number of concurrently processed tasks.
     *
     * @returns {Number}
     */
    concurrency() {
        return this.meta.concurrency;
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {Array} items
     *
     * @returns {PromisePoolExecutor}
     */
    for(items) {
        this.meta.items = items;
        return this;
    }
    /**
     * Returns the list of items to process.
     *
     * @returns {T[]}
     */
    items() {
        return this.meta.items;
    }
    /**
     * Returns the number of items to process.
     *
     * @returns {Number}
     */
    itemsCount() {
        return this.items().length;
    }
    /**
     * Returns the list of active tasks.
     *
     * @returns {Array}
     */
    tasks() {
        return this.meta.tasks;
    }
    /**
     * Returns the number of currently active tasks.
     *
     * @returns {Number}
     *
     * @deprecated use the `activeTasksCount()` method (plural naming) instead
     */
    activeTaskCount() {
        return this.activeTasksCount();
    }
    /**
     * Returns the number of currently active tasks.
     *
     * @returns {Number}
     */
    activeTasksCount() {
        return this.tasks().length;
    }
    /**
     * Returns the list of processed items.
     *
     * @returns {T[]}
     */
    processedItems() {
        return this.meta.processedItems;
    }
    /**
     * Returns the number of processed items.
     *
     * @returns {Number}
     */
    processedCount() {
        return this.processedItems().length;
    }
    /**
     * Returns the percentage progress of items that have been processed.
     */
    processedPercentage() {
        return (this.processedCount() / this.itemsCount()) * 100;
    }
    /**
     * Returns the list of results.
     *
     * @returns {R[]}
     */
    results() {
        return this.meta.results;
    }
    /**
     * Returns the list of errors.
     *
     * @returns {Array<PromisePoolError<T>>}
     */
    errors() {
        return this.meta.errors;
    }
    /**
     * Set the handler that is applied to each item.
     *
     * @param {Function} action
     *
     * @returns {PromisePoolExecutor}
     */
    withHandler(action) {
        this.handler = action;
        return this;
    }
    /**
     * Determine whether a custom error handle is available.
     *
     * @returns {Boolean}
     */
    hasErrorHandler() {
        return !!this.errorHandler;
    }
    /**
     * Set the error handler function to execute when an error occurs.
     *
     * @param {Function} errorHandler
     *
     * @returns {PromisePoolExecutor}
     */
    handleError(handler) {
        this.errorHandler = handler;
        return this;
    }
    /**
     * Set the handler function to execute when started a task.
     *
     * @param {Function} handler
     *
     * @returns {this}
     */
    onTaskStarted(handlers) {
        this.onTaskStartedHandlers = handlers;
        return this;
    }
    /**
      * Assign the given callback `handler` function to run when a task finished.
     *
     * @param {OnProgressCallback<T>} handlers
     *
     * @returns {this}
     */
    onTaskFinished(handlers) {
        this.onTaskFinishedHandlers = handlers;
        return this;
    }
    /**
     * Determines whether the number of active tasks is greater or equal to the concurrency limit.
     *
     * @returns {Boolean}
     */
    hasReachedConcurrencyLimit() {
        return this.activeTasksCount() >= this.concurrency();
    }
    /**
     * Stop a promise pool processing.
     */
    stop() {
        this.markAsStopped();
        throw new stop_the_promise_pool_error_1.StopThePromisePoolError();
    }
    /**
     * Mark the promise pool as stopped.
     *
     * @returns {PromisePoolExecutor}
     */
    markAsStopped() {
        this.meta.stopped = true;
        return this;
    }
    /**
     * Determine whether the pool is stopped.
     *
     * @returns {Boolean}
     */
    isStopped() {
        return this.meta.stopped;
    }
    /**
     * Start processing the promise pool.
     *
     * @returns {ReturnValue}
     */
    async start() {
        return await this.validateInputs().process();
    }
    /**
     * Determine whether the pool should stop.
     *
     * @returns {PromisePoolExecutor}
     *
     * @throws
     */
    validateInputs() {
        if (typeof this.handler !== 'function') {
            throw validation_error_1.ValidationError.createFrom('The first parameter for the .process(fn) method must be a function');
        }
        if (!Array.isArray(this.items())) {
            throw validation_error_1.ValidationError.createFrom(`"items" must be an array. Received ${typeof this.items()}`);
        }
        if (this.errorHandler && typeof this.errorHandler !== 'function') {
            throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received ${typeof this.errorHandler}`);
        }
        this.onTaskStartedHandlers.forEach(handler => {
            if (handler && typeof handler !== 'function') {
                throw validation_error_1.ValidationError.createFrom(`The onTaskStarted handler must be a function. Received ${typeof handler}`);
            }
        });
        this.onTaskFinishedHandlers.forEach(handler => {
            if (handler && typeof handler !== 'function') {
                throw validation_error_1.ValidationError.createFrom(`The error handler must be a function. Received ${typeof handler}`);
            }
        });
        return this;
    }
    /**
     * Starts processing the promise pool by iterating over the items
     * and running each item through the async `callback` function.
     *
     * @param {Function} callback
     *
     * @returns {Promise}
     */
    async process() {
        for (const [index, item] of this.items().entries()) {
            if (this.isStopped()) {
                break;
            }
            await this.waitForProcessingSlot();
            this.startProcessing(item, index);
        }
        return await this.drained();
    }
    /**
     * Wait for one of the active tasks to finish processing.
     */
    async waitForProcessingSlot() {
        while (this.hasReachedConcurrencyLimit()) {
            await Promise.race(this.tasks());
        }
    }
    /**
     * Create a processing function for the given `item`.
     *
     * @param {T} item
     * @param {number} index
     */
    startProcessing(item, index) {
        const task = this.createTaskFor(item, index)
            .then(result => {
            this
                .removeActive(task)
                .save(result);
        })
            .catch(async (error) => {
            return this
                .removeActive(task)
                .handleErrorFor(error, item);
        }).finally(() => {
            this.processedItems().push(item);
            this.runOnTaskFinishedHandlers(item);
        });
        this.tasks().push(task);
        this.runOnTaskStartedHandlers(item);
    }
    /**
     * Ensures a returned promise for the processing of the given `item`.
     *
     * @param {T} item
     * @param {number} index
     *
     * @returns {*}
     */
    async createTaskFor(item, index) {
        return this.handler(item, index, this);
    }
    /**
     * Save the given calculation `result`.
     *
     * @param {*} result
     *
     * @returns {PromisePoolExecutor}
     */
    save(result) {
        this.results().push(result);
        return this;
    }
    /**
     * Remove the given `task` from the list of active tasks.
     *
     * @param {Promise} task
     */
    removeActive(task) {
        this.tasks().splice(this.tasks().indexOf(task), 1);
        return this;
    }
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {Error} error
     * @param {T} item
     */
    async handleErrorFor(error, item) {
        if (this.isStoppingThePoolError(error)) {
            return;
        }
        if (this.isValidationError(error)) {
            this.markAsStopped();
            throw error;
        }
        return this.hasErrorHandler()
            ? await this.runErrorHandlerFor(error, item)
            : this.saveErrorFor(error, item);
    }
    /**
     * Determine whether the given `error` is a `StopThePromisePoolError` instance.
     *
     * @param {Error} error
     *
     * @returns {Boolean}
     */
    isStoppingThePoolError(error) {
        return error instanceof stop_the_promise_pool_error_1.StopThePromisePoolError;
    }
    /**
     * Determine whether the given `error` is a `ValidationError` instance.
     *
     * @param {Error} error
     *
     * @returns {Boolean}
     */
    isValidationError(error) {
        return error instanceof validation_error_1.ValidationError;
    }
    /**
     * Run the userâ€™s error handler, if available.
     *
     * @param {Error} processingError
     * @param {T} item
     */
    async runErrorHandlerFor(processingError, item) {
        var _a;
        try {
            return await ((_a = this.errorHandler) === null || _a === void 0 ? void 0 : _a.call(this, processingError, item, this));
        }
        catch (error) {
            this.rethrowIfNotStoppingThePool(error);
        }
    }
    /**
     * Run the onTaskStarted handlers.
     */
    runOnTaskStartedHandlers(item) {
        this.onTaskStartedHandlers.forEach(handler => {
            handler(item, this);
        });
    }
    /**
     * Run the onTaskFinished handlers.
     */
    runOnTaskFinishedHandlers(item) {
        this.onTaskFinishedHandlers.forEach(handler => {
            handler(item, this);
        });
    }
    /**
     * Rethrow the given `error` if itâ€™s not an instance of `StopThePromisePoolError`.
     *
     * @param {Error} error
     */
    rethrowIfNotStoppingThePool(error) {
        if (this.isStoppingThePoolError(error)) {
            return;
        }
        throw error;
    }
    /**
     * Create and save an error for the the given `item`.
     *
     * @param {T} item
     */
    saveErrorFor(error, item) {
        this.errors().push(promise_pool_error_1.PromisePoolError.createFrom(error, item));
    }
    /**
     * Wait for all active tasks to finish. Once all the tasks finished
     * processing, returns an object containing the results and errors.
     *
     * @returns {Object}
     */
    async drained() {
        await this.drainActiveTasks();
        return {
            errors: this.errors(),
            results: this.results()
        };
    }
    /**
     * Wait for all of the active tasks to finish processing.
     */
    async drainActiveTasks() {
        await Promise.all(this.tasks());
    }
}
exports.PromisePoolExecutor = PromisePoolExecutor;


/***/ }),

/***/ 8941:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromisePool = void 0;
const promise_pool_executor_1 = __nccwpck_require__(6331);
class PromisePool {
    /**
     * Instantiates a new promise pool with a default `concurrency: 10` and `items: []`.
     *
     * @param {Object} options
     */
    constructor(items) {
        this.concurrency = 10;
        this.items = items !== null && items !== void 0 ? items : [];
        this.errorHandler = undefined;
        this.onTaskStartedHandlers = [];
        this.onTaskFinishedHandlers = [];
    }
    /**
     * Set the number of tasks to process concurrently in the promise pool.
     *
     * @param {Integer} concurrency
     *
     * @returns {PromisePool}
     */
    withConcurrency(concurrency) {
        this.concurrency = concurrency;
        return this;
    }
    /**
     * Set the number of tasks to process concurrently in the promise pool.
     *
     * @param {Number} concurrency
     *
     * @returns {PromisePool}
     */
    static withConcurrency(concurrency) {
        return new this().withConcurrency(concurrency);
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {T[]} items
     *
     * @returns {PromisePool}
     */
    for(items) {
        return new PromisePool(items).withConcurrency(this.concurrency);
    }
    /**
     * Set the items to be processed in the promise pool.
     *
     * @param {T[]} items
     *
     * @returns {PromisePool}
     */
    static for(items) {
        return new this().for(items);
    }
    /**
     * Set the error handler function to execute when an error occurs.
     *
     * @param {ErrorHandler<T>} handler
     *
     * @returns {PromisePool}
     */
    handleError(handler) {
        this.errorHandler = handler;
        return this;
    }
    /**
     * Assign the given callback `handler` function to run when a task starts.
     *
     * @param {OnProgressCallback<T>} handler
     *
     * @returns {PromisePool}
     */
    onTaskStarted(handler) {
        this.onTaskStartedHandlers.push(handler);
        return this;
    }
    /**
      * Assign the given callback `handler` function to run when a task finished.
      *
      * @param {OnProgressCallback<T>} handler
      *
      * @returns {PromisePool}
      */
    onTaskFinished(handler) {
        this.onTaskFinishedHandlers.push(handler);
        return this;
    }
    /**
     * Starts processing the promise pool by iterating over the items
     * and running each item through the async `callback` function.
     *
     * @param {ProcessHandler} The async processing function receiving each item from the `items` array.
     *
     * @returns Promise<{ results, errors }>
     */
    async process(callback) {
        return new promise_pool_executor_1.PromisePoolExecutor()
            .useConcurrency(this.concurrency)
            .withHandler(callback)
            .handleError(this.errorHandler)
            .onTaskStarted(this.onTaskStartedHandlers)
            .onTaskFinished(this.onTaskFinishedHandlers)
            .for(this.items)
            .start();
    }
}
exports.PromisePool = PromisePool;


/***/ }),

/***/ 4983:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StopThePromisePoolError = void 0;
class StopThePromisePoolError extends Error {
}
exports.StopThePromisePoolError = StopThePromisePoolError;


/***/ }),

/***/ 9657:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValidationError = void 0;
class ValidationError extends Error {
    /**
     * Create a new instance for the given `message`.
     *
     * @param message  The error message
     */
    constructor(message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
    }
    /**
     * Returns a validation error with the given `message`.
     */
    static createFrom(message) {
        return new this(message);
    }
}
exports.ValidationError = ValidationError;


/***/ }),

/***/ 8097:
/***/ ((module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const defer_to_connect_1 = __nccwpck_require__(6214);
const util_1 = __nccwpck_require__(3837);
const nodejsMajorVersion = Number(process.versions.node.split('.')[0]);
const timer = (request) => {
    if (request.timings) {
        return request.timings;
    }
    const timings = {
        start: Date.now(),
        socket: undefined,
        lookup: undefined,
        connect: undefined,
        secureConnect: undefined,
        upload: undefined,
        response: undefined,
        end: undefined,
        error: undefined,
        abort: undefined,
        phases: {
            wait: undefined,
            dns: undefined,
            tcp: undefined,
            tls: undefined,
            request: undefined,
            firstByte: undefined,
            download: undefined,
            total: undefined
        }
    };
    request.timings = timings;
    const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
            // Catches the `error` event
            if (event === 'error') {
                timings.error = Date.now();
                timings.phases.total = timings.error - timings.start;
                origin.emit = emit;
            }
            // Saves the original behavior
            return emit(event, ...args);
        };
    };
    handleError(request);
    const onAbort = () => {
        timings.abort = Date.now();
        // Let the `end` response event be responsible for setting the total phase,
        // unless the Node.js major version is >= 13.
        if (!timings.response || nodejsMajorVersion >= 13) {
            timings.phases.total = Date.now() - timings.start;
        }
    };
    request.prependOnceListener('abort', onAbort);
    const onSocket = (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        if (util_1.types.isProxy(socket)) {
            return;
        }
        const lookupListener = () => {
            timings.lookup = Date.now();
            timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.prependOnceListener('lookup', lookupListener);
        defer_to_connect_1.default(socket, {
            connect: () => {
                timings.connect = Date.now();
                if (timings.lookup === undefined) {
                    socket.removeListener('lookup', lookupListener);
                    timings.lookup = timings.connect;
                    timings.phases.dns = timings.lookup - timings.socket;
                }
                timings.phases.tcp = timings.connect - timings.lookup;
                // This callback is called before flushing any data,
                // so we don't need to set `timings.phases.request` here.
            },
            secureConnect: () => {
                timings.secureConnect = Date.now();
                timings.phases.tls = timings.secureConnect - timings.connect;
            }
        });
    };
    if (request.socket) {
        onSocket(request.socket);
    }
    else {
        request.prependOnceListener('socket', onSocket);
    }
    const onUpload = () => {
        var _a;
        timings.upload = Date.now();
        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);
    };
    const writableFinished = () => {
        if (typeof request.writableFinished === 'boolean') {
            return request.writableFinished;
        }
        // Node.js doesn't have `request.writableFinished` property
        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);
    };
    if (writableFinished()) {
        onUpload();
    }
    else {
        request.prependOnceListener('finish', onUpload);
    }
    request.prependOnceListener('response', (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        response.timings = timings;
        handleError(response);
        response.prependOnceListener('end', () => {
            timings.end = Date.now();
            timings.phases.download = timings.end - timings.response;
            timings.phases.total = timings.end - timings.start;
        });
        response.prependOnceListener('aborted', onAbort);
    });
    return timings;
};
exports["default"] = timer;
// For CommonJS default export support
module.exports = timer;
module.exports["default"] = timer;


/***/ }),

/***/ 4812:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports =
{
  parallel      : __nccwpck_require__(8210),
  serial        : __nccwpck_require__(445),
  serialOrdered : __nccwpck_require__(3578)
};


/***/ }),

/***/ 1700:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 2794:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var defer = __nccwpck_require__(8737);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 8737:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 9023:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var async = __nccwpck_require__(2794)
  , abort = __nccwpck_require__(1700)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 2474:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 7942:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var abort = __nccwpck_require__(1700)
  , async = __nccwpck_require__(2794)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 8210:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(9023)
  , initState  = __nccwpck_require__(2474)
  , terminator = __nccwpck_require__(7942)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 445:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var serialOrdered = __nccwpck_require__(3578);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 3578:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var iterate    = __nccwpck_require__(9023)
  , initState  = __nccwpck_require__(2474)
  , terminator = __nccwpck_require__(7942)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 9417:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3717:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var concatMap = __nccwpck_require__(6891);
var balanced = __nccwpck_require__(9417);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 610:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(8750);
const compile = __nccwpck_require__(9434);
const expand = __nccwpck_require__(5873);
const parse = __nccwpck_require__(6477);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),

/***/ 9434:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const utils = __nccwpck_require__(5207);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),

/***/ 8774:
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),

/***/ 5873:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const fill = __nccwpck_require__(6330);
const stringify = __nccwpck_require__(8750);
const utils = __nccwpck_require__(5207);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),

/***/ 6477:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const stringify = __nccwpck_require__(8750);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __nccwpck_require__(8774);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),

/***/ 8750:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(5207);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),

/***/ 5207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),

/***/ 2286:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {
	V4MAPPED,
	ADDRCONFIG,
	ALL,
	promises: {
		Resolver: AsyncResolver
	},
	lookup: dnsLookup
} = __nccwpck_require__(9523);
const {promisify} = __nccwpck_require__(3837);
const os = __nccwpck_require__(2037);

const kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');
const kCacheableLookupInstance = Symbol('cacheableLookupInstance');
const kExpires = Symbol('expires');

const supportsALL = typeof ALL === 'number';

const verifyAgent = agent => {
	if (!(agent && typeof agent.createConnection === 'function')) {
		throw new Error('Expected an Agent instance as the first argument');
	}
};

const map4to6 = entries => {
	for (const entry of entries) {
		if (entry.family === 6) {
			continue;
		}

		entry.address = `::ffff:${entry.address}`;
		entry.family = 6;
	}
};

const getIfaceInfo = () => {
	let has4 = false;
	let has6 = false;

	for (const device of Object.values(os.networkInterfaces())) {
		for (const iface of device) {
			if (iface.internal) {
				continue;
			}

			if (iface.family === 'IPv6') {
				has6 = true;
			} else {
				has4 = true;
			}

			if (has4 && has6) {
				return {has4, has6};
			}
		}
	}

	return {has4, has6};
};

const isIterable = map => {
	return Symbol.iterator in map;
};

const ttl = {ttl: true};
const all = {all: true};

class CacheableLookup {
	constructor({
		cache = new Map(),
		maxTtl = Infinity,
		fallbackDuration = 3600,
		errorTtl = 0.15,
		resolver = new AsyncResolver(),
		lookup = dnsLookup
	} = {}) {
		this.maxTtl = maxTtl;
		this.errorTtl = errorTtl;

		this._cache = cache;
		this._resolver = resolver;
		this._dnsLookup = promisify(lookup);

		if (this._resolver instanceof AsyncResolver) {
			this._resolve4 = this._resolver.resolve4.bind(this._resolver);
			this._resolve6 = this._resolver.resolve6.bind(this._resolver);
		} else {
			this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));
			this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));
		}

		this._iface = getIfaceInfo();

		this._pending = {};
		this._nextRemovalTime = false;
		this._hostnamesToFallback = new Set();

		if (fallbackDuration < 1) {
			this._fallback = false;
		} else {
			this._fallback = true;

			const interval = setInterval(() => {
				this._hostnamesToFallback.clear();
			}, fallbackDuration * 1000);

			/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */
			if (interval.unref) {
				interval.unref();
			}
		}

		this.lookup = this.lookup.bind(this);
		this.lookupAsync = this.lookupAsync.bind(this);
	}

	set servers(servers) {
		this.clear();

		this._resolver.setServers(servers);
	}

	get servers() {
		return this._resolver.getServers();
	}

	lookup(hostname, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		} else if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		if (!callback) {
			throw new Error('Callback must be a function.');
		}

		// eslint-disable-next-line promise/prefer-await-to-then
		this.lookupAsync(hostname, options).then(result => {
			if (options.all) {
				callback(null, result);
			} else {
				callback(null, result.address, result.family, result.expires, result.ttl);
			}
		}, callback);
	}

	async lookupAsync(hostname, options = {}) {
		if (typeof options === 'number') {
			options = {
				family: options
			};
		}

		let cached = await this.query(hostname);

		if (options.family === 6) {
			const filtered = cached.filter(entry => entry.family === 6);

			if (options.hints & V4MAPPED) {
				if ((supportsALL && options.hints & ALL) || filtered.length === 0) {
					map4to6(cached);
				} else {
					cached = filtered;
				}
			} else {
				cached = filtered;
			}
		} else if (options.family === 4) {
			cached = cached.filter(entry => entry.family === 4);
		}

		if (options.hints & ADDRCONFIG) {
			const {_iface} = this;
			cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);
		}

		if (cached.length === 0) {
			const error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
			error.code = 'ENOTFOUND';
			error.hostname = hostname;

			throw error;
		}

		if (options.all) {
			return cached;
		}

		return cached[0];
	}

	async query(hostname) {
		let cached = await this._cache.get(hostname);

		if (!cached) {
			const pending = this._pending[hostname];

			if (pending) {
				cached = await pending;
			} else {
				const newPromise = this.queryAndCache(hostname);
				this._pending[hostname] = newPromise;

				try {
					cached = await newPromise;
				} finally {
					delete this._pending[hostname];
				}
			}
		}

		cached = cached.map(entry => {
			return {...entry};
		});

		return cached;
	}

	async _resolve(hostname) {
		const wrap = async promise => {
			try {
				return await promise;
			} catch (error) {
				if (error.code === 'ENODATA' || error.code === 'ENOTFOUND') {
					return [];
				}

				throw error;
			}
		};

		// ANY is unsafe as it doesn't trigger new queries in the underlying server.
		const [A, AAAA] = await Promise.all([
			this._resolve4(hostname, ttl),
			this._resolve6(hostname, ttl)
		].map(promise => wrap(promise)));

		let aTtl = 0;
		let aaaaTtl = 0;
		let cacheTtl = 0;

		const now = Date.now();

		for (const entry of A) {
			entry.family = 4;
			entry.expires = now + (entry.ttl * 1000);

			aTtl = Math.max(aTtl, entry.ttl);
		}

		for (const entry of AAAA) {
			entry.family = 6;
			entry.expires = now + (entry.ttl * 1000);

			aaaaTtl = Math.max(aaaaTtl, entry.ttl);
		}

		if (A.length > 0) {
			if (AAAA.length > 0) {
				cacheTtl = Math.min(aTtl, aaaaTtl);
			} else {
				cacheTtl = aTtl;
			}
		} else {
			cacheTtl = aaaaTtl;
		}

		return {
			entries: [
				...A,
				...AAAA
			],
			cacheTtl
		};
	}

	async _lookup(hostname) {
		try {
			const entries = await this._dnsLookup(hostname, {
				all: true
			});

			return {
				entries,
				cacheTtl: 0
			};
		} catch (_) {
			return {
				entries: [],
				cacheTtl: 0
			};
		}
	}

	async _set(hostname, data, cacheTtl) {
		if (this.maxTtl > 0 && cacheTtl > 0) {
			cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;
			data[kExpires] = Date.now() + cacheTtl;

			try {
				await this._cache.set(hostname, data, cacheTtl);
			} catch (error) {
				this.lookupAsync = async () => {
					const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');
					cacheError.cause = error;

					throw cacheError;
				};
			}

			if (isIterable(this._cache)) {
				this._tick(cacheTtl);
			}
		}
	}

	async queryAndCache(hostname) {
		if (this._hostnamesToFallback.has(hostname)) {
			return this._dnsLookup(hostname, all);
		}

		let query = await this._resolve(hostname);

		if (query.entries.length === 0 && this._fallback) {
			query = await this._lookup(hostname);

			if (query.entries.length !== 0) {
				// Use `dns.lookup(...)` for that particular hostname
				this._hostnamesToFallback.add(hostname);
			}
		}

		const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
		await this._set(hostname, query.entries, cacheTtl);

		return query.entries;
	}

	_tick(ms) {
		const nextRemovalTime = this._nextRemovalTime;

		if (!nextRemovalTime || ms < nextRemovalTime) {
			clearTimeout(this._removalTimeout);

			this._nextRemovalTime = ms;

			this._removalTimeout = setTimeout(() => {
				this._nextRemovalTime = false;

				let nextExpiry = Infinity;

				const now = Date.now();

				for (const [hostname, entries] of this._cache) {
					const expires = entries[kExpires];

					if (now >= expires) {
						this._cache.delete(hostname);
					} else if (expires < nextExpiry) {
						nextExpiry = expires;
					}
				}

				if (nextExpiry !== Infinity) {
					this._tick(nextExpiry - now);
				}
			}, ms);

			/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */
			if (this._removalTimeout.unref) {
				this._removalTimeout.unref();
			}
		}
	}

	install(agent) {
		verifyAgent(agent);

		if (kCacheableLookupCreateConnection in agent) {
			throw new Error('CacheableLookup has been already installed');
		}

		agent[kCacheableLookupCreateConnection] = agent.createConnection;
		agent[kCacheableLookupInstance] = this;

		agent.createConnection = (options, callback) => {
			if (!('lookup' in options)) {
				options.lookup = this.lookup;
			}

			return agent[kCacheableLookupCreateConnection](options, callback);
		};
	}

	uninstall(agent) {
		verifyAgent(agent);

		if (agent[kCacheableLookupCreateConnection]) {
			if (agent[kCacheableLookupInstance] !== this) {
				throw new Error('The agent is not owned by this CacheableLookup instance');
			}

			agent.createConnection = agent[kCacheableLookupCreateConnection];

			delete agent[kCacheableLookupCreateConnection];
			delete agent[kCacheableLookupInstance];
		}
	}

	updateInterfaceInfo() {
		const {_iface} = this;

		this._iface = getIfaceInfo();

		if ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {
			this._cache.clear();
		}
	}

	clear(hostname) {
		if (hostname) {
			this._cache.delete(hostname);
			return;
		}

		this._cache.clear();
	}
}

module.exports = CacheableLookup;
module.exports["default"] = CacheableLookup;


/***/ }),

/***/ 4340:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __nccwpck_require__(2781);

module.exports = options => {
	options = {...options};

	const {array} = options;
	let {encoding} = options;
	const isBuffer = encoding === 'buffer';
	let objectMode = false;

	if (array) {
		objectMode = !(encoding || isBuffer);
	} else {
		encoding = encoding || 'utf8';
	}

	if (isBuffer) {
		encoding = null;
	}

	const stream = new PassThroughStream({objectMode});

	if (encoding) {
		stream.setEncoding(encoding);
	}

	let length = 0;
	const chunks = [];

	stream.on('data', chunk => {
		chunks.push(chunk);

		if (objectMode) {
			length = chunks.length;
		} else {
			length += chunk.length;
		}
	});

	stream.getBufferedValue = () => {
		if (array) {
			return chunks;
		}

		return isBuffer ? Buffer.concat(chunks, length) : chunks.join('');
	};

	stream.getBufferedLength = () => length;

	return stream;
};


/***/ }),

/***/ 7040:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {constants: BufferConstants} = __nccwpck_require__(4300);
const pump = __nccwpck_require__(8341);
const bufferStream = __nccwpck_require__(4340);

class MaxBufferError extends Error {
	constructor() {
		super('maxBuffer exceeded');
		this.name = 'MaxBufferError';
	}
}

async function getStream(inputStream, options) {
	if (!inputStream) {
		return Promise.reject(new Error('Expected a stream'));
	}

	options = {
		maxBuffer: Infinity,
		...options
	};

	const {maxBuffer} = options;

	let stream;
	await new Promise((resolve, reject) => {
		const rejectPromise = error => {
			// Don't retrieve an oversized buffer.
			if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
				error.bufferedData = stream.getBufferedValue();
			}

			reject(error);
		};

		stream = pump(inputStream, bufferStream(options), error => {
			if (error) {
				rejectPromise(error);
				return;
			}

			resolve();
		});

		stream.on('data', () => {
			if (stream.getBufferedLength() > maxBuffer) {
				rejectPromise(new MaxBufferError());
			}
		});
	});

	return stream.getBufferedValue();
}

module.exports = getStream;
// TODO: Remove this for the next major release
module.exports["default"] = getStream;
module.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});
module.exports.array = (stream, options) => getStream(stream, {...options, array: true});
module.exports.MaxBufferError = MaxBufferError;


/***/ }),

/***/ 8116:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(2361);
const urlLib = __nccwpck_require__(7310);
const normalizeUrl = __nccwpck_require__(7952);
const getStream = __nccwpck_require__(7040);
const CachePolicy = __nccwpck_require__(1002);
const Response = __nccwpck_require__(9004);
const lowercaseKeys = __nccwpck_require__(9662);
const cloneResponse = __nccwpck_require__(2430);
const Keyv = __nccwpck_require__(1531);

class CacheableRequest {
	constructor(request, cacheAdapter) {
		if (typeof request !== 'function') {
			throw new TypeError('Parameter `request` must be a function');
		}

		this.cache = new Keyv({
			uri: typeof cacheAdapter === 'string' && cacheAdapter,
			store: typeof cacheAdapter !== 'string' && cacheAdapter,
			namespace: 'cacheable-request'
		});

		return this.createCacheableRequest(request);
	}

	createCacheableRequest(request) {
		return (opts, cb) => {
			let url;
			if (typeof opts === 'string') {
				url = normalizeUrlObject(urlLib.parse(opts));
				opts = {};
			} else if (opts instanceof urlLib.URL) {
				url = normalizeUrlObject(urlLib.parse(opts.toString()));
				opts = {};
			} else {
				const [pathname, ...searchParts] = (opts.path || '').split('?');
				const search = searchParts.length > 0 ?
					`?${searchParts.join('?')}` :
					'';
				url = normalizeUrlObject({ ...opts, pathname, search });
			}

			opts = {
				headers: {},
				method: 'GET',
				cache: true,
				strictTtl: false,
				automaticFailover: false,
				...opts,
				...urlObjectToRequestOptions(url)
			};
			opts.headers = lowercaseKeys(opts.headers);

			const ee = new EventEmitter();
			const normalizedUrlString = normalizeUrl(
				urlLib.format(url),
				{
					stripWWW: false,
					removeTrailingSlash: false,
					stripAuthentication: false
				}
			);
			const key = `${opts.method}:${normalizedUrlString}`;
			let revalidate = false;
			let madeRequest = false;

			const makeRequest = opts => {
				madeRequest = true;
				let requestErrored = false;
				let requestErrorCallback;

				const requestErrorPromise = new Promise(resolve => {
					requestErrorCallback = () => {
						if (!requestErrored) {
							requestErrored = true;
							resolve();
						}
					};
				});

				const handler = response => {
					if (revalidate && !opts.forceRefresh) {
						response.status = response.statusCode;
						const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);
						if (!revalidatedPolicy.modified) {
							const headers = revalidatedPolicy.policy.responseHeaders();
							response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
							response.cachePolicy = revalidatedPolicy.policy;
							response.fromCache = true;
						}
					}

					if (!response.fromCache) {
						response.cachePolicy = new CachePolicy(opts, response, opts);
						response.fromCache = false;
					}

					let clonedResponse;
					if (opts.cache && response.cachePolicy.storable()) {
						clonedResponse = cloneResponse(response);

						(async () => {
							try {
								const bodyPromise = getStream.buffer(response);

								await Promise.race([
									requestErrorPromise,
									new Promise(resolve => response.once('end', resolve))
								]);

								if (requestErrored) {
									return;
								}

								const body = await bodyPromise;

								const value = {
									cachePolicy: response.cachePolicy.toObject(),
									url: response.url,
									statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
									body
								};

								let ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;
								if (opts.maxTtl) {
									ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;
								}

								await this.cache.set(key, value, ttl);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					} else if (opts.cache && revalidate) {
						(async () => {
							try {
								await this.cache.delete(key);
							} catch (error) {
								ee.emit('error', new CacheableRequest.CacheError(error));
							}
						})();
					}

					ee.emit('response', clonedResponse || response);
					if (typeof cb === 'function') {
						cb(clonedResponse || response);
					}
				};

				try {
					const req = request(opts, handler);
					req.once('error', requestErrorCallback);
					req.once('abort', requestErrorCallback);
					ee.emit('request', req);
				} catch (error) {
					ee.emit('error', new CacheableRequest.RequestError(error));
				}
			};

			(async () => {
				const get = async opts => {
					await Promise.resolve();

					const cacheEntry = opts.cache ? await this.cache.get(key) : undefined;
					if (typeof cacheEntry === 'undefined') {
						return makeRequest(opts);
					}

					const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
					if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {
						const headers = policy.responseHeaders();
						const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
						response.cachePolicy = policy;
						response.fromCache = true;

						ee.emit('response', response);
						if (typeof cb === 'function') {
							cb(response);
						}
					} else {
						revalidate = cacheEntry;
						opts.headers = policy.revalidationHeaders(opts);
						makeRequest(opts);
					}
				};

				const errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));
				this.cache.once('error', errorHandler);
				ee.on('response', () => this.cache.removeListener('error', errorHandler));

				try {
					await get(opts);
				} catch (error) {
					if (opts.automaticFailover && !madeRequest) {
						makeRequest(opts);
					}

					ee.emit('error', new CacheableRequest.CacheError(error));
				}
			})();

			return ee;
		};
	}
}

function urlObjectToRequestOptions(url) {
	const options = { ...url };
	options.path = `${url.pathname || '/'}${url.search || ''}`;
	delete options.pathname;
	delete options.search;
	return options;
}

function normalizeUrlObject(url) {
	// If url was parsed by url.parse or new URL:
	// - hostname will be set
	// - host will be hostname[:port]
	// - port will be set if it was explicit in the parsed string
	// Otherwise, url was from request options:
	// - hostname or host may be set
	// - host shall not have port encoded
	return {
		protocol: url.protocol,
		auth: url.auth,
		hostname: url.hostname || url.host || 'localhost',
		port: url.port,
		pathname: url.pathname,
		search: url.search
	};
}

CacheableRequest.RequestError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'RequestError';
		Object.assign(this, error);
	}
};

CacheableRequest.CacheError = class extends Error {
	constructor(error) {
		super(error.message);
		this.name = 'CacheError';
		Object.assign(this, error);
	}
};

module.exports = CacheableRequest;


/***/ }),

/***/ 2430:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const PassThrough = (__nccwpck_require__(2781).PassThrough);
const mimicResponse = __nccwpck_require__(2610);

const cloneResponse = response => {
	if (!(response && response.pipe)) {
		throw new TypeError('Parameter `response` must be a response stream.');
	}

	const clone = new PassThrough();
	mimicResponse(response, clone);

	return response.pipe(clone);
};

module.exports = cloneResponse;


/***/ }),

/***/ 5443:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var util = __nccwpck_require__(3837);
var Stream = (__nccwpck_require__(2781).Stream);
var DelayedStream = __nccwpck_require__(8611);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 5728:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const { promisify } = __nccwpck_require__(3837)
const JSONB = __nccwpck_require__(2820)
const zlib = __nccwpck_require__(9796)

const mergeOptions = __nccwpck_require__(4968)

const compress = promisify(zlib.brotliCompress)

const decompress = promisify(zlib.brotliDecompress)

const identity = val => val

const createCompress = ({
  enable = true,
  serialize = JSONB.stringify,
  deserialize = JSONB.parse,
  compressOptions,
  decompressOptions
} = {}) => {
  if (!enable) {
    return { serialize, deserialize, decompress: identity, compress: identity }
  }

  return {
    serialize,
    deserialize,
    compress: async (data, options = {}) => {
      if (data === undefined) return data
      const serializedData = serialize(data)
      return compress(serializedData, mergeOptions(compressOptions, options))
    },
    decompress: async (data, options = {}) => {
      if (data === undefined) return data
      return deserialize(
        await decompress(data, mergeOptions(decompressOptions, options))
      )
    }
  }
}

module.exports = createCompress
module.exports.stringify = JSONB.stringify
module.exports.parse = JSONB.parse


/***/ }),

/***/ 4968:
/***/ ((module) => {

"use strict";


module.exports = (defaultOptions = {}, options = {}) => {
  const params = {
    ...(defaultOptions.params || {}),
    ...(options.params || {})
  }

  return {
    ...defaultOptions,
    ...options,
    ...(Object.keys(params).length
      ? {
          params
        }
      : {})
  }
}


/***/ }),

/***/ 6891:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 2391:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {Transform, PassThrough} = __nccwpck_require__(2781);
const zlib = __nccwpck_require__(9796);
const mimicResponse = __nccwpck_require__(3877);

module.exports = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	// TODO: Remove this when targeting Node.js 12.
	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		response.destroy(new Error('Brotli is not supported on Node.js < 12'));
		return response;
	}

	let isEmpty = true;

	const checker = new Transform({
		transform(data, _encoding, callback) {
			isEmpty = false;

			callback(null, data);
		},

		flush(callback) {
			callback();
		}
	});

	const finalStream = new PassThrough({
		autoDestroy: false,
		destroy(error, callback) {
			response.destroy();

			callback(error);
		}
	});

	const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();

	decompressStream.once('error', error => {
		if (isEmpty && !response.readable) {
			finalStream.end();
			return;
		}

		finalStream.destroy(error);
	});

	mimicResponse(response, finalStream);
	response.pipe(checker).pipe(decompressStream).pipe(finalStream);

	return finalStream;
};


/***/ }),

/***/ 3877:
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

module.exports = (fromStream, toStream) => {
	if (toStream._readableState.autoDestroy) {
		throw new Error('The second stream must have the `autoDestroy` option set to `false`');
	}

	const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));

	const properties = {};

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		properties[property] = {
			get() {
				const value = fromStream[property];
				const isFunction = typeof value === 'function';

				return isFunction ? value.bind(fromStream) : value;
			},
			set(value) {
				fromStream[property] = value;
			},
			enumerable: true,
			configurable: false
		};
	}

	Object.defineProperties(toStream, properties);

	fromStream.once('aborted', () => {
		toStream.destroy();

		toStream.emit('aborted');
	});

	fromStream.once('close', () => {
		if (fromStream.complete) {
			if (toStream.readable) {
				toStream.once('end', () => {
					toStream.emit('close');
				});
			} else {
				toStream.emit('close');
			}
		} else {
			toStream.emit('close');
		}
	});

	return toStream;
};


/***/ }),

/***/ 6214:
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isTLSSocket(socket) {
    return socket.encrypted;
}
const deferToConnect = (socket, fn) => {
    let listeners;
    if (typeof fn === 'function') {
        const connect = fn;
        listeners = { connect };
    }
    else {
        listeners = fn;
    }
    const hasConnectListener = typeof listeners.connect === 'function';
    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';
    const hasCloseListener = typeof listeners.close === 'function';
    const onConnect = () => {
        if (hasConnectListener) {
            listeners.connect();
        }
        if (isTLSSocket(socket) && hasSecureConnectListener) {
            if (socket.authorized) {
                listeners.secureConnect();
            }
            else if (!socket.authorizationError) {
                socket.once('secureConnect', listeners.secureConnect);
            }
        }
        if (hasCloseListener) {
            socket.once('close', listeners.close);
        }
    };
    if (socket.writable && !socket.connecting) {
        onConnect();
    }
    else if (socket.connecting) {
        socket.once('connect', onConnect);
    }
    else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
    }
};
exports["default"] = deferToConnect;
// For CommonJS default export support
module.exports = deferToConnect;
module.exports["default"] = deferToConnect;


/***/ }),

/***/ 8611:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var Stream = (__nccwpck_require__(2781).Stream);
var util = __nccwpck_require__(3837);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 1205:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var once = __nccwpck_require__(1223);

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ 4460:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var isGlob = __nccwpck_require__(4466);
var pathPosixDirname = (__nccwpck_require__(1017).posix.dirname);
var isWin32 = (__nccwpck_require__(2037).platform)() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),

/***/ 3664:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const taskManager = __nccwpck_require__(2708);
const patternManager = __nccwpck_require__(8306);
const async_1 = __nccwpck_require__(5679);
const stream_1 = __nccwpck_require__(4630);
const sync_1 = __nccwpck_require__(2405);
const settings_1 = __nccwpck_require__(952);
const utils = __nccwpck_require__(5444);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = patternManager.transform([].concat(source));
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),

/***/ 8306:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeDuplicateSlashes = exports.transform = void 0;
/**
 * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
 * The latter is due to the presence of the device path at the beginning of the UNC path.
 * @todo rewrite to negative lookbehind with the next major release.
 */
const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
function transform(patterns) {
    return patterns.map((pattern) => removeDuplicateSlashes(pattern));
}
exports.transform = transform;
/**
 * This package only works with forward slashes as a path separator.
 * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
 */
function removeDuplicateSlashes(pattern) {
    return pattern.replace(DOUBLE_SLASH_RE, '/');
}
exports.removeDuplicateSlashes = removeDuplicateSlashes;


/***/ }),

/***/ 2708:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
const utils = __nccwpck_require__(5444);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
/**
 * Returns tasks grouped by basic pattern directories.
 *
 * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
 * This is necessary because directory traversal starts at the base directory and goes deeper.
 */
function convertPatternsToTasks(positive, negative, dynamic) {
    const tasks = [];
    const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
    const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
    const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
    const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
    tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
    /*
     * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
     * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
     */
    if ('.' in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));
    }
    else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
    }
    return tasks;
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),

/***/ 5679:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2083);
const provider_1 = __nccwpck_require__(257);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderAsync;


/***/ }),

/***/ 6983:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
const partial_1 = __nccwpck_require__(5295);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
    }
}
exports["default"] = DeepFilter;


/***/ }),

/***/ 1343:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
    }
    /**
     * First, just trying to apply patterns to the path.
     * Second, trying to apply patterns to the path with final slash.
     */
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + '/', patternsRe);
    }
}
exports["default"] = EntryFilter;


/***/ }),

/***/ 6654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports["default"] = ErrorFilter;


/***/ }),

/***/ 2576:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports["default"] = Matcher;


/***/ }),

/***/ 5295:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __nccwpck_require__(2576);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports["default"] = PartialMatcher;


/***/ }),

/***/ 257:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(1017);
const deep_1 = __nccwpck_require__(6983);
const entry_1 = __nccwpck_require__(1343);
const error_1 = __nccwpck_require__(6654);
const entry_2 = __nccwpck_require__(4029);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports["default"] = Provider;


/***/ }),

/***/ 4630:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2781);
const stream_2 = __nccwpck_require__(2083);
const provider_1 = __nccwpck_require__(257);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderStream;


/***/ }),

/***/ 2405:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __nccwpck_require__(6234);
const provider_1 = __nccwpck_require__(257);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports["default"] = ProviderSync;


/***/ }),

/***/ 4029:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __nccwpck_require__(5444);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports["default"] = EntryTransformer;


/***/ }),

/***/ 5582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __nccwpck_require__(1017);
const fsStat = __nccwpck_require__(109);
const utils = __nccwpck_require__(5444);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports["default"] = Reader;


/***/ }),

/***/ 2083:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __nccwpck_require__(2781);
const fsStat = __nccwpck_require__(109);
const fsWalk = __nccwpck_require__(6026);
const reader_1 = __nccwpck_require__(5582);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports["default"] = ReaderStream;


/***/ }),

/***/ 6234:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __nccwpck_require__(109);
const fsWalk = __nccwpck_require__(6026);
const reader_1 = __nccwpck_require__(5582);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports["default"] = ReaderSync;


/***/ }),

/***/ 952:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = __nccwpck_require__(7147);
const os = __nccwpck_require__(2037);
/**
 * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
 * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
 */
const CPU_COUNT = Math.max(os.cpus().length, 1);
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports["default"] = Settings;


/***/ }),

/***/ 5325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitWhen = exports.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),

/***/ 1230:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),

/***/ 7543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),

/***/ 5444:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
const array = __nccwpck_require__(5325);
exports.array = array;
const errno = __nccwpck_require__(1230);
exports.errno = errno;
const fs = __nccwpck_require__(7543);
exports.fs = fs;
const path = __nccwpck_require__(3873);
exports.path = path;
const pattern = __nccwpck_require__(1221);
exports.pattern = pattern;
const stream = __nccwpck_require__(8382);
exports.stream = stream;
const string = __nccwpck_require__(2203);
exports.string = string;


/***/ }),

/***/ 3873:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
const path = __nccwpck_require__(1017);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),

/***/ 1221:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = __nccwpck_require__(1017);
const globParent = __nccwpck_require__(4460);
const micromatch = __nccwpck_require__(6228);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function hasBraceExpansion(pattern) {
    const openingBraceIndex = pattern.indexOf('{');
    if (openingBraceIndex === -1) {
        return false;
    }
    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);
    if (closingBraceIndex === -1) {
        return false;
    }
    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
/**
 * Returns patterns that can be applied inside the current directory.
 *
 * @example
 * // ['./*', '*', 'a/*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsInsideCurrentDirectory(patterns) {
    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
}
exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
/**
 * Returns patterns to be expanded relative to (outside) the current directory.
 *
 * @example
 * // ['../*', './../*']
 * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
 */
function getPatternsOutsideCurrentDirectory(patterns) {
    return patterns.filter(isPatternRelatedToParentDirectory);
}
exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern) {
    return pattern.startsWith('..') || pattern.startsWith('./..');
}
exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),

/***/ 8382:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.merge = void 0;
const merge2 = __nccwpck_require__(2578);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),

/***/ 2203:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmpty = exports.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),

/***/ 7340:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/* eslint-disable no-var */

var reusify = __nccwpck_require__(2113)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  if (concurrency < 1) {
    throw new Error('fastqueue concurrency must be greater than 1')
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0
  var errorHandler = null

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    getQueue: getQueue,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain,
    error: error
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function getQueue () {
    var current = queueHead
    var tasks = []

    while (current) {
      tasks.push(current.value)
      current = current.next
    }

    return tasks
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop
    current.errorHandler = errorHandler

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }

  function error (handler) {
    errorHandler = handler
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null
  this.errorHandler = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    var errorHandler = self.errorHandler
    var val = self.value
    self.value = null
    self.callback = noop
    if (self.errorHandler) {
      errorHandler(err, val)
    }
    callback.call(self.context, err, result)
    self.release(self)
  }
}

function queueAsPromised (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  function asyncWrapper (arg, cb) {
    worker.call(this, arg)
      .then(function (res) {
        cb(null, res)
      }, cb)
  }

  var queue = fastqueue(context, asyncWrapper, concurrency)

  var pushCb = queue.push
  var unshiftCb = queue.unshift

  queue.push = push
  queue.unshift = unshift
  queue.drained = drained

  return queue

  function push (value) {
    var p = new Promise(function (resolve, reject) {
      pushCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function unshift (value) {
    var p = new Promise(function (resolve, reject) {
      unshiftCb(value, function (err, result) {
        if (err) {
          reject(err)
          return
        }
        resolve(result)
      })
    })

    // Let's fork the promise chain to
    // make the error bubble up to the user but
    // not lead to a unhandledRejection
    p.catch(noop)

    return p
  }

  function drained () {
    var previousDrain = queue.drain

    var p = new Promise(function (resolve) {
      queue.drain = function () {
        previousDrain()
        resolve()
      }
    })

    return p
  }
}

module.exports = fastqueue
module.exports.promise = queueAsPromised


/***/ }),

/***/ 6330:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __nccwpck_require__(3837);
const toRegexRange = __nccwpck_require__(1861);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),

/***/ 4334:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var CombinedStream = __nccwpck_require__(5443);
var util = __nccwpck_require__(3837);
var path = __nccwpck_require__(1017);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var parseUrl = (__nccwpck_require__(7310).parse);
var fs = __nccwpck_require__(7147);
var Stream = (__nccwpck_require__(2781).Stream);
var mime = __nccwpck_require__(3583);
var asynckit = __nccwpck_require__(4812);
var populate = __nccwpck_require__(7142);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (util.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {

  if (value.hasOwnProperty('fd')) {

    // take read range into a account
    // `end` = Infinity â€“> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (value.hasOwnProperty('httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (value.hasOwnProperty('httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header = headers[prop];

    // skip nullish headers.
    if (header == null) {
      continue;
    }

    // convert all headers to arrays.
    if (!Array.isArray(header)) {
      header = [header];
    }

    // add non-empty headers.
    if (header.length) {
      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (userHeaders.hasOwnProperty(header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc( 0 );
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};


/***/ }),

/***/ 7142:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 6457:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __nccwpck_require__(4597);
function createRejection(error, ...beforeErrorGroups) {
    const promise = (async () => {
        if (error instanceof types_1.RequestError) {
            try {
                for (const hooks of beforeErrorGroups) {
                    if (hooks) {
                        for (const hook of hooks) {
                            // eslint-disable-next-line no-await-in-loop
                            error = await hook(error);
                        }
                    }
                }
            }
            catch (error_) {
                error = error_;
            }
        }
        throw error;
    })();
    const returnPromise = () => promise;
    promise.json = returnPromise;
    promise.text = returnPromise;
    promise.buffer = returnPromise;
    promise.on = returnPromise;
    return promise;
}
exports["default"] = createRejection;


/***/ }),

/***/ 6056:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __nccwpck_require__(2361);
const is_1 = __nccwpck_require__(7678);
const PCancelable = __nccwpck_require__(9072);
const types_1 = __nccwpck_require__(4597);
const parse_body_1 = __nccwpck_require__(8220);
const core_1 = __nccwpck_require__(94);
const proxy_events_1 = __nccwpck_require__(3021);
const get_buffer_1 = __nccwpck_require__(4500);
const is_response_ok_1 = __nccwpck_require__(9298);
const proxiedRequestEvents = [
    'request',
    'response',
    'redirect',
    'uploadProgress',
    'downloadProgress'
];
function asPromise(normalizedOptions) {
    let globalRequest;
    let globalResponse;
    const emitter = new events_1.EventEmitter();
    const promise = new PCancelable((resolve, reject, onCancel) => {
        const makeRequest = (retryCount) => {
            const request = new core_1.default(undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            onCancel(() => request.destroy());
            onCancel.shouldReject = false;
            onCancel(() => reject(new types_1.CancelError(request)));
            globalRequest = request;
            request.once('response', async (response) => {
                var _a;
                response.retryCount = retryCount;
                if (response.request.aborted) {
                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error
                    return;
                }
                // Download body
                let rawBody;
                try {
                    rawBody = await get_buffer_1.default(request);
                    response.rawBody = rawBody;
                }
                catch (_b) {
                    // The same error is caught below.
                    // See request.once('error')
                    return;
                }
                if (request._isAboutToError) {
                    return;
                }
                // Parse body
                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();
                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);
                const { options } = request;
                if (isCompressed && !options.decompress) {
                    response.body = rawBody;
                }
                else {
                    try {
                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);
                    }
                    catch (error) {
                        // Fallback to `utf8`
                        response.body = rawBody.toString();
                        if (is_response_ok_1.isResponseOk(response)) {
                            request._beforeError(error);
                            return;
                        }
                    }
                }
                try {
                    for (const [index, hook] of options.hooks.afterResponse.entries()) {
                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise
                        // eslint-disable-next-line no-await-in-loop
                        response = await hook(response, async (updatedOptions) => {
                            const typedOptions = core_1.default.normalizeArguments(undefined, {
                                ...updatedOptions,
                                retry: {
                                    calculateDelay: () => 0
                                },
                                throwHttpErrors: false,
                                resolveBodyOnly: false
                            }, options);
                            // Remove any further hooks for that request, because we'll call them anyway.
                            // The loop continues. We don't want duplicates (asPromise recursion).
                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);
                            for (const hook of typedOptions.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(typedOptions);
                            }
                            const promise = asPromise(typedOptions);
                            onCancel(() => {
                                promise.catch(() => { });
                                promise.cancel();
                            });
                            return promise;
                        });
                    }
                }
                catch (error) {
                    request._beforeError(new types_1.RequestError(error.message, error, request));
                    return;
                }
                globalResponse = response;
                if (!is_response_ok_1.isResponseOk(response)) {
                    request._beforeError(new types_1.HTTPError(response));
                    return;
                }
                resolve(request.options.resolveBodyOnly ? response.body : response);
            });
            const onError = (error) => {
                if (promise.isCanceled) {
                    return;
                }
                const { options } = request;
                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {
                    const { response } = error;
                    resolve(request.options.resolveBodyOnly ? response.body : response);
                    return;
                }
                reject(error);
            };
            request.once('error', onError);
            const previousBody = request.options.body;
            request.once('retry', (newRetryCount, error) => {
                var _a, _b;
                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {
                    onError(error);
                    return;
                }
                makeRequest(newRetryCount);
            });
            proxy_events_1.default(request, emitter, proxiedRequestEvents);
        };
        makeRequest(0);
    });
    promise.on = (event, fn) => {
        emitter.on(event, fn);
        return promise;
    };
    const shortcut = (responseType) => {
        const newPromise = (async () => {
            // Wait until downloading has ended
            await promise;
            const { options } = globalResponse.request;
            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);
        })();
        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));
        return newPromise;
    };
    promise.json = () => {
        const { headers } = globalRequest.options;
        if (!globalRequest.writableFinished && headers.accept === undefined) {
            headers.accept = 'application/json';
        }
        return shortcut('json');
    };
    promise.buffer = () => shortcut('buffer');
    promise.text = () => shortcut('text');
    return promise;
}
exports["default"] = asPromise;
__exportStar(__nccwpck_require__(4597), exports);


/***/ }),

/***/ 1048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __nccwpck_require__(7678);
const normalizeArguments = (options, defaults) => {
    if (is_1.default.null_(options.encoding)) {
        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
    }
    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);
    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);
    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);
    // `options.responseType`
    if (options.responseType === undefined) {
        options.responseType = 'text';
    }
    // `options.retry`
    const { retry } = options;
    if (defaults) {
        options.retry = { ...defaults.retry };
    }
    else {
        options.retry = {
            calculateDelay: retryObject => retryObject.computedValue,
            limit: 0,
            methods: [],
            statusCodes: [],
            errorCodes: [],
            maxRetryAfter: undefined
        };
    }
    if (is_1.default.object(retry)) {
        options.retry = {
            ...options.retry,
            ...retry
        };
        options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];
        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];
        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];
    }
    else if (is_1.default.number(retry)) {
        options.retry.limit = retry;
    }
    if (is_1.default.undefined(options.retry.maxRetryAfter)) {
        options.retry.maxRetryAfter = Math.min(
        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.
        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator
        ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));
    }
    // `options.pagination`
    if (is_1.default.object(options.pagination)) {
        if (defaults) {
            options.pagination = {
                ...defaults.pagination,
                ...options.pagination
            };
        }
        const { pagination } = options;
        if (!is_1.default.function_(pagination.transform)) {
            throw new Error('`options.pagination.transform` must be implemented');
        }
        if (!is_1.default.function_(pagination.shouldContinue)) {
            throw new Error('`options.pagination.shouldContinue` must be implemented');
        }
        if (!is_1.default.function_(pagination.filter)) {
            throw new TypeError('`options.pagination.filter` must be implemented');
        }
        if (!is_1.default.function_(pagination.paginate)) {
            throw new Error('`options.pagination.paginate` must be implemented');
        }
    }
    // JSON mode
    if (options.responseType === 'json' && options.headers.accept === undefined) {
        options.headers.accept = 'application/json';
    }
    return options;
};
exports["default"] = normalizeArguments;


/***/ }),

/***/ 8220:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const types_1 = __nccwpck_require__(4597);
const parseBody = (response, responseType, parseJson, encoding) => {
    const { rawBody } = response;
    try {
        if (responseType === 'text') {
            return rawBody.toString(encoding);
        }
        if (responseType === 'json') {
            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());
        }
        if (responseType === 'buffer') {
            return rawBody;
        }
        throw new types_1.ParseError({
            message: `Unknown body type '${responseType}'`,
            name: 'Error'
        }, response);
    }
    catch (error) {
        throw new types_1.ParseError(error, response);
    }
};
exports["default"] = parseBody;


/***/ }),

/***/ 4597:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancelError = exports.ParseError = void 0;
const core_1 = __nccwpck_require__(94);
/**
An error to be thrown when server response code is 2xx, and parsing body fails.
Includes a `response` property.
*/
class ParseError extends core_1.RequestError {
    constructor(error, response) {
        const { options } = response.request;
        super(`${error.message} in "${options.url.toString()}"`, error, response.request);
        this.name = 'ParseError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_BODY_PARSE_FAILURE' : this.code;
    }
}
exports.ParseError = ParseError;
/**
An error to be thrown when the request is aborted with `.cancel()`.
*/
class CancelError extends core_1.RequestError {
    constructor(request) {
        super('Promise was canceled', {}, request);
        this.name = 'CancelError';
        this.code = 'ERR_CANCELED';
    }
    get isCanceled() {
        return true;
    }
}
exports.CancelError = CancelError;
__exportStar(__nccwpck_require__(94), exports);


/***/ }),

/***/ 3462:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retryAfterStatusCodes = void 0;
exports.retryAfterStatusCodes = new Set([413, 429, 503]);
const calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {
    if (attemptCount > retryOptions.limit) {
        return 0;
    }
    const hasMethod = retryOptions.methods.includes(error.options.method);
    const hasErrorCode = retryOptions.errorCodes.includes(error.code);
    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {
        return 0;
    }
    if (error.response) {
        if (retryAfter) {
            if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {
                return 0;
            }
            return retryAfter;
        }
        if (error.response.statusCode === 413) {
            return 0;
        }
    }
    const noise = Math.random() * 100;
    return ((2 ** (attemptCount - 1)) * 1000) + noise;
};
exports["default"] = calculateRetryDelay;


/***/ }),

/***/ 94:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;
const util_1 = __nccwpck_require__(3837);
const stream_1 = __nccwpck_require__(2781);
const fs_1 = __nccwpck_require__(7147);
const url_1 = __nccwpck_require__(7310);
const http = __nccwpck_require__(3685);
const http_1 = __nccwpck_require__(3685);
const https = __nccwpck_require__(5687);
const http_timer_1 = __nccwpck_require__(8097);
const cacheable_lookup_1 = __nccwpck_require__(2286);
const CacheableRequest = __nccwpck_require__(8116);
const decompressResponse = __nccwpck_require__(2391);
// @ts-expect-error Missing types
const http2wrapper = __nccwpck_require__(4645);
const lowercaseKeys = __nccwpck_require__(9662);
const is_1 = __nccwpck_require__(7678);
const get_body_size_1 = __nccwpck_require__(4564);
const is_form_data_1 = __nccwpck_require__(40);
const proxy_events_1 = __nccwpck_require__(3021);
const timed_out_1 = __nccwpck_require__(2454);
const url_to_options_1 = __nccwpck_require__(8026);
const options_to_url_1 = __nccwpck_require__(9219);
const weakable_map_1 = __nccwpck_require__(7288);
const get_buffer_1 = __nccwpck_require__(4500);
const dns_ip_version_1 = __nccwpck_require__(4993);
const is_response_ok_1 = __nccwpck_require__(9298);
const deprecation_warning_1 = __nccwpck_require__(397);
const normalize_arguments_1 = __nccwpck_require__(1048);
const calculate_retry_delay_1 = __nccwpck_require__(3462);
let globalDnsCache;
const kRequest = Symbol('request');
const kResponse = Symbol('response');
const kResponseSize = Symbol('responseSize');
const kDownloadedSize = Symbol('downloadedSize');
const kBodySize = Symbol('bodySize');
const kUploadedSize = Symbol('uploadedSize');
const kServerResponsesPiped = Symbol('serverResponsesPiped');
const kUnproxyEvents = Symbol('unproxyEvents');
const kIsFromCache = Symbol('isFromCache');
const kCancelTimeouts = Symbol('cancelTimeouts');
const kStartedReading = Symbol('startedReading');
const kStopReading = Symbol('stopReading');
const kTriggerRead = Symbol('triggerRead');
const kBody = Symbol('body');
const kJobs = Symbol('jobs');
const kOriginalResponse = Symbol('originalResponse');
const kRetryTimeout = Symbol('retryTimeout');
exports.kIsNormalizedAlready = Symbol('isNormalizedAlready');
const supportsBrotli = is_1.default.string(process.versions.brotli);
exports.withoutBody = new Set(['GET', 'HEAD']);
exports.knownHookEvents = [
    'init',
    'beforeRequest',
    'beforeRedirect',
    'beforeError',
    'beforeRetry',
    // Promise-Only
    'afterResponse'
];
function validateSearchParameters(searchParameters) {
    // eslint-disable-next-line guard-for-in
    for (const key in searchParameters) {
        const value = searchParameters[key];
        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {
            throw new TypeError(`The \`searchParams\` value '${String(value)}' must be a string, number, boolean or null`);
        }
    }
}
function isClientRequest(clientRequest) {
    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);
}
const cacheableStore = new weakable_map_1.default();
const waitForOpenFile = async (file) => new Promise((resolve, reject) => {
    const onError = (error) => {
        reject(error);
    };
    // Node.js 12 has incomplete types
    if (!file.pending) {
        resolve();
    }
    file.once('error', onError);
    file.once('ready', () => {
        file.off('error', onError);
        resolve();
    });
});
const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
const nonEnumerableProperties = [
    'context',
    'body',
    'json',
    'form'
];
exports.setNonEnumerableProperties = (sources, to) => {
    // Non enumerable properties shall not be merged
    const properties = {};
    for (const source of sources) {
        if (!source) {
            continue;
        }
        for (const name of nonEnumerableProperties) {
            if (!(name in source)) {
                continue;
            }
            properties[name] = {
                writable: true,
                configurable: true,
                enumerable: false,
                // @ts-expect-error TS doesn't see the check above
                value: source[name]
            };
        }
    }
    Object.defineProperties(to, properties);
};
/**
An error to be thrown when a request fails.
Contains a `code` property with error class code, like `ECONNREFUSED`.
*/
class RequestError extends Error {
    constructor(message, error, self) {
        var _a, _b;
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = 'RequestError';
        this.code = (_a = error.code) !== null && _a !== void 0 ? _a : 'ERR_GOT_REQUEST_ERROR';
        if (self instanceof Request) {
            Object.defineProperty(this, 'request', {
                enumerable: false,
                value: self
            });
            Object.defineProperty(this, 'response', {
                enumerable: false,
                value: self[kResponse]
            });
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self.options
            });
        }
        else {
            Object.defineProperty(this, 'options', {
                // This fails because of TS 3.7.2 useDefineForClassFields
                // Ref: https://github.com/microsoft/TypeScript/issues/34972
                enumerable: false,
                value: self
            });
        }
        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;
        // Recover the original stacktrace
        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {
            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;
            const thisStackTrace = this.stack.slice(indexOfMessage).split('\n').reverse();
            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\n').reverse();
            // Remove duplicated traces
            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {
                thisStackTrace.shift();
            }
            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\n')}${errorStackTrace.reverse().join('\n')}`;
        }
    }
}
exports.RequestError = RequestError;
/**
An error to be thrown when the server redirects you more than ten times.
Includes a `response` property.
*/
class MaxRedirectsError extends RequestError {
    constructor(request) {
        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);
        this.name = 'MaxRedirectsError';
        this.code = 'ERR_TOO_MANY_REDIRECTS';
    }
}
exports.MaxRedirectsError = MaxRedirectsError;
/**
An error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.
Includes a `response` property.
*/
class HTTPError extends RequestError {
    constructor(response) {
        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);
        this.name = 'HTTPError';
        this.code = 'ERR_NON_2XX_3XX_RESPONSE';
    }
}
exports.HTTPError = HTTPError;
/**
An error to be thrown when a cache method fails.
For example, if the database goes down or there's a filesystem error.
*/
class CacheError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'CacheError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : this.code;
    }
}
exports.CacheError = CacheError;
/**
An error to be thrown when the request body is a stream and an error occurs while reading from that stream.
*/
class UploadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'UploadError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : this.code;
    }
}
exports.UploadError = UploadError;
/**
An error to be thrown when the request is aborted due to a timeout.
Includes an `event` and `timings` property.
*/
class TimeoutError extends RequestError {
    constructor(error, timings, request) {
        super(error.message, error, request);
        this.name = 'TimeoutError';
        this.event = error.event;
        this.timings = timings;
    }
}
exports.TimeoutError = TimeoutError;
/**
An error to be thrown when reading from response stream fails.
*/
class ReadError extends RequestError {
    constructor(error, request) {
        super(error.message, error, request);
        this.name = 'ReadError';
        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : this.code;
    }
}
exports.ReadError = ReadError;
/**
An error to be thrown when given an unsupported protocol.
*/
class UnsupportedProtocolError extends RequestError {
    constructor(options) {
        super(`Unsupported protocol "${options.url.protocol}"`, {}, options);
        this.name = 'UnsupportedProtocolError';
        this.code = 'ERR_UNSUPPORTED_PROTOCOL';
    }
}
exports.UnsupportedProtocolError = UnsupportedProtocolError;
const proxiedRequestEvents = [
    'socket',
    'connect',
    'continue',
    'information',
    'upgrade',
    'timeout'
];
class Request extends stream_1.Duplex {
    constructor(url, options = {}, defaults) {
        super({
            // This must be false, to enable throwing after destroy
            // It is used for retry logic in Promise API
            autoDestroy: false,
            // It needs to be zero because we're just proxying the data to another stream
            highWaterMark: 0
        });
        this[kDownloadedSize] = 0;
        this[kUploadedSize] = 0;
        this.requestInitialized = false;
        this[kServerResponsesPiped] = new Set();
        this.redirects = [];
        this[kStopReading] = false;
        this[kTriggerRead] = false;
        this[kJobs] = [];
        this.retryCount = 0;
        // TODO: Remove this when targeting Node.js >= 12
        this._progressCallbacks = [];
        const unlockWrite = () => this._unlockWrite();
        const lockWrite = () => this._lockWrite();
        this.on('pipe', (source) => {
            source.prependListener('data', unlockWrite);
            source.on('data', lockWrite);
            source.prependListener('end', unlockWrite);
            source.on('end', lockWrite);
        });
        this.on('unpipe', (source) => {
            source.off('data', unlockWrite);
            source.off('data', lockWrite);
            source.off('end', unlockWrite);
            source.off('end', lockWrite);
        });
        this.on('pipe', source => {
            if (source instanceof http_1.IncomingMessage) {
                this.options.headers = {
                    ...source.headers,
                    ...this.options.headers
                };
            }
        });
        const { json, body, form } = options;
        if (json || body || form) {
            this._lockWrite();
        }
        if (exports.kIsNormalizedAlready in options) {
            this.options = options;
        }
        else {
            try {
                // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible
                this.options = this.constructor.normalizeArguments(url, options, defaults);
            }
            catch (error) {
                // TODO: Move this to `_destroy()`
                if (is_1.default.nodeStream(options.body)) {
                    options.body.destroy();
                }
                this.destroy(error);
                return;
            }
        }
        (async () => {
            var _a;
            try {
                if (this.options.body instanceof fs_1.ReadStream) {
                    await waitForOpenFile(this.options.body);
                }
                const { url: normalizedURL } = this.options;
                if (!normalizedURL) {
                    throw new TypeError('Missing `url` property');
                }
                this.requestUrl = normalizedURL.toString();
                decodeURI(this.requestUrl);
                await this._finalizeBody();
                await this._makeRequest();
                if (this.destroyed) {
                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();
                    return;
                }
                // Queued writes etc.
                for (const job of this[kJobs]) {
                    job();
                }
                // Prevent memory leak
                this[kJobs].length = 0;
                this.requestInitialized = true;
            }
            catch (error) {
                if (error instanceof RequestError) {
                    this._beforeError(error);
                    return;
                }
                // This is a workaround for https://github.com/nodejs/node/issues/33335
                if (!this.destroyed) {
                    this.destroy(error);
                }
            }
        })();
    }
    static normalizeArguments(url, options, defaults) {
        var _a, _b, _c, _d, _e;
        const rawOptions = options;
        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {
            options = { ...defaults, ...url, ...options };
        }
        else {
            if (url && options && options.url !== undefined) {
                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
            }
            options = { ...defaults, ...options };
            if (url !== undefined) {
                options.url = url;
            }
            if (is_1.default.urlInstance(options.url)) {
                options.url = new url_1.URL(options.url.toString());
            }
        }
        // TODO: Deprecate URL options in Got 12.
        // Support extend-specific options
        if (options.cache === false) {
            options.cache = undefined;
        }
        if (options.dnsCache === false) {
            options.dnsCache = undefined;
        }
        // Nice type assertions
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);
        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);
        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);
        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);
        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);
        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);
        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);
        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);
        if (options.https) {
            is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);
            is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);
            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);
            is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);
            is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);
        }
        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);
        // `options.method`
        if (is_1.default.string(options.method)) {
            options.method = options.method.toUpperCase();
        }
        else {
            options.method = 'GET';
        }
        // `options.headers`
        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {
            options.headers = { ...options.headers };
        }
        else {
            options.headers = lowercaseKeys({ ...(defaults === null || defaults === void 0 ? void 0 : defaults.headers), ...options.headers });
        }
        // Disallow legacy `url.Url`
        if ('slashes' in options) {
            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');
        }
        // `options.auth`
        if ('auth' in options) {
            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');
        }
        // `options.searchParams`
        if ('searchParams' in options) {
            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {
                let searchParameters;
                if (is_1.default.string(options.searchParams) || (options.searchParams instanceof url_1.URLSearchParams)) {
                    searchParameters = new url_1.URLSearchParams(options.searchParams);
                }
                else {
                    validateSearchParameters(options.searchParams);
                    searchParameters = new url_1.URLSearchParams();
                    // eslint-disable-next-line guard-for-in
                    for (const key in options.searchParams) {
                        const value = options.searchParams[key];
                        if (value === null) {
                            searchParameters.append(key, '');
                        }
                        else if (value !== undefined) {
                            searchParameters.append(key, value);
                        }
                    }
                }
                // `normalizeArguments()` is also used to merge options
                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {
                    // Only use default if one isn't already defined
                    if (!searchParameters.has(key)) {
                        searchParameters.append(key, value);
                    }
                });
                options.searchParams = searchParameters;
            }
        }
        // `options.username` & `options.password`
        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';
        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';
        // `options.prefixUrl` & `options.url`
        if (is_1.default.undefined(options.prefixUrl)) {
            options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';
        }
        else {
            options.prefixUrl = options.prefixUrl.toString();
            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {
                options.prefixUrl += '/';
            }
        }
        if (is_1.default.string(options.url)) {
            if (options.url.startsWith('/')) {
                throw new Error('`input` must not start with a slash when using `prefixUrl`');
            }
            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);
        }
        else if ((is_1.default.undefined(options.url) && options.prefixUrl !== '') || options.protocol) {
            options.url = options_to_url_1.default(options.prefixUrl, options);
        }
        if (options.url) {
            if ('port' in options) {
                delete options.port;
            }
            // Make it possible to change `options.prefixUrl`
            let { prefixUrl } = options;
            Object.defineProperty(options, 'prefixUrl', {
                set: (value) => {
                    const url = options.url;
                    if (!url.href.startsWith(value)) {
                        throw new Error(`Cannot change \`prefixUrl\` from ${prefixUrl} to ${value}: ${url.href}`);
                    }
                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));
                    prefixUrl = value;
                },
                get: () => prefixUrl
            });
            // Support UNIX sockets
            let { protocol } = options.url;
            if (protocol === 'unix:') {
                protocol = 'http:';
                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);
            }
            // Set search params
            if (options.searchParams) {
                // eslint-disable-next-line @typescript-eslint/no-base-to-string
                options.url.search = options.searchParams.toString();
            }
            // Protocol check
            if (protocol !== 'http:' && protocol !== 'https:') {
                throw new UnsupportedProtocolError(options);
            }
            // Update `username`
            if (options.username === '') {
                options.username = options.url.username;
            }
            else {
                options.url.username = options.username;
            }
            // Update `password`
            if (options.password === '') {
                options.password = options.url.password;
            }
            else {
                options.url.password = options.password;
            }
        }
        // `options.cookieJar`
        const { cookieJar } = options;
        if (cookieJar) {
            let { setCookie, getCookieString } = cookieJar;
            is_1.assert.function_(setCookie);
            is_1.assert.function_(getCookieString);
            /* istanbul ignore next: Horrible `tough-cookie` v3 check */
            if (setCookie.length === 4 && getCookieString.length === 0) {
                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));
                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));
                options.cookieJar = {
                    setCookie,
                    getCookieString: getCookieString
                };
            }
        }
        // `options.cache`
        const { cache } = options;
        if (cache) {
            if (!cacheableStore.has(cache)) {
                cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => {
                    const result = requestOptions[kRequest](requestOptions, handler);
                    // TODO: remove this when `cacheable-request` supports async request functions.
                    if (is_1.default.promise(result)) {
                        // @ts-expect-error
                        // We only need to implement the error handler in order to support HTTP2 caching.
                        // The result will be a promise anyway.
                        result.once = (event, handler) => {
                            if (event === 'error') {
                                result.catch(handler);
                            }
                            else if (event === 'abort') {
                                // The empty catch is needed here in case when
                                // it rejects before it's `await`ed in `_makeRequest`.
                                (async () => {
                                    try {
                                        const request = (await result);
                                        request.once('abort', handler);
                                    }
                                    catch (_a) { }
                                })();
                            }
                            else {
                                /* istanbul ignore next: safety check */
                                throw new Error(`Unknown HTTP2 promise event: ${event}`);
                            }
                            return result;
                        };
                    }
                    return result;
                }), cache));
            }
        }
        // `options.cacheOptions`
        options.cacheOptions = { ...options.cacheOptions };
        // `options.dnsCache`
        if (options.dnsCache === true) {
            if (!globalDnsCache) {
                globalDnsCache = new cacheable_lookup_1.default();
            }
            options.dnsCache = globalDnsCache;
        }
        else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {
            throw new TypeError(`Parameter \`dnsCache\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);
        }
        // `options.timeout`
        if (is_1.default.number(options.timeout)) {
            options.timeout = { request: options.timeout };
        }
        else if (defaults && options.timeout !== defaults.timeout) {
            options.timeout = {
                ...defaults.timeout,
                ...options.timeout
            };
        }
        else {
            options.timeout = { ...options.timeout };
        }
        // `options.context`
        if (!options.context) {
            options.context = {};
        }
        // `options.hooks`
        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);
        options.hooks = { ...options.hooks };
        for (const event of exports.knownHookEvents) {
            if (event in options.hooks) {
                if (is_1.default.array(options.hooks[event])) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [...options.hooks[event]];
                }
                else {
                    throw new TypeError(`Parameter \`${event}\` must be an Array, got ${is_1.default(options.hooks[event])}`);
                }
            }
            else {
                options.hooks[event] = [];
            }
        }
        if (defaults && !areHooksDefault) {
            for (const event of exports.knownHookEvents) {
                const defaultHooks = defaults.hooks[event];
                if (defaultHooks.length > 0) {
                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044
                    options.hooks[event] = [
                        ...defaults.hooks[event],
                        ...options.hooks[event]
                    ];
                }
            }
        }
        // DNS options
        if ('family' in options) {
            deprecation_warning_1.default('"options.family" was never documented, please use "options.dnsLookupIpVersion"');
        }
        // HTTPS options
        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {
            options.https = { ...defaults.https, ...options.https };
        }
        if ('rejectUnauthorized' in options) {
            deprecation_warning_1.default('"options.rejectUnauthorized" is now deprecated, please use "options.https.rejectUnauthorized"');
        }
        if ('checkServerIdentity' in options) {
            deprecation_warning_1.default('"options.checkServerIdentity" was never documented, please use "options.https.checkServerIdentity"');
        }
        if ('ca' in options) {
            deprecation_warning_1.default('"options.ca" was never documented, please use "options.https.certificateAuthority"');
        }
        if ('key' in options) {
            deprecation_warning_1.default('"options.key" was never documented, please use "options.https.key"');
        }
        if ('cert' in options) {
            deprecation_warning_1.default('"options.cert" was never documented, please use "options.https.certificate"');
        }
        if ('passphrase' in options) {
            deprecation_warning_1.default('"options.passphrase" was never documented, please use "options.https.passphrase"');
        }
        if ('pfx' in options) {
            deprecation_warning_1.default('"options.pfx" was never documented, please use "options.https.pfx"');
        }
        // Other options
        if ('followRedirects' in options) {
            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
        }
        if (options.agent) {
            for (const key in options.agent) {
                if (key !== 'http' && key !== 'https' && key !== 'http2') {
                    throw new TypeError(`Expected the \`options.agent\` properties to be \`http\`, \`https\` or \`http2\`, got \`${key}\``);
                }
            }
        }
        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;
        // Set non-enumerable properties
        exports.setNonEnumerableProperties([defaults, rawOptions], options);
        return normalize_arguments_1.default(options, defaults);
    }
    _lockWrite() {
        const onLockedWrite = () => {
            throw new TypeError('The payload has been already provided');
        };
        this.write = onLockedWrite;
        this.end = onLockedWrite;
    }
    _unlockWrite() {
        this.write = super.write;
        this.end = super.end;
    }
    async _finalizeBody() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is_1.default.undefined(options.form);
        const isJSON = !is_1.default.undefined(options.json);
        const isBody = !is_1.default.undefined(options.body);
        const hasPayload = isForm || isJSON || isBody;
        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);
        this._cannotHaveBody = cannotHaveBody;
        if (hasPayload) {
            if (cannotHaveBody) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
            }
            if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {
                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');
            }
            if (isBody &&
                !(options.body instanceof stream_1.Readable) &&
                !is_1.default.string(options.body) &&
                !is_1.default.buffer(options.body) &&
                !is_form_data_1.default(options.body)) {
                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');
            }
            if (isForm && !is_1.default.object(options.form)) {
                throw new TypeError('The `form` option must be an Object');
            }
            {
                // Serialize body
                const noContentType = !is_1.default.string(headers['content-type']);
                if (isBody) {
                    // Special case for https://github.com/form-data/form-data
                    if (is_form_data_1.default(options.body) && noContentType) {
                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;
                    }
                    this[kBody] = options.body;
                }
                else if (isForm) {
                    if (noContentType) {
                        headers['content-type'] = 'application/x-www-form-urlencoded';
                    }
                    this[kBody] = (new url_1.URLSearchParams(options.form)).toString();
                }
                else {
                    if (noContentType) {
                        headers['content-type'] = 'application/json';
                    }
                    this[kBody] = options.stringifyJson(options.json);
                }
                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);
                // See https://tools.ietf.org/html/rfc7230#section-3.3.2
                // A user agent SHOULD send a Content-Length in a request message when
                // no Transfer-Encoding is sent and the request method defines a meaning
                // for an enclosed payload body.  For example, a Content-Length header
                // field is normally sent in a POST request even when the value is 0
                // (indicating an empty payload body).  A user agent SHOULD NOT send a
                // Content-Length header field when the request message does not contain
                // a payload body and the method semantics do not anticipate such a
                // body.
                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {
                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {
                        headers['content-length'] = String(uploadBodySize);
                    }
                }
            }
        }
        else if (cannotHaveBody) {
            this._lockWrite();
        }
        else {
            this._unlockWrite();
        }
        this[kBodySize] = Number(headers['content-length']) || undefined;
    }
    async _onResponseBase(response) {
        const { options } = this;
        const { url } = options;
        this[kOriginalResponse] = response;
        if (options.decompress) {
            response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirects;
        typedResponse.request = this;
        typedResponse.isFromCache = response.fromCache || false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        this[kIsFromCache] = typedResponse.isFromCache;
        this[kResponseSize] = Number(response.headers['content-length']) || undefined;
        this[kResponse] = response;
        response.once('end', () => {
            this[kResponseSize] = this[kDownloadedSize];
            this.emit('downloadProgress', this.downloadProgress);
        });
        response.once('error', (error) => {
            // Force clean-up, because some packages don't do this.
            // TODO: Fix decompress-response
            response.destroy();
            this._beforeError(new ReadError(error, this));
        });
        response.once('aborted', () => {
            this._beforeError(new ReadError({
                name: 'Error',
                message: 'The server aborted pending request',
                code: 'ECONNRESET'
            }, this));
        });
        this.emit('downloadProgress', this.downloadProgress);
        const rawCookies = response.headers['set-cookie'];
        if (is_1.default.object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                promises = promises.map(async (p) => p.catch(() => { }));
            }
            try {
                await Promise.all(promises);
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
        }
        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
            // We're being redirected, we don't care about the response.
            // It'd be best to abort the request, but we can't because
            // we would have to sacrifice the TCP connection. We don't want that.
            response.resume();
            if (this[kRequest]) {
                this[kCancelTimeouts]();
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this[kRequest];
                this[kUnproxyEvents]();
            }
            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';
            if (shouldBeGet || !options.methodRewriting) {
                // Server responded with "see other", indicating that the resource exists at another location,
                // and the client should request it from that location via GET or HEAD.
                options.method = 'GET';
                if ('body' in options) {
                    delete options.body;
                }
                if ('json' in options) {
                    delete options.json;
                }
                if ('form' in options) {
                    delete options.form;
                }
                this[kBody] = undefined;
                delete options.headers['content-length'];
            }
            if (this.redirects.length >= options.maxRedirects) {
                this._beforeError(new MaxRedirectsError(this));
                return;
            }
            try {
                // Do not remove. See https://github.com/sindresorhus/got/pull/214
                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604
                const redirectUrl = new url_1.URL(redirectBuffer, url);
                const redirectString = redirectUrl.toString();
                decodeURI(redirectString);
                // eslint-disable-next-line no-inner-declarations
                function isUnixSocketURL(url) {
                    return url.protocol === 'unix:' || url.hostname === 'unix';
                }
                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));
                    return;
                }
                // Redirecting to a different site, clear sensitive data.
                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                    if ('host' in options.headers) {
                        delete options.headers.host;
                    }
                    if ('cookie' in options.headers) {
                        delete options.headers.cookie;
                    }
                    if ('authorization' in options.headers) {
                        delete options.headers.authorization;
                    }
                    if (options.username || options.password) {
                        options.username = '';
                        options.password = '';
                    }
                }
                else {
                    redirectUrl.username = options.username;
                    redirectUrl.password = options.password;
                }
                this.redirects.push(redirectString);
                options.url = redirectUrl;
                for (const hook of options.hooks.beforeRedirect) {
                    // eslint-disable-next-line no-await-in-loop
                    await hook(options, typedResponse);
                }
                this.emit('redirect', typedResponse, options);
                await this._makeRequest();
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
            return;
        }
        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {
            this._beforeError(new HTTPError(typedResponse));
            return;
        }
        response.on('readable', () => {
            if (this[kTriggerRead]) {
                this._read();
            }
        });
        this.on('resume', () => {
            response.resume();
        });
        this.on('pause', () => {
            response.pause();
        });
        response.once('end', () => {
            this.push(null);
        });
        this.emit('response', response);
        for (const destination of this[kServerResponsesPiped]) {
            if (destination.headersSent) {
                continue;
            }
            // eslint-disable-next-line guard-for-in
            for (const key in response.headers) {
                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
                const value = response.headers[key];
                if (isAllowed) {
                    destination.setHeader(key, value);
                }
            }
            destination.statusCode = statusCode;
        }
    }
    async _onResponse(response) {
        try {
            await this._onResponseBase(response);
        }
        catch (error) {
            /* istanbul ignore next: better safe than sorry */
            this._beforeError(error);
        }
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        http_timer_1.default(request);
        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response) => {
            void this._onResponse(response);
        });
        request.once('error', (error) => {
            var _a;
            // Force clean-up, because some packages (e.g. nock) don't do this.
            request.destroy();
            // Node.js <= 12.18.2 mistakenly emits the response `end` first.
            (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');
            error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);
            this._beforeError(error);
        });
        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);
        this[kRequest] = request;
        this.emit('uploadProgress', this.uploadProgress);
        // Send body
        const body = this[kBody];
        const currentRequest = this.redirects.length === 0 ? this : request;
        if (is_1.default.nodeStream(body)) {
            body.pipe(currentRequest);
            body.once('error', (error) => {
                this._beforeError(new UploadError(error, this));
            });
        }
        else {
            this._unlockWrite();
            if (!is_1.default.undefined(body)) {
                this._writeRequest(body, undefined, () => { });
                currentRequest.end();
                this._lockWrite();
            }
            else if (this._cannotHaveBody || this._noPipe) {
                currentRequest.end();
                this._lockWrite();
            }
        }
        this.emit('request', request);
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed
            Object.assign(options, url_to_options_1.default(url));
            // `http-cache-semantics` checks this
            // TODO: Fix this ignore.
            // @ts-expect-error
            delete options.url;
            let request;
            // This is ugly
            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
                // TODO: Fix `cacheable-response`
                response._readableState.autoDestroy = false;
                if (request) {
                    (await request).emit('cacheableResponse', response);
                }
                resolve(response);
            });
            // Restore options
            options.url = url;
            cacheRequest.once('error', reject);
            cacheRequest.once('request', async (requestOrPromise) => {
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        var _a, _b, _c, _d, _e;
        const { options } = this;
        const { headers } = options;
        for (const key in headers) {
            if (is_1.default.undefined(headers[key])) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete headers[key];
            }
            else if (is_1.default.null_(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {
            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
        }
        // Set cookies
        if (options.cookieJar) {
            const cookieString = await options.cookieJar.getCookieString(options.url.toString());
            if (is_1.default.nonEmptyString(cookieString)) {
                options.headers.cookie = cookieString;
            }
        }
        for (const hook of options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(options);
            if (!is_1.default.undefined(result)) {
                // @ts-expect-error Skip the type mismatch to support abstract responses
                options.request = () => result;
                break;
            }
        }
        if (options.body && this[kBody] !== options.body) {
            this[kBody] = options.body;
        }
        const { agent, request, timeout, url } = options;
        if (options.dnsCache && !('lookup' in options)) {
            options.lookup = options.dnsCache.lookup;
        }
        // UNIX sockets
        if (url.hostname === 'unix') {
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                const { socketPath, path } = matches.groups;
                Object.assign(options, {
                    socketPath,
                    path,
                    host: ''
                });
            }
        }
        const isHttps = url.protocol === 'https:';
        // Fallback function
        let fallbackFn;
        if (options.http2) {
            fallbackFn = http2wrapper.auto;
        }
        else {
            fallbackFn = isHttps ? https.request : http.request;
        }
        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;
        // Cache support
        const fn = options.cache ? this._createCacheableRequest : realFn;
        // Pass an agent directly when HTTP2 is disabled
        if (agent && !options.http2) {
            options.agent = agent[isHttps ? 'https' : 'http'];
        }
        // Prepare plain HTTP request options
        options[kRequest] = realFn;
        delete options.request;
        // TODO: Fix this ignore.
        // @ts-expect-error
        delete options.timeout;
        const requestOptions = options;
        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;
        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;
        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;
        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;
        // If `dnsLookupIpVersion` is not present do not override `family`
        if (options.dnsLookupIpVersion !== undefined) {
            try {
                requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);
            }
            catch (_f) {
                throw new Error('Invalid `dnsLookupIpVersion` option value');
            }
        }
        // HTTPS options remapping
        if (options.https) {
            if ('rejectUnauthorized' in options.https) {
                requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;
            }
            if (options.https.checkServerIdentity) {
                requestOptions.checkServerIdentity = options.https.checkServerIdentity;
            }
            if (options.https.certificateAuthority) {
                requestOptions.ca = options.https.certificateAuthority;
            }
            if (options.https.certificate) {
                requestOptions.cert = options.https.certificate;
            }
            if (options.https.key) {
                requestOptions.key = options.https.key;
            }
            if (options.https.passphrase) {
                requestOptions.passphrase = options.https.passphrase;
            }
            if (options.https.pfx) {
                requestOptions.pfx = options.https.pfx;
            }
        }
        try {
            let requestOrResponse = await fn(url, requestOptions);
            if (is_1.default.undefined(requestOrResponse)) {
                requestOrResponse = fallbackFn(url, requestOptions);
            }
            // Restore options
            options.request = request;
            options.timeout = timeout;
            options.agent = agent;
            // HTTPS options restore
            if (options.https) {
                if ('rejectUnauthorized' in options.https) {
                    delete requestOptions.rejectUnauthorized;
                }
                if (options.https.checkServerIdentity) {
                    // @ts-expect-error - This one will be removed when we remove the alias.
                    delete requestOptions.checkServerIdentity;
                }
                if (options.https.certificateAuthority) {
                    delete requestOptions.ca;
                }
                if (options.https.certificate) {
                    delete requestOptions.cert;
                }
                if (options.https.key) {
                    delete requestOptions.key;
                }
                if (options.https.passphrase) {
                    delete requestOptions.passphrase;
                }
                if (options.https.pfx) {
                    delete requestOptions.pfx;
                }
            }
            if (isClientRequest(requestOrResponse)) {
                this._onRequest(requestOrResponse);
                // Emit the response after the stream has been ended
            }
            else if (this.writable) {
                this.once('finish', () => {
                    void this._onResponse(requestOrResponse);
                });
                this._unlockWrite();
                this.end();
                this._lockWrite();
            }
            else {
                void this._onResponse(requestOrResponse);
            }
        }
        catch (error) {
            if (error instanceof CacheableRequest.CacheError) {
                throw new CacheError(error, this);
            }
            throw new RequestError(error.message, error, this);
        }
    }
    async _error(error) {
        try {
            for (const hook of this.options.hooks.beforeError) {
                // eslint-disable-next-line no-await-in-loop
                error = await hook(error);
            }
        }
        catch (error_) {
            error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _beforeError(error) {
        if (this[kStopReading]) {
            return;
        }
        const { options } = this;
        const retryCount = this.retryCount + 1;
        this[kStopReading] = true;
        if (!(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        const { response } = typedError;
        void (async () => {
            if (response && !response.body) {
                response.setEncoding(this._readableState.encoding);
                try {
                    response.rawBody = await get_buffer_1.default(response);
                    response.body = response.rawBody.toString();
                }
                catch (_a) { }
            }
            if (this.listenerCount('retry') !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && 'retry-after' in response.headers) {
                        retryAfter = Number(response.headers['retry-after']);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
                            if (retryAfter <= 0) {
                                retryAfter = 1;
                            }
                        }
                        else {
                            retryAfter *= 1000;
                        }
                    }
                    backoff = await options.retry.calculateDelay({
                        attemptCount: retryCount,
                        retryOptions: options.retry,
                        error: typedError,
                        retryAfter,
                        computedValue: calculate_retry_delay_1.default({
                            attemptCount: retryCount,
                            retryOptions: options.retry,
                            error: typedError,
                            retryAfter,
                            computedValue: 0
                        })
                    });
                }
                catch (error_) {
                    void this._error(new RequestError(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    const retry = async () => {
                        try {
                            for (const hook of this.options.hooks.beforeRetry) {
                                // eslint-disable-next-line no-await-in-loop
                                await hook(this.options, typedError, retryCount);
                            }
                        }
                        catch (error_) {
                            void this._error(new RequestError(error_.message, error, this));
                            return;
                        }
                        // Something forced us to abort the retry
                        if (this.destroyed) {
                            return;
                        }
                        this.destroy();
                        this.emit('retry', retryCount, error);
                    };
                    this[kRetryTimeout] = setTimeout(retry, backoff);
                    return;
                }
            }
            void this._error(typedError);
        })();
    }
    _read() {
        this[kTriggerRead] = true;
        const response = this[kResponse];
        if (response && !this[kStopReading]) {
            // We cannot put this in the `if` above
            // because `.read()` also triggers the `end` event
            if (response.readableLength) {
                this[kTriggerRead] = false;
            }
            let data;
            while ((data = response.read()) !== null) {
                this[kDownloadedSize] += data.length;
                this[kStartedReading] = true;
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    // Node.js 12 has incorrect types, so the encoding must be a string
    _write(chunk, encoding, callback) {
        const write = () => {
            this._writeRequest(chunk, encoding, callback);
        };
        if (this.requestInitialized) {
            write();
        }
        else {
            this[kJobs].push(write);
        }
    }
    _writeRequest(chunk, encoding, callback) {
        if (this[kRequest].destroyed) {
            // Probably the `ClientRequest` instance will throw
            return;
        }
        this._progressCallbacks.push(() => {
            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);
            const progress = this.uploadProgress;
            if (progress.percent < 1) {
                this.emit('uploadProgress', progress);
            }
        });
        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.
        this[kRequest].write(chunk, encoding, (error) => {
            if (!error && this._progressCallbacks.length > 0) {
                this._progressCallbacks.shift()();
            }
            callback(error);
        });
    }
    _final(callback) {
        const endRequest = () => {
            // FIX: Node.js 10 calls the write callback AFTER the end callback!
            while (this._progressCallbacks.length !== 0) {
                this._progressCallbacks.shift()();
            }
            // We need to check if `this[kRequest]` is present,
            // because it isn't when we use cache.
            if (!(kRequest in this)) {
                callback();
                return;
            }
            if (this[kRequest].destroyed) {
                callback();
                return;
            }
            this[kRequest].end((error) => {
                if (!error) {
                    this[kBodySize] = this[kUploadedSize];
                    this.emit('uploadProgress', this.uploadProgress);
                    this[kRequest].emit('upload-complete');
                }
                callback(error);
            });
        };
        if (this.requestInitialized) {
            endRequest();
        }
        else {
            this[kJobs].push(endRequest);
        }
    }
    _destroy(error, callback) {
        var _a;
        this[kStopReading] = true;
        // Prevent further retries
        clearTimeout(this[kRetryTimeout]);
        if (kRequest in this) {
            this[kCancelTimeouts]();
            // TODO: Remove the next `if` when these get fixed:
            // - https://github.com/nodejs/node/issues/32851
            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {
                this[kRequest].destroy();
            }
        }
        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        callback(error);
    }
    get _isAboutToError() {
        return this[kStopReading];
    }
    /**
    The remote IP address.
    */
    get ip() {
        var _a;
        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */
    get aborted() {
        var _a, _b, _c;
        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);
    }
    get socket() {
        var _a, _b;
        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;
    }
    /**
    Progress event for downloading (receiving a response).
    */
    get downloadProgress() {
        let percent;
        if (this[kResponseSize]) {
            percent = this[kDownloadedSize] / this[kResponseSize];
        }
        else if (this[kResponseSize] === this[kDownloadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kDownloadedSize],
            total: this[kResponseSize]
        };
    }
    /**
    Progress event for uploading (sending a request).
    */
    get uploadProgress() {
        let percent;
        if (this[kBodySize]) {
            percent = this[kUploadedSize] / this[kBodySize];
        }
        else if (this[kBodySize] === this[kUploadedSize]) {
            percent = 1;
        }
        else {
            percent = 0;
        }
        return {
            percent,
            transferred: this[kUploadedSize],
            total: this[kBodySize]
        };
    }
    /**
    The object contains the following properties:

    - `start` - Time when the request started.
    - `socket` - Time when a socket was assigned to the request.
    - `lookup` - Time when the DNS lookup finished.
    - `connect` - Time when the socket successfully connected.
    - `secureConnect` - Time when the socket securely connected.
    - `upload` - Time when the request finished uploading.
    - `response` - Time when the request fired `response` event.
    - `end` - Time when the response fired `end` event.
    - `error` - Time when the request fired `error` event.
    - `abort` - Time when the request fired `abort` event.
    - `phases`
        - `wait` - `timings.socket - timings.start`
        - `dns` - `timings.lookup - timings.socket`
        - `tcp` - `timings.connect - timings.lookup`
        - `tls` - `timings.secureConnect - timings.connect`
        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
        - `firstByte` - `timings.response - timings.upload`
        - `download` - `timings.end - timings.response`
        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`

    If something has not been measured yet, it will be `undefined`.

    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
    */
    get timings() {
        var _a;
        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */
    get isFromCache() {
        return this[kIsFromCache];
    }
    pipe(destination, options) {
        if (this[kStartedReading]) {
            throw new Error('Failed to pipe. The response has been emitted already.');
        }
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof http_1.ServerResponse) {
            this[kServerResponsesPiped].delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
}
exports["default"] = Request;


/***/ }),

/***/ 4993:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;
const conversionTable = {
    auto: 0,
    ipv4: 4,
    ipv6: 6
};
exports.isDnsLookupIpVersion = (value) => {
    return value in conversionTable;
};
exports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {
    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {
        return conversionTable[dnsLookupIpVersion];
    }
    throw new Error('Invalid DNS lookup IP version');
};


/***/ }),

/***/ 4564:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs_1 = __nccwpck_require__(7147);
const util_1 = __nccwpck_require__(3837);
const is_1 = __nccwpck_require__(7678);
const is_form_data_1 = __nccwpck_require__(40);
const statAsync = util_1.promisify(fs_1.stat);
exports["default"] = async (body, headers) => {
    if (headers && 'content-length' in headers) {
        return Number(headers['content-length']);
    }
    if (!body) {
        return 0;
    }
    if (is_1.default.string(body)) {
        return Buffer.byteLength(body);
    }
    if (is_1.default.buffer(body)) {
        return body.length;
    }
    if (is_form_data_1.default(body)) {
        return util_1.promisify(body.getLength.bind(body))();
    }
    if (body instanceof fs_1.ReadStream) {
        const { size } = await statAsync(body.path);
        if (size === 0) {
            return undefined;
        }
        return size;
    }
    return undefined;
};


/***/ }),

/***/ 4500:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// TODO: Update https://github.com/sindresorhus/get-stream
const getBuffer = async (stream) => {
    const chunks = [];
    let length = 0;
    for await (const chunk of stream) {
        chunks.push(chunk);
        length += Buffer.byteLength(chunk);
    }
    if (Buffer.isBuffer(chunks[0])) {
        return Buffer.concat(chunks, length);
    }
    return Buffer.from(chunks.join(''));
};
exports["default"] = getBuffer;


/***/ }),

/***/ 40:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __nccwpck_require__(7678);
exports["default"] = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);


/***/ }),

/***/ 9298:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseOk = void 0;
exports.isResponseOk = (response) => {
    const { statusCode } = response;
    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;
    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
};


/***/ }),

/***/ 9219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* istanbul ignore file: deprecated */
const url_1 = __nccwpck_require__(7310);
const keys = [
    'protocol',
    'host',
    'hostname',
    'port',
    'pathname',
    'search'
];
exports["default"] = (origin, options) => {
    var _a, _b;
    if (options.path) {
        if (options.pathname) {
            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');
        }
        if (options.search) {
            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');
        }
        if (options.searchParams) {
            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');
        }
    }
    if (options.search && options.searchParams) {
        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');
    }
    if (!origin) {
        if (!options.protocol) {
            throw new TypeError('No URL protocol specified');
        }
        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;
    }
    const url = new url_1.URL(origin);
    if (options.path) {
        const searchIndex = options.path.indexOf('?');
        if (searchIndex === -1) {
            options.pathname = options.path;
        }
        else {
            options.pathname = options.path.slice(0, searchIndex);
            options.search = options.path.slice(searchIndex + 1);
        }
        delete options.path;
    }
    for (const key of keys) {
        if (options[key]) {
            url[key] = options[key].toString();
        }
    }
    return url;
};


/***/ }),

/***/ 3021:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function default_1(from, to, events) {
    const fns = {};
    for (const event of events) {
        fns[event] = (...args) => {
            to.emit(event, ...args);
        };
        from.on(event, fns[event]);
    }
    return () => {
        for (const event of events) {
            from.off(event, fns[event]);
        }
    };
}
exports["default"] = default_1;


/***/ }),

/***/ 2454:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = void 0;
const net = __nccwpck_require__(1808);
const unhandle_1 = __nccwpck_require__(1593);
const reentry = Symbol('reentry');
const noop = () => { };
class TimeoutError extends Error {
    constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.event = event;
        this.name = 'TimeoutError';
        this.code = 'ETIMEDOUT';
    }
}
exports.TimeoutError = TimeoutError;
exports["default"] = (request, delays, options) => {
    if (reentry in request) {
        return noop;
    }
    request[reentry] = true;
    const cancelers = [];
    const { once, unhandleAll } = unhandle_1.default();
    const addTimeout = (delay, callback, event) => {
        var _a;
        const timeout = setTimeout(callback, delay, delay, event);
        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);
        const cancel = () => {
            clearTimeout(timeout);
        };
        cancelers.push(cancel);
        return cancel;
    };
    const { host, hostname } = options;
    const timeoutHandler = (delay, event) => {
        request.destroy(new TimeoutError(delay, event));
    };
    const cancelTimeouts = () => {
        for (const cancel of cancelers) {
            cancel();
        }
        unhandleAll();
    };
    request.once('error', error => {
        cancelTimeouts();
        // Save original behavior
        /* istanbul ignore next */
        if (request.listenerCount('error') === 0) {
            throw error;
        }
    });
    request.once('close', cancelTimeouts);
    once(request, 'response', (response) => {
        once(response, 'end', cancelTimeouts);
    });
    if (typeof delays.request !== 'undefined') {
        addTimeout(delays.request, timeoutHandler, 'request');
    }
    if (typeof delays.socket !== 'undefined') {
        const socketTimeoutHandler = () => {
            timeoutHandler(delays.socket, 'socket');
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        // `request.setTimeout(0)` causes a memory leak.
        // We can just remove the listener and forget about the timer - it's unreffed.
        // See https://github.com/sindresorhus/got/issues/690
        cancelers.push(() => {
            request.removeListener('timeout', socketTimeoutHandler);
        });
    }
    once(request, 'socket', (socket) => {
        var _a;
        const { socketPath } = request;
        /* istanbul ignore next: hard to test */
        if (socket.connecting) {
            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);
            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {
                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');
                once(socket, 'lookup', cancelTimeout);
            }
            if (typeof delays.connect !== 'undefined') {
                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');
                if (hasPath) {
                    once(socket, 'connect', timeConnect());
                }
                else {
                    once(socket, 'lookup', (error) => {
                        if (error === null) {
                            once(socket, 'connect', timeConnect());
                        }
                    });
                }
            }
            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {
                once(socket, 'connect', () => {
                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');
                    once(socket, 'secureConnect', cancelTimeout);
                });
            }
        }
        if (typeof delays.send !== 'undefined') {
            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');
            /* istanbul ignore next: hard to test */
            if (socket.connecting) {
                once(socket, 'connect', () => {
                    once(request, 'upload-complete', timeRequest());
                });
            }
            else {
                once(request, 'upload-complete', timeRequest());
            }
        }
    });
    if (typeof delays.response !== 'undefined') {
        once(request, 'upload-complete', () => {
            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');
            once(request, 'response', cancelTimeout);
        });
    }
    return cancelTimeouts;
};


/***/ }),

/***/ 1593:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// When attaching listeners, it's very easy to forget about them.
// Especially if you do error handling and set timeouts.
// So instead of checking if it's proper to throw an error on every timeout ever,
// use this simple tool which will remove all listeners you have attached.
exports["default"] = () => {
    const handlers = [];
    return {
        once(origin, event, fn) {
            origin.once(event, fn);
            handlers.push({ origin, event, fn });
        },
        unhandleAll() {
            for (const handler of handlers) {
                const { origin, event, fn } = handler;
                origin.removeListener(event, fn);
            }
            handlers.length = 0;
        }
    };
};


/***/ }),

/***/ 8026:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __nccwpck_require__(7678);
exports["default"] = (url) => {
    // Cast to URL
    url = url;
    const options = {
        protocol: url.protocol,
        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
        host: url.host,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href,
        path: `${url.pathname || ''}${url.search || ''}`
    };
    if (is_1.default.string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username || ''}:${url.password || ''}`;
    }
    return options;
};


/***/ }),

/***/ 7288:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WeakableMap {
    constructor() {
        this.weakMap = new WeakMap();
        this.map = new Map();
    }
    set(key, value) {
        if (typeof key === 'object') {
            this.weakMap.set(key, value);
        }
        else {
            this.map.set(key, value);
        }
    }
    get(key) {
        if (typeof key === 'object') {
            return this.weakMap.get(key);
        }
        return this.map.get(key);
    }
    has(key) {
        if (typeof key === 'object') {
            return this.weakMap.has(key);
        }
        return this.map.has(key);
    }
}
exports["default"] = WeakableMap;


/***/ }),

/***/ 4337:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultHandler = void 0;
const is_1 = __nccwpck_require__(7678);
const as_promise_1 = __nccwpck_require__(6056);
const create_rejection_1 = __nccwpck_require__(6457);
const core_1 = __nccwpck_require__(94);
const deep_freeze_1 = __nccwpck_require__(285);
const errors = {
    RequestError: as_promise_1.RequestError,
    CacheError: as_promise_1.CacheError,
    ReadError: as_promise_1.ReadError,
    HTTPError: as_promise_1.HTTPError,
    MaxRedirectsError: as_promise_1.MaxRedirectsError,
    TimeoutError: as_promise_1.TimeoutError,
    ParseError: as_promise_1.ParseError,
    CancelError: as_promise_1.CancelError,
    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,
    UploadError: as_promise_1.UploadError
};
// The `delay` package weighs 10KB (!)
const delay = async (ms) => new Promise(resolve => {
    setTimeout(resolve, ms);
});
const { normalizeArguments } = core_1.default;
const mergeOptions = (...sources) => {
    let mergedOptions;
    for (const source of sources) {
        mergedOptions = normalizeArguments(undefined, source, mergedOptions);
    }
    return mergedOptions;
};
const getPromiseOrStream = (options) => options.isStream ? new core_1.default(undefined, options) : as_promise_1.default(options);
const isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);
const aliases = [
    'get',
    'post',
    'put',
    'patch',
    'head',
    'delete'
];
exports.defaultHandler = (options, next) => next(options);
const callInitHooks = (hooks, options) => {
    if (hooks) {
        for (const hook of hooks) {
            hook(options);
        }
    }
};
const create = (defaults) => {
    // Proxy properties from next handlers
    defaults._rawHandlers = defaults.handlers;
    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {
        // This will be assigned by assigning result
        let root;
        const result = fn(options, newOptions => {
            root = next(newOptions);
            return root;
        });
        if (result !== root && !options.isStream && root) {
            const typedResult = result;
            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;
            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));
            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));
            // These should point to the new promise
            // eslint-disable-next-line promise/prefer-await-to-then
            typedResult.then = promiseThen;
            typedResult.catch = promiseCatch;
            typedResult.finally = promiseFianlly;
        }
        return result;
    }));
    // Got interface
    const got = ((url, options = {}, _defaults) => {
        var _a, _b;
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);
        };
        // TODO: Remove this in Got 12.
        if (is_1.default.plainObject(url)) {
            const mergedOptions = {
                ...url,
                ...options
            };
            core_1.setNonEnumerableProperties([url, options], mergedOptions);
            options = mergedOptions;
            url = undefined;
        }
        try {
            // Call `init` hooks
            let initHookError;
            try {
                callInitHooks(defaults.options.hooks.init, options);
                callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);
            }
            catch (error) {
                initHookError = error;
            }
            // Normalize options & call handlers
            const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);
            normalizedOptions[core_1.kIsNormalizedAlready] = true;
            if (initHookError) {
                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);
            }
            return iterateHandlers(normalizedOptions);
        }
        catch (error) {
            if (options.isStream) {
                throw error;
            }
            else {
                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);
            }
        }
    });
    got.extend = (...instancesOrOptions) => {
        const optionsArray = [defaults.options];
        let handlers = [...defaults._rawHandlers];
        let isMutableDefaults;
        for (const value of instancesOrOptions) {
            if (isGotInstance(value)) {
                optionsArray.push(value.defaults.options);
                handlers.push(...value.defaults._rawHandlers);
                isMutableDefaults = value.defaults.mutableDefaults;
            }
            else {
                optionsArray.push(value);
                if ('handlers' in value) {
                    handlers.push(...value.handlers);
                }
                isMutableDefaults = value.mutableDefaults;
            }
        }
        handlers = handlers.filter(handler => handler !== exports.defaultHandler);
        if (handlers.length === 0) {
            handlers.push(exports.defaultHandler);
        }
        return create({
            options: mergeOptions(...optionsArray),
            handlers,
            mutableDefaults: Boolean(isMutableDefaults)
        });
    };
    // Pagination
    const paginateEach = (async function* (url, options) {
        // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.
        // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.
        // @ts-expect-error
        let normalizedOptions = normalizeArguments(url, options, defaults.options);
        normalizedOptions.resolveBodyOnly = false;
        const pagination = normalizedOptions.pagination;
        if (!is_1.default.object(pagination)) {
            throw new TypeError('`options.pagination` must be implemented');
        }
        const all = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
            if (numberOfRequests !== 0) {
                // eslint-disable-next-line no-await-in-loop
                await delay(pagination.backoff);
            }
            // @ts-expect-error FIXME!
            // TODO: Throw when result is not an instance of Response
            // eslint-disable-next-line no-await-in-loop
            const result = (await got(undefined, undefined, normalizedOptions));
            // eslint-disable-next-line no-await-in-loop
            const parsed = await pagination.transform(result);
            const current = [];
            for (const item of parsed) {
                if (pagination.filter(item, all, current)) {
                    if (!pagination.shouldContinue(item, all, current)) {
                        return;
                    }
                    yield item;
                    if (pagination.stackAllItems) {
                        all.push(item);
                    }
                    current.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate(result, all, current);
            if (optionsToMerge === false) {
                return;
            }
            if (optionsToMerge === result.request.options) {
                normalizedOptions = result.request.options;
            }
            else if (optionsToMerge !== undefined) {
                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);
            }
            numberOfRequests++;
        }
    });
    got.paginate = paginateEach;
    got.paginate.all = (async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
            results.push(item);
        }
        return results;
    });
    // For those who like very descriptive names
    got.paginate.each = paginateEach;
    // Stream API
    got.stream = ((url, options) => got(url, { ...options, isStream: true }));
    // Shortcuts
    for (const method of aliases) {
        got[method] = ((url, options) => got(url, { ...options, method }));
        got.stream[method] = ((url, options) => {
            return got(url, { ...options, method, isStream: true });
        });
    }
    Object.assign(got, errors);
    Object.defineProperty(got, 'defaults', {
        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
    });
    got.mergeOptions = mergeOptions;
    return got;
};
exports["default"] = create;
__exportStar(__nccwpck_require__(2613), exports);


/***/ }),

/***/ 3061:
/***/ (function(module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const url_1 = __nccwpck_require__(7310);
const create_1 = __nccwpck_require__(4337);
const defaults = {
    options: {
        method: 'GET',
        retry: {
            limit: 2,
            methods: [
                'GET',
                'PUT',
                'HEAD',
                'DELETE',
                'OPTIONS',
                'TRACE'
            ],
            statusCodes: [
                408,
                413,
                429,
                500,
                502,
                503,
                504,
                521,
                522,
                524
            ],
            errorCodes: [
                'ETIMEDOUT',
                'ECONNRESET',
                'EADDRINUSE',
                'ECONNREFUSED',
                'EPIPE',
                'ENOTFOUND',
                'ENETUNREACH',
                'EAI_AGAIN'
            ],
            maxRetryAfter: undefined,
            calculateDelay: ({ computedValue }) => computedValue
        },
        timeout: {},
        headers: {
            'user-agent': 'got (https://github.com/sindresorhus/got)'
        },
        hooks: {
            init: [],
            beforeRequest: [],
            beforeRedirect: [],
            beforeRetry: [],
            beforeError: [],
            afterResponse: []
        },
        cache: undefined,
        dnsCache: undefined,
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        isStream: false,
        responseType: 'text',
        resolveBodyOnly: false,
        maxRedirects: 10,
        prefixUrl: '',
        methodRewriting: true,
        ignoreInvalidCookies: false,
        context: {},
        // TODO: Set this to `true` when Got 12 gets released
        http2: false,
        allowGetBody: false,
        https: undefined,
        pagination: {
            transform: (response) => {
                if (response.request.options.responseType === 'json') {
                    return response.body;
                }
                return JSON.parse(response.body);
            },
            paginate: response => {
                if (!Reflect.has(response.headers, 'link')) {
                    return false;
                }
                const items = response.headers.link.split(',');
                let next;
                for (const item of items) {
                    const parsed = item.split(';');
                    if (parsed[1].includes('next')) {
                        next = parsed[0].trimStart().trim();
                        next = next.slice(1, -1);
                        break;
                    }
                }
                if (next) {
                    const options = {
                        url: new url_1.URL(next)
                    };
                    return options;
                }
                return false;
            },
            filter: () => true,
            shouldContinue: () => true,
            countLimit: Infinity,
            backoff: 0,
            requestLimit: 10000,
            stackAllItems: true
        },
        parseJson: (text) => JSON.parse(text),
        stringifyJson: (object) => JSON.stringify(object),
        cacheOptions: {}
    },
    handlers: [create_1.defaultHandler],
    mutableDefaults: false
};
const got = create_1.default(defaults);
exports["default"] = got;
// For CommonJS default export support
module.exports = got;
module.exports["default"] = got;
module.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267
__exportStar(__nccwpck_require__(4337), exports);
__exportStar(__nccwpck_require__(6056), exports);


/***/ }),

/***/ 2613:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ 285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const is_1 = __nccwpck_require__(7678);
function deepFreeze(object) {
    for (const value of Object.values(object)) {
        if (is_1.default.plainObject(value) || is_1.default.array(value)) {
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
}
exports["default"] = deepFreeze;


/***/ }),

/***/ 397:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const alreadyWarned = new Set();
exports["default"] = (message) => {
    if (alreadyWarned.has(message)) {
        return;
    }
    alreadyWarned.add(message);
    // @ts-expect-error Missing types.
    process.emitWarning(`Got: ${message}`, {
        type: 'DeprecationWarning'
    });
};


/***/ }),

/***/ 1002:
/***/ ((module) => {

"use strict";

// rfc7231 6.1
const statusCodeCacheableByDefault = new Set([
    200,
    203,
    204,
    206,
    300,
    301,
    404,
    405,
    410,
    414,
    501,
]);

// This implementation does not understand partial responses (206)
const understoodStatuses = new Set([
    200,
    203,
    204,
    300,
    301,
    302,
    303,
    307,
    308,
    404,
    405,
    410,
    414,
    501,
]);

const errorStatusCodes = new Set([
    500,
    502,
    503, 
    504,
]);

const hopByHopHeaders = {
    date: true, // included, because we add Age update Date
    connection: true,
    'keep-alive': true,
    'proxy-authenticate': true,
    'proxy-authorization': true,
    te: true,
    trailer: true,
    'transfer-encoding': true,
    upgrade: true,
};

const excludedFromRevalidationUpdate = {
    // Since the old body is reused, it doesn't make sense to change properties of the body
    'content-length': true,
    'content-encoding': true,
    'transfer-encoding': true,
    'content-range': true,
};

function toNumberOrZero(s) {
    const n = parseInt(s, 10);
    return isFinite(n) ? n : 0;
}

// RFC 5861
function isErrorResponse(response) {
    // consider undefined response as faulty
    if(!response) {
        return true
    }
    return errorStatusCodes.has(response.status);
}

function parseCacheControl(header) {
    const cc = {};
    if (!header) return cc;

    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),
    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale
    const parts = header.trim().split(/\s*,\s*/); // TODO: lame parsing
    for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === undefined ? true : v.replace(/^"|"$/g, ''); // TODO: lame unquoting
    }

    return cc;
}

function formatCacheControl(cc) {
    let parts = [];
    for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + '=' + v);
    }
    if (!parts.length) {
        return undefined;
    }
    return parts.join(', ');
}

module.exports = class CachePolicy {
    constructor(
        req,
        res,
        {
            shared,
            cacheHeuristic,
            immutableMinTimeToLive,
            ignoreCargoCult,
            _fromObject,
        } = {}
    ) {
        if (_fromObject) {
            this._fromObject(_fromObject);
            return;
        }

        if (!res || !res.headers) {
            throw Error('Response headers missing');
        }
        this._assertRequestHasHeaders(req);

        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic =
            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE
        this._immutableMinTtl =
            undefined !== immutableMinTimeToLive
                ? immutableMinTimeToLive
                : 24 * 3600 * 1000;

        this._status = 'status' in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers['cache-control']);
        this._method = 'method' in req ? req.method : 'GET';
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used
        this._reqcc = parseCacheControl(req.headers['cache-control']);

        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,
        // so there's no point stricly adhering to the blindly copy&pasted directives.
        if (
            ignoreCargoCult &&
            'pre-check' in this._rescc &&
            'post-check' in this._rescc
        ) {
            delete this._rescc['pre-check'];
            delete this._rescc['post-check'];
            delete this._rescc['no-cache'];
            delete this._rescc['no-store'];
            delete this._rescc['must-revalidate'];
            this._resHeaders = Object.assign({}, this._resHeaders, {
                'cache-control': formatCacheControl(this._rescc),
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
        }

        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive
        // as having the same effect as if "Cache-Control: no-cache" were present (see Section 5.2.1).
        if (
            res.headers['cache-control'] == null &&
            /no-cache/.test(res.headers.pragma)
        ) {
            this._rescc['no-cache'] = true;
        }
    }

    now() {
        return Date.now();
    }

    storable() {
        // The "no-store" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.
        return !!(
            !this._reqcc['no-store'] &&
            // A cache MUST NOT store a response to any request, unless:
            // The request method is understood by the cache and defined as being cacheable, and
            ('GET' === this._method ||
                'HEAD' === this._method ||
                ('POST' === this._method && this._hasExplicitExpiration())) &&
            // the response status code is understood by the cache, and
            understoodStatuses.has(this._status) &&
            // the "no-store" cache directive does not appear in request or response header fields, and
            !this._rescc['no-store'] &&
            // the "private" response directive does not appear in the response, if the cache is shared, and
            (!this._isShared || !this._rescc.private) &&
            // the Authorization header field does not appear in the request, if the cache is shared,
            (!this._isShared ||
                this._noAuthorization ||
                this._allowsStoringAuthenticated()) &&
            // the response either:
            // contains an Expires header field, or
            (this._resHeaders.expires ||
                // contains a max-age response directive, or
                // contains a s-maxage response directive and the cache is shared, or
                // contains a public response directive.
                this._rescc['max-age'] ||
                (this._isShared && this._rescc['s-maxage']) ||
                this._rescc.public ||
                // has a status code that is defined as cacheable by default
                statusCodeCacheableByDefault.has(this._status))
        );
    }

    _hasExplicitExpiration() {
        // 4.2.1 Calculating Freshness Lifetime
        return (
            (this._isShared && this._rescc['s-maxage']) ||
            this._rescc['max-age'] ||
            this._resHeaders.expires
        );
    }

    _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
            throw Error('Request headers missing');
        }
    }

    satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);

        // When presented with a request, a cache MUST NOT reuse a stored response, unless:
        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,
        // unless the stored response is successfully validated (Section 4.3), and
        const requestCC = parseCacheControl(req.headers['cache-control']);
        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {
            return false;
        }

        if (requestCC['max-age'] && this.age() > requestCC['max-age']) {
            return false;
        }

        if (
            requestCC['min-fresh'] &&
            this.timeToLive() < 1000 * requestCC['min-fresh']
        ) {
            return false;
        }

        // the stored response is either:
        // fresh, or allowed to be served stale
        if (this.stale()) {
            const allowsStale =
                requestCC['max-stale'] &&
                !this._rescc['must-revalidate'] &&
                (true === requestCC['max-stale'] ||
                    requestCC['max-stale'] > this.age() - this.maxAge());
            if (!allowsStale) {
                return false;
            }
        }

        return this._requestMatches(req, false);
    }

    _requestMatches(req, allowHeadMethod) {
        // The presented effective request URI and that of the stored response match, and
        return (
            (!this._url || this._url === req.url) &&
            this._host === req.headers.host &&
            // the request method associated with the stored response allows it to be used for the presented request, and
            (!req.method ||
                this._method === req.method ||
                (allowHeadMethod && 'HEAD' === req.method)) &&
            // selecting header fields nominated by the stored response (if any) match those presented, and
            this._varyMatches(req)
        );
    }

    _allowsStoringAuthenticated() {
        //  following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.
        return (
            this._rescc['must-revalidate'] ||
            this._rescc.public ||
            this._rescc['s-maxage']
        );
    }

    _varyMatches(req) {
        if (!this._resHeaders.vary) {
            return true;
        }

        // A Vary header field-value of "*" always fails to match
        if (this._resHeaders.vary === '*') {
            return false;
        }

        const fields = this._resHeaders.vary
            .trim()
            .toLowerCase()
            .split(/\s*,\s*/);
        for (const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
        }
        return true;
    }

    _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
        }
        // 9.1.  Connection
        if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens) {
                delete headers[name];
            }
        }
        if (headers.warning) {
            const warnings = headers.warning.split(/,/).filter(warning => {
                return !/^\s*1[0-9][0-9]/.test(warning);
            });
            if (!warnings.length) {
                delete headers.warning;
            } else {
                headers.warning = warnings.join(',').trim();
            }
        }
        return headers;
    }

    responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();

        // A cache SHOULD generate 113 warning if it heuristically chose a freshness
        // lifetime greater than 24 hours and the response's age is greater than 24 hours.
        if (
            age > 3600 * 24 &&
            !this._hasExplicitExpiration() &&
            this.maxAge() > 3600 * 24
        ) {
            headers.warning =
                (headers.warning ? `${headers.warning}, ` : '') +
                '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
    }

    /**
     * Value of the Date response header or current time if Date was invalid
     * @return timestamp
     */
    date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
            return serverDate;
        }
        return this._responseTime;
    }

    /**
     * Value of the Age header, in seconds, updated for the current time.
     * May be fractional.
     *
     * @return Number
     */
    age() {
        let age = this._ageValue();

        const residentTime = (this.now() - this._responseTime) / 1000;
        return age + residentTime;
    }

    _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
    }

    /**
     * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
     *
     * For an up-to-date value, see `timeToLive()`.
     *
     * @return Number
     */
    maxAge() {
        if (!this.storable() || this._rescc['no-cache']) {
            return 0;
        }

        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default
        // so this implementation requires explicit opt-in via public header
        if (
            this._isShared &&
            (this._resHeaders['set-cookie'] &&
                !this._rescc.public &&
                !this._rescc.immutable)
        ) {
            return 0;
        }

        if (this._resHeaders.vary === '*') {
            return 0;
        }

        if (this._isShared) {
            if (this._rescc['proxy-revalidate']) {
                return 0;
            }
            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.
            if (this._rescc['s-maxage']) {
                return toNumberOrZero(this._rescc['s-maxage']);
            }
        }

        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.
        if (this._rescc['max-age']) {
            return toNumberOrZero(this._rescc['max-age']);
        }

        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;

        const serverDate = this.date();
        if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            // A cache recipient MUST interpret invalid date formats, especially the value "0", as representing a time in the past (i.e., "already expired").
            if (Number.isNaN(expires) || expires < serverDate) {
                return 0;
            }
            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);
        }

        if (this._resHeaders['last-modified']) {
            const lastModified = Date.parse(this._resHeaders['last-modified']);
            if (isFinite(lastModified) && serverDate > lastModified) {
                return Math.max(
                    defaultMinTtl,
                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic
                );
            }
        }

        return defaultMinTtl;
    }

    timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000;
    }

    stale() {
        return this.maxAge() <= this.age();
    }

    _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();
    }

    useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc['stale-while-revalidate']) > this.age();
    }

    static fromObject(obj) {
        return new this(undefined, undefined, { _fromObject: obj });
    }

    _fromObject(obj) {
        if (this._responseTime) throw Error('Reinitialized');
        if (!obj || obj.v !== 1) throw Error('Invalid serialization');

        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl =
            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
    }

    toObject() {
        return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
        };
    }

    /**
     * Headers for sending to the origin server to revalidate stale response.
     * Allows server to return 304 to allow reuse of the previous response.
     *
     * Hop by hop headers are always stripped.
     * Revalidation headers may be added or removed, depending on request.
     */
    revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);

        // This implementation does not understand range requests
        delete headers['if-range'];

        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            // revalidation allowed via HEAD
            // not for the same resource, or wasn't allowed to be cached anyway
            delete headers['if-none-match'];
            delete headers['if-modified-since'];
            return headers;
        }

        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */
        if (this._resHeaders.etag) {
            headers['if-none-match'] = headers['if-none-match']
                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`
                : this._resHeaders.etag;
        }

        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.
        const forbidsWeakValidators =
            headers['accept-ranges'] ||
            headers['if-match'] ||
            headers['if-unmodified-since'] ||
            (this._method && this._method != 'GET');

        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
        Note: This implementation does not understand partial responses (206) */
        if (forbidsWeakValidators) {
            delete headers['if-modified-since'];

            if (headers['if-none-match']) {
                const etags = headers['if-none-match']
                    .split(/,/)
                    .filter(etag => {
                        return !/^\s*W\//.test(etag);
                    });
                if (!etags.length) {
                    delete headers['if-none-match'];
                } else {
                    headers['if-none-match'] = etags.join(',').trim();
                }
            }
        } else if (
            this._resHeaders['last-modified'] &&
            !headers['if-modified-since']
        ) {
            headers['if-modified-since'] = this._resHeaders['last-modified'];
        }

        return headers;
    }

    /**
     * Creates new CachePolicy with information combined from the previews response,
     * and the new revalidation response.
     *
     * Returns {policy, modified} where modified is a boolean indicating
     * whether the response body has been modified, and old cached body can't be used.
     *
     * @return {Object} {policy: CachePolicy, modified: Boolean}
     */
    revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if(this._useStaleIfError() && isErrorResponse(response)) {  // I consider the revalidation request unsuccessful
          return {
            modified: false,
            matches: false,
            policy: this,
          };
        }
        if (!response || !response.headers) {
            throw Error('Response headers missing');
        }

        // These aren't going to be supported exactly, since one CachePolicy object
        // doesn't know about all the other cached objects.
        let matches = false;
        if (response.status !== undefined && response.status != 304) {
            matches = false;
        } else if (
            response.headers.etag &&
            !/^\s*W\//.test(response.headers.etag)
        ) {
            // "All of the stored responses with the same strong validator are selected.
            // If none of the stored responses contain the same strong validator,
            // then the cache MUST NOT use the new response to update any stored responses."
            matches =
                this._resHeaders.etag &&
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                    response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
            // "If the new response contains a weak validator and that validator corresponds
            // to one of the cache's stored responses,
            // then the most recent of those matching stored responses is selected for update."
            matches =
                this._resHeaders.etag.replace(/^\s*W\//, '') ===
                response.headers.etag.replace(/^\s*W\//, '');
        } else if (this._resHeaders['last-modified']) {
            matches =
                this._resHeaders['last-modified'] ===
                response.headers['last-modified'];
        } else {
            // If the new response does not include any form of validator (such as in the case where
            // a client generates an If-Modified-Since request from a source other than the Last-Modified
            // response header field), and there is only one stored response, and that stored response also
            // lacks a validator, then that stored response is selected for update.
            if (
                !this._resHeaders.etag &&
                !this._resHeaders['last-modified'] &&
                !response.headers.etag &&
                !response.headers['last-modified']
            ) {
                matches = true;
            }
        }

        if (!matches) {
            return {
                policy: new this.constructor(request, response),
                // Client receiving 304 without body, even if it's invalid/mismatched has no option
                // but to reuse a cached body. We don't have a good way to tell clients to do
                // error recovery in such case.
                modified: response.status != 304,
                matches: false,
            };
        }

        // use other header fields provided in the 304 (Not Modified) response to replace all instances
        // of the corresponding header fields in the stored response.
        const headers = {};
        for (const k in this._resHeaders) {
            headers[k] =
                k in response.headers && !excludedFromRevalidationUpdate[k]
                    ? response.headers[k]
                    : this._resHeaders[k];
        }

        const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
        });
        return {
            policy: new this.constructor(request, newResponse, {
                shared: this._isShared,
                cacheHeuristic: this._cacheHeuristic,
                immutableMinTimeToLive: this._immutableMinTtl,
            }),
            modified: false,
            matches: true,
        };
    }
};


/***/ }),

/***/ 9898:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const EventEmitter = __nccwpck_require__(2361);
const tls = __nccwpck_require__(4404);
const http2 = __nccwpck_require__(5158);
const QuickLRU = __nccwpck_require__(9273);

const kCurrentStreamsCount = Symbol('currentStreamsCount');
const kRequest = Symbol('request');
const kOriginSet = Symbol('cachedOriginSet');
const kGracefullyClosing = Symbol('gracefullyClosing');

const nameKeys = [
	// `http2.connect()` options
	'maxDeflateDynamicTableSize',
	'maxSessionMemory',
	'maxHeaderListPairs',
	'maxOutstandingPings',
	'maxReservedRemoteStreams',
	'maxSendHeaderBlockLength',
	'paddingStrategy',

	// `tls.connect()` options
	'localAddress',
	'path',
	'rejectUnauthorized',
	'minDHSize',

	// `tls.createSecureContext()` options
	'ca',
	'cert',
	'clientCertEngine',
	'ciphers',
	'key',
	'pfx',
	'servername',
	'minVersion',
	'maxVersion',
	'secureProtocol',
	'crl',
	'honorCipherOrder',
	'ecdhCurve',
	'dhparam',
	'secureOptions',
	'sessionIdContext'
];

const getSortedIndex = (array, value, compare) => {
	let low = 0;
	let high = array.length;

	while (low < high) {
		const mid = (low + high) >>> 1;

		/* istanbul ignore next */
		if (compare(array[mid], value)) {
			// This never gets called because we use descending sort. Better to have this anyway.
			low = mid + 1;
		} else {
			high = mid;
		}
	}

	return low;
};

const compareSessions = (a, b) => {
	return a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;
};

// See https://tools.ietf.org/html/rfc8336
const closeCoveredSessions = (where, session) => {
	// Clients SHOULD NOT emit new requests on any connection whose Origin
	// Set is a proper subset of another connection's Origin Set, and they
	// SHOULD close it once all outstanding requests are satisfied.
	for (const coveredSession of where) {
		if (
			// The set is a proper subset when its length is less than the other set.
			coveredSession[kOriginSet].length < session[kOriginSet].length &&

			// And the other set includes all elements of the subset.
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&

			// Makes sure that the session can handle all requests from the covered session.
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			// This allows pending requests to finish and prevents making new requests.
			gracefullyClose(coveredSession);
		}
	}
};

// This is basically inverted `closeCoveredSessions(...)`.
const closeSessionIfCovered = (where, coveredSession) => {
	for (const session of where) {
		if (
			coveredSession[kOriginSet].length < session[kOriginSet].length &&
			coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&
			coveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams
		) {
			gracefullyClose(coveredSession);
		}
	}
};

const getSessions = ({agent, isFree}) => {
	const result = {};

	// eslint-disable-next-line guard-for-in
	for (const normalizedOptions in agent.sessions) {
		const sessions = agent.sessions[normalizedOptions];

		const filtered = sessions.filter(session => {
			const result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;

			return isFree ? result : !result;
		});

		if (filtered.length !== 0) {
			result[normalizedOptions] = filtered;
		}
	}

	return result;
};

const gracefullyClose = session => {
	session[kGracefullyClosing] = true;

	if (session[kCurrentStreamsCount] === 0) {
		session.close();
	}
};

class Agent extends EventEmitter {
	constructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {
		super();

		// A session is considered busy when its current streams count
		// is equal to or greater than the `maxConcurrentStreams` value.

		// A session is considered free when its current streams count
		// is less than the `maxConcurrentStreams` value.

		// SESSIONS[NORMALIZED_OPTIONS] = [];
		this.sessions = {};

		// The queue for creating new sessions. It looks like this:
		// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION
		//
		// The entry function has `listeners`, `completed` and `destroyed` properties.
		// `listeners` is an array of objects containing `resolve` and `reject` functions.
		// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.
		// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.
		this.queue = {};

		// Each session will use this timeout value.
		this.timeout = timeout;

		// Max sessions in total
		this.maxSessions = maxSessions;

		// Max free sessions in total
		// TODO: decreasing `maxFreeSessions` should close some sessions
		this.maxFreeSessions = maxFreeSessions;

		this._freeSessionsCount = 0;
		this._sessionsCount = 0;

		// We don't support push streams by default.
		this.settings = {
			enablePush: false
		};

		// Reusing TLS sessions increases performance.
		this.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});
	}

	static normalizeOrigin(url, servername) {
		if (typeof url === 'string') {
			url = new URL(url);
		}

		if (servername && url.hostname !== servername) {
			url.hostname = servername;
		}

		return url.origin;
	}

	normalizeOptions(options) {
		let normalized = '';

		if (options) {
			for (const key of nameKeys) {
				if (options[key]) {
					normalized += `:${options[key]}`;
				}
			}
		}

		return normalized;
	}

	_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {
		if (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {
			return;
		}

		const item = this.queue[normalizedOptions][normalizedOrigin];

		// The entry function can be run only once.
		// BUG: The session may be never created when:
		// - the first condition is false AND
		// - this function is never called with the same arguments in the future.
		if (this._sessionsCount < this.maxSessions && !item.completed) {
			item.completed = true;

			item();
		}
	}

	getSession(origin, options, listeners) {
		return new Promise((resolve, reject) => {
			if (Array.isArray(listeners)) {
				listeners = [...listeners];

				// Resolve the current promise ASAP, we're just moving the listeners.
				// They will be executed at a different time.
				resolve();
			} else {
				listeners = [{resolve, reject}];
			}

			const normalizedOptions = this.normalizeOptions(options);
			const normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);

			if (normalizedOrigin === undefined) {
				for (const {reject} of listeners) {
					reject(new TypeError('The `origin` argument needs to be a string or an URL object'));
				}

				return;
			}

			if (normalizedOptions in this.sessions) {
				const sessions = this.sessions[normalizedOptions];

				let maxConcurrentStreams = -1;
				let currentStreamsCount = -1;
				let optimalSession;

				// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.
				// Additionally, we are looking for session which has biggest current pending streams count.
				for (const session of sessions) {
					const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;

					if (sessionMaxConcurrentStreams < maxConcurrentStreams) {
						break;
					}

					if (session[kOriginSet].includes(normalizedOrigin)) {
						const sessionCurrentStreamsCount = session[kCurrentStreamsCount];

						if (
							sessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||
							session[kGracefullyClosing] ||
							// Unfortunately the `close` event isn't called immediately,
							// so `session.destroyed` is `true`, but `session.closed` is `false`.
							session.destroyed
						) {
							continue;
						}

						// We only need set this once.
						if (!optimalSession) {
							maxConcurrentStreams = sessionMaxConcurrentStreams;
						}

						// We're looking for the session which has biggest current pending stream count,
						// in order to minimalize the amount of active sessions.
						if (sessionCurrentStreamsCount > currentStreamsCount) {
							optimalSession = session;
							currentStreamsCount = sessionCurrentStreamsCount;
						}
					}
				}

				if (optimalSession) {
					/* istanbul ignore next: safety check */
					if (listeners.length !== 1) {
						for (const {reject} of listeners) {
							const error = new Error(
								`Expected the length of listeners to be 1, got ${listeners.length}.\n` +
								'Please report this to https://github.com/szmarczak/http2-wrapper/'
							);

							reject(error);
						}

						return;
					}

					listeners[0].resolve(optimalSession);
					return;
				}
			}

			if (normalizedOptions in this.queue) {
				if (normalizedOrigin in this.queue[normalizedOptions]) {
					// There's already an item in the queue, just attach ourselves to it.
					this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);

					// This shouldn't be executed here.
					// See the comment inside _tryToCreateNewSession.
					this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					return;
				}
			} else {
				this.queue[normalizedOptions] = {};
			}

			// The entry must be removed from the queue IMMEDIATELY when:
			// 1. the session connects successfully,
			// 2. an error occurs.
			const removeFromQueue = () => {
				// Our entry can be replaced. We cannot remove the new one.
				if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {
					delete this.queue[normalizedOptions][normalizedOrigin];

					if (Object.keys(this.queue[normalizedOptions]).length === 0) {
						delete this.queue[normalizedOptions];
					}
				}
			};

			// The main logic is here
			const entry = () => {
				const name = `${normalizedOrigin}:${normalizedOptions}`;
				let receivedSettings = false;

				try {
					const session = http2.connect(origin, {
						createConnection: this.createConnection,
						settings: this.settings,
						session: this.tlsSessionCache.get(name),
						...options
					});
					session[kCurrentStreamsCount] = 0;
					session[kGracefullyClosing] = false;

					const isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;
					let wasFree = true;

					session.socket.once('session', tlsSession => {
						this.tlsSessionCache.set(name, tlsSession);
					});

					session.once('error', error => {
						// Listeners are empty when the session successfully connected.
						for (const {reject} of listeners) {
							reject(error);
						}

						// The connection got broken, purge the cache.
						this.tlsSessionCache.delete(name);
					});

					session.setTimeout(this.timeout, () => {
						// Terminates all streams owned by this session.
						// TODO: Maybe the streams should have a "Session timed out" error?
						session.destroy();
					});

					session.once('close', () => {
						if (receivedSettings) {
							// 1. If it wasn't free then no need to decrease because
							//    it has been decreased already in session.request().
							// 2. `stream.once('close')` won't increment the count
							//    because the session is already closed.
							if (wasFree) {
								this._freeSessionsCount--;
							}

							this._sessionsCount--;

							// This cannot be moved to the stream logic,
							// because there may be a session that hadn't made a single request.
							const where = this.sessions[normalizedOptions];
							where.splice(where.indexOf(session), 1);

							if (where.length === 0) {
								delete this.sessions[normalizedOptions];
							}
						} else {
							// Broken connection
							const error = new Error('Session closed without receiving a SETTINGS frame');
							error.code = 'HTTP2WRAPPER_NOSETTINGS';

							for (const {reject} of listeners) {
								reject(error);
							}

							removeFromQueue();
						}

						// There may be another session awaiting.
						this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
					});

					// Iterates over the queue and processes listeners.
					const processListeners = () => {
						if (!(normalizedOptions in this.queue) || !isFree()) {
							return;
						}

						for (const origin of session[kOriginSet]) {
							if (origin in this.queue[normalizedOptions]) {
								const {listeners} = this.queue[normalizedOptions][origin];

								// Prevents session overloading.
								while (listeners.length !== 0 && isFree()) {
									// We assume `resolve(...)` calls `request(...)` *directly*,
									// otherwise the session will get overloaded.
									listeners.shift().resolve(session);
								}

								const where = this.queue[normalizedOptions];
								if (where[origin].listeners.length === 0) {
									delete where[origin];

									if (Object.keys(where).length === 0) {
										delete this.queue[normalizedOptions];
										break;
									}
								}

								// We're no longer free, no point in continuing.
								if (!isFree()) {
									break;
								}
							}
						}
					};

					// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.
					session.on('origin', () => {
						session[kOriginSet] = session.originSet;

						if (!isFree()) {
							// The session is full.
							return;
						}

						processListeners();

						// Close covered sessions (if possible).
						closeCoveredSessions(this.sessions[normalizedOptions], session);
					});

					session.once('remoteSettings', () => {
						// Fix Node.js bug preventing the process from exiting
						session.ref();
						session.unref();

						this._sessionsCount++;

						// The Agent could have been destroyed already.
						if (entry.destroyed) {
							const error = new Error('Agent has been destroyed');

							for (const listener of listeners) {
								listener.reject(error);
							}

							session.destroy();
							return;
						}

						session[kOriginSet] = session.originSet;

						{
							const where = this.sessions;

							if (normalizedOptions in where) {
								const sessions = where[normalizedOptions];
								sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
							} else {
								where[normalizedOptions] = [session];
							}
						}

						this._freeSessionsCount += 1;
						receivedSettings = true;

						this.emit('session', session);

						processListeners();
						removeFromQueue();

						// TODO: Close last recently used (or least used?) session
						if (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {
							session.close();
						}

						// Check if we haven't managed to execute all listeners.
						if (listeners.length !== 0) {
							// Request for a new session with predefined listeners.
							this.getSession(normalizedOrigin, options, listeners);
							listeners.length = 0;
						}

						// `session.remoteSettings.maxConcurrentStreams` might get increased
						session.on('remoteSettings', () => {
							processListeners();

							// In case the Origin Set changes
							closeCoveredSessions(this.sessions[normalizedOptions], session);
						});
					});

					// Shim `session.request()` in order to catch all streams
					session[kRequest] = session.request;
					session.request = (headers, streamOptions) => {
						if (session[kGracefullyClosing]) {
							throw new Error('The session is gracefully closing. No new streams are allowed.');
						}

						const stream = session[kRequest](headers, streamOptions);

						// The process won't exit until the session is closed or all requests are gone.
						session.ref();

						++session[kCurrentStreamsCount];

						if (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {
							this._freeSessionsCount--;
						}

						stream.once('close', () => {
							wasFree = isFree();

							--session[kCurrentStreamsCount];

							if (!session.destroyed && !session.closed) {
								closeSessionIfCovered(this.sessions[normalizedOptions], session);

								if (isFree() && !session.closed) {
									if (!wasFree) {
										this._freeSessionsCount++;

										wasFree = true;
									}

									const isEmpty = session[kCurrentStreamsCount] === 0;

									if (isEmpty) {
										session.unref();
									}

									if (
										isEmpty &&
										(
											this._freeSessionsCount > this.maxFreeSessions ||
											session[kGracefullyClosing]
										)
									) {
										session.close();
									} else {
										closeCoveredSessions(this.sessions[normalizedOptions], session);
										processListeners();
									}
								}
							}
						});

						return stream;
					};
				} catch (error) {
					for (const listener of listeners) {
						listener.reject(error);
					}

					removeFromQueue();
				}
			};

			entry.listeners = listeners;
			entry.completed = false;
			entry.destroyed = false;

			this.queue[normalizedOptions][normalizedOrigin] = entry;
			this._tryToCreateNewSession(normalizedOptions, normalizedOrigin);
		});
	}

	request(origin, options, headers, streamOptions) {
		return new Promise((resolve, reject) => {
			this.getSession(origin, options, [{
				reject,
				resolve: session => {
					try {
						resolve(session.request(headers, streamOptions));
					} catch (error) {
						reject(error);
					}
				}
			}]);
		});
	}

	createConnection(origin, options) {
		return Agent.connect(origin, options);
	}

	static connect(origin, options) {
		options.ALPNProtocols = ['h2'];

		const port = origin.port || 443;
		const host = origin.hostname || origin.host;

		if (typeof options.servername === 'undefined') {
			options.servername = host;
		}

		return tls.connect(port, host, options);
	}

	closeFreeSessions() {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				if (session[kCurrentStreamsCount] === 0) {
					session.close();
				}
			}
		}
	}

	destroy(reason) {
		for (const sessions of Object.values(this.sessions)) {
			for (const session of sessions) {
				session.destroy(reason);
			}
		}

		for (const entriesOfAuthority of Object.values(this.queue)) {
			for (const entry of Object.values(entriesOfAuthority)) {
				entry.destroyed = true;
			}
		}

		// New requests should NOT attach to destroyed sessions
		this.queue = {};
	}

	get freeSessions() {
		return getSessions({agent: this, isFree: true});
	}

	get busySessions() {
		return getSessions({agent: this, isFree: false});
	}
}

Agent.kCurrentStreamsCount = kCurrentStreamsCount;
Agent.kGracefullyClosing = kGracefullyClosing;

module.exports = {
	Agent,
	globalAgent: new Agent()
};


/***/ }),

/***/ 7167:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const http = __nccwpck_require__(3685);
const https = __nccwpck_require__(5687);
const resolveALPN = __nccwpck_require__(6624);
const QuickLRU = __nccwpck_require__(9273);
const Http2ClientRequest = __nccwpck_require__(9632);
const calculateServerName = __nccwpck_require__(1982);
const urlToOptions = __nccwpck_require__(2686);

const cache = new QuickLRU({maxSize: 100});
const queue = new Map();

const installSocket = (agent, socket, options) => {
	socket._httpMessage = {shouldKeepAlive: true};

	const onFree = () => {
		agent.emit('free', socket, options);
	};

	socket.on('free', onFree);

	const onClose = () => {
		agent.removeSocket(socket, options);
	};

	socket.on('close', onClose);

	const onRemove = () => {
		agent.removeSocket(socket, options);
		socket.off('close', onClose);
		socket.off('free', onFree);
		socket.off('agentRemove', onRemove);
	};

	socket.on('agentRemove', onRemove);

	agent.emit('free', socket, options);
};

const resolveProtocol = async options => {
	const name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;

	if (!cache.has(name)) {
		if (queue.has(name)) {
			const result = await queue.get(name);
			return result.alpnProtocol;
		}

		const {path, agent} = options;
		options.path = options.socketPath;

		const resultPromise = resolveALPN(options);
		queue.set(name, resultPromise);

		try {
			const {socket, alpnProtocol} = await resultPromise;
			cache.set(name, alpnProtocol);

			options.path = path;

			if (alpnProtocol === 'h2') {
				// https://github.com/nodejs/node/issues/33343
				socket.destroy();
			} else {
				const {globalAgent} = https;
				const defaultCreateConnection = https.Agent.prototype.createConnection;

				if (agent) {
					if (agent.createConnection === defaultCreateConnection) {
						installSocket(agent, socket, options);
					} else {
						socket.destroy();
					}
				} else if (globalAgent.createConnection === defaultCreateConnection) {
					installSocket(globalAgent, socket, options);
				} else {
					socket.destroy();
				}
			}

			queue.delete(name);

			return alpnProtocol;
		} catch (error) {
			queue.delete(name);

			throw error;
		}
	}

	return cache.get(name);
};

module.exports = async (input, options, callback) => {
	if (typeof input === 'string' || input instanceof URL) {
		input = urlToOptions(new URL(input));
	}

	if (typeof options === 'function') {
		callback = options;
		options = undefined;
	}

	options = {
		ALPNProtocols: ['h2', 'http/1.1'],
		...input,
		...options,
		resolveSocket: true
	};

	if (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {
		throw new Error('The `ALPNProtocols` option must be an Array with at least one entry');
	}

	options.protocol = options.protocol || 'https:';
	const isHttps = options.protocol === 'https:';

	options.host = options.hostname || options.host || 'localhost';
	options.session = options.tlsSession;
	options.servername = options.servername || calculateServerName(options);
	options.port = options.port || (isHttps ? 443 : 80);
	options._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;

	const agents = options.agent;

	if (agents) {
		if (agents.addRequest) {
			throw new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');
		}

		options.agent = agents[isHttps ? 'https' : 'http'];
	}

	if (isHttps) {
		const protocol = await resolveProtocol(options);

		if (protocol === 'h2') {
			if (agents) {
				options.agent = agents.http2;
			}

			return new Http2ClientRequest(options, callback);
		}
	}

	return http.request(options, callback);
};

module.exports.protocolCache = cache;


/***/ }),

/***/ 9632:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const http2 = __nccwpck_require__(5158);
const {Writable} = __nccwpck_require__(2781);
const {Agent, globalAgent} = __nccwpck_require__(9898);
const IncomingMessage = __nccwpck_require__(2575);
const urlToOptions = __nccwpck_require__(2686);
const proxyEvents = __nccwpck_require__(1818);
const isRequestPseudoHeader = __nccwpck_require__(1199);
const {
	ERR_INVALID_ARG_TYPE,
	ERR_INVALID_PROTOCOL,
	ERR_HTTP_HEADERS_SENT,
	ERR_INVALID_HTTP_TOKEN,
	ERR_HTTP_INVALID_HEADER_VALUE,
	ERR_INVALID_CHAR
} = __nccwpck_require__(7087);

const {
	HTTP2_HEADER_STATUS,
	HTTP2_HEADER_METHOD,
	HTTP2_HEADER_PATH,
	HTTP2_METHOD_CONNECT
} = http2.constants;

const kHeaders = Symbol('headers');
const kOrigin = Symbol('origin');
const kSession = Symbol('session');
const kOptions = Symbol('options');
const kFlushedHeaders = Symbol('flushedHeaders');
const kJobs = Symbol('jobs');

const isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
const isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;

class ClientRequest extends Writable {
	constructor(input, options, callback) {
		super({
			autoDestroy: false
		});

		const hasInput = typeof input === 'string' || input instanceof URL;
		if (hasInput) {
			input = urlToOptions(input instanceof URL ? input : new URL(input));
		}

		if (typeof options === 'function' || options === undefined) {
			// (options, callback)
			callback = options;
			options = hasInput ? input : {...input};
		} else {
			// (input, options, callback)
			options = {...input, ...options};
		}

		if (options.h2session) {
			this[kSession] = options.h2session;
		} else if (options.agent === false) {
			this.agent = new Agent({maxFreeSessions: 0});
		} else if (typeof options.agent === 'undefined' || options.agent === null) {
			if (typeof options.createConnection === 'function') {
				// This is a workaround - we don't have to create the session on our own.
				this.agent = new Agent({maxFreeSessions: 0});
				this.agent.createConnection = options.createConnection;
			} else {
				this.agent = globalAgent;
			}
		} else if (typeof options.agent.request === 'function') {
			this.agent = options.agent;
		} else {
			throw new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);
		}

		if (options.protocol && options.protocol !== 'https:') {
			throw new ERR_INVALID_PROTOCOL(options.protocol, 'https:');
		}

		const port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;
		const host = options.hostname || options.host || 'localhost';

		// Don't enforce the origin via options. It may be changed in an Agent.
		delete options.hostname;
		delete options.host;
		delete options.port;

		const {timeout} = options;
		options.timeout = undefined;

		this[kHeaders] = Object.create(null);
		this[kJobs] = [];

		this.socket = null;
		this.connection = null;

		this.method = options.method || 'GET';
		this.path = options.path;

		this.res = null;
		this.aborted = false;
		this.reusedSocket = false;

		if (options.headers) {
			for (const [header, value] of Object.entries(options.headers)) {
				this.setHeader(header, value);
			}
		}

		if (options.auth && !('authorization' in this[kHeaders])) {
			this[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');
		}

		options.session = options.tlsSession;
		options.path = options.socketPath;

		this[kOptions] = options;

		// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.
		if (port === 443) {
			this[kOrigin] = `https://${host}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = host;
			}
		} else {
			this[kOrigin] = `https://${host}:${port}`;

			if (!(':authority' in this[kHeaders])) {
				this[kHeaders][':authority'] = `${host}:${port}`;
			}
		}

		if (timeout) {
			this.setTimeout(timeout);
		}

		if (callback) {
			this.once('response', callback);
		}

		this[kFlushedHeaders] = false;
	}

	get method() {
		return this[kHeaders][HTTP2_HEADER_METHOD];
	}

	set method(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();
		}
	}

	get path() {
		return this[kHeaders][HTTP2_HEADER_PATH];
	}

	set path(value) {
		if (value) {
			this[kHeaders][HTTP2_HEADER_PATH] = value;
		}
	}

	get _mustNotHaveABody() {
		return this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';
	}

	_write(chunk, encoding, callback) {
		// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156
		if (this._mustNotHaveABody) {
			callback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));
			/* istanbul ignore next: Node.js 12 throws directly */
			return;
		}

		this.flushHeaders();

		const callWrite = () => this._request.write(chunk, encoding, callback);
		if (this._request) {
			callWrite();
		} else {
			this[kJobs].push(callWrite);
		}
	}

	_final(callback) {
		if (this.destroyed) {
			return;
		}

		this.flushHeaders();

		const callEnd = () => {
			// For GET, HEAD and DELETE
			if (this._mustNotHaveABody) {
				callback();
				return;
			}

			this._request.end(callback);
		};

		if (this._request) {
			callEnd();
		} else {
			this[kJobs].push(callEnd);
		}
	}

	abort() {
		if (this.res && this.res.complete) {
			return;
		}

		if (!this.aborted) {
			process.nextTick(() => this.emit('abort'));
		}

		this.aborted = true;

		this.destroy();
	}

	_destroy(error, callback) {
		if (this.res) {
			this.res._dump();
		}

		if (this._request) {
			this._request.destroy();
		}

		callback(error);
	}

	async flushHeaders() {
		if (this[kFlushedHeaders] || this.destroyed) {
			return;
		}

		this[kFlushedHeaders] = true;

		const isConnectMethod = this.method === HTTP2_METHOD_CONNECT;

		// The real magic is here
		const onStream = stream => {
			this._request = stream;

			if (this.destroyed) {
				stream.destroy();
				return;
			}

			// Forwards `timeout`, `continue`, `close` and `error` events to this instance.
			if (!isConnectMethod) {
				proxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);
			}

			// Wait for the `finish` event. We don't want to emit the `response` event
			// before `request.end()` is called.
			const waitForEnd = fn => {
				return (...args) => {
					if (!this.writable && !this.destroyed) {
						fn(...args);
					} else {
						this.once('finish', () => {
							fn(...args);
						});
					}
				};
			};

			// This event tells we are ready to listen for the data.
			stream.once('response', waitForEnd((headers, flags, rawHeaders) => {
				// If we were to emit raw request stream, it would be as fast as the native approach.
				// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).
				const response = new IncomingMessage(this.socket, stream.readableHighWaterMark);
				this.res = response;

				response.req = this;
				response.statusCode = headers[HTTP2_HEADER_STATUS];
				response.headers = headers;
				response.rawHeaders = rawHeaders;

				response.once('end', () => {
					if (this.aborted) {
						response.aborted = true;
						response.emit('aborted');
					} else {
						response.complete = true;

						// Has no effect, just be consistent with the Node.js behavior
						response.socket = null;
						response.connection = null;
					}
				});

				if (isConnectMethod) {
					response.upgrade = true;

					// The HTTP1 API says the socket is detached here,
					// but we can't do that so we pass the original HTTP2 request.
					if (this.emit('connect', response, stream, Buffer.alloc(0))) {
						this.emit('close');
					} else {
						// No listeners attached, destroy the original request.
						stream.destroy();
					}
				} else {
					// Forwards data
					stream.on('data', chunk => {
						if (!response._dumped && !response.push(chunk)) {
							stream.pause();
						}
					});

					stream.once('end', () => {
						response.push(null);
					});

					if (!this.emit('response', response)) {
						// No listeners attached, dump the response.
						response._dump();
					}
				}
			}));

			// Emits `information` event
			stream.once('headers', waitForEnd(
				headers => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})
			));

			stream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {
				const {res} = this;

				// Assigns trailers to the response object.
				res.trailers = trailers;
				res.rawTrailers = rawTrailers;
			}));

			const {socket} = stream.session;
			this.socket = socket;
			this.connection = socket;

			for (const job of this[kJobs]) {
				job();
			}

			this.emit('socket', this.socket);
		};

		// Makes a HTTP2 request
		if (this[kSession]) {
			try {
				onStream(this[kSession].request(this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		} else {
			this.reusedSocket = true;

			try {
				onStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));
			} catch (error) {
				this.emit('error', error);
			}
		}
	}

	getHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		return this[kHeaders][name.toLowerCase()];
	}

	get headersSent() {
		return this[kFlushedHeaders];
	}

	removeHeader(name) {
		if (typeof name !== 'string') {
			throw new ERR_INVALID_ARG_TYPE('name', 'string', name);
		}

		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('remove');
		}

		delete this[kHeaders][name.toLowerCase()];
	}

	setHeader(name, value) {
		if (this.headersSent) {
			throw new ERR_HTTP_HEADERS_SENT('set');
		}

		if (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {
			throw new ERR_INVALID_HTTP_TOKEN('Header name', name);
		}

		if (typeof value === 'undefined') {
			throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
		}

		if (isInvalidHeaderValue.test(value)) {
			throw new ERR_INVALID_CHAR('header content', name);
		}

		this[kHeaders][name.toLowerCase()] = value;
	}

	setNoDelay() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setSocketKeepAlive() {
		// HTTP2 sockets cannot be malformed, do nothing.
	}

	setTimeout(ms, callback) {
		const applyTimeout = () => this._request.setTimeout(ms, callback);

		if (this._request) {
			applyTimeout();
		} else {
			this[kJobs].push(applyTimeout);
		}

		return this;
	}

	get maxHeadersCount() {
		if (!this.destroyed && this._request) {
			return this._request.session.localSettings.maxHeaderListSize;
		}

		return undefined;
	}

	set maxHeadersCount(_value) {
		// Updating HTTP2 settings would affect all requests, do nothing.
	}
}

module.exports = ClientRequest;


/***/ }),

/***/ 2575:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const {Readable} = __nccwpck_require__(2781);

class IncomingMessage extends Readable {
	constructor(socket, highWaterMark) {
		super({
			highWaterMark,
			autoDestroy: false
		});

		this.statusCode = null;
		this.statusMessage = '';
		this.httpVersion = '2.0';
		this.httpVersionMajor = 2;
		this.httpVersionMinor = 0;
		this.headers = {};
		this.trailers = {};
		this.req = null;

		this.aborted = false;
		this.complete = false;
		this.upgrade = null;

		this.rawHeaders = [];
		this.rawTrailers = [];

		this.socket = socket;
		this.connection = socket;

		this._dumped = false;
	}

	_destroy(error) {
		this.req._request.destroy(error);
	}

	setTimeout(ms, callback) {
		this.req.setTimeout(ms, callback);
		return this;
	}

	_dump() {
		if (!this._dumped) {
			this._dumped = true;

			this.removeAllListeners('data');
			this.resume();
		}
	}

	_read() {
		if (this.req) {
			this.req._request.resume();
		}
	}
}

module.exports = IncomingMessage;


/***/ }),

/***/ 4645:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const http2 = __nccwpck_require__(5158);
const agent = __nccwpck_require__(9898);
const ClientRequest = __nccwpck_require__(9632);
const IncomingMessage = __nccwpck_require__(2575);
const auto = __nccwpck_require__(7167);

const request = (url, options, callback) => {
	return new ClientRequest(url, options, callback);
};

const get = (url, options, callback) => {
	// eslint-disable-next-line unicorn/prevent-abbreviations
	const req = new ClientRequest(url, options, callback);
	req.end();

	return req;
};

module.exports = {
	...http2,
	ClientRequest,
	IncomingMessage,
	...agent,
	request,
	get,
	auto
};


/***/ }),

/***/ 1982:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const net = __nccwpck_require__(1808);
/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */

module.exports = options => {
	let servername = options.host;
	const hostHeader = options.headers && options.headers.host;

	if (hostHeader) {
		if (hostHeader.startsWith('[')) {
			const index = hostHeader.indexOf(']');
			if (index === -1) {
				servername = hostHeader;
			} else {
				servername = hostHeader.slice(1, -1);
			}
		} else {
			servername = hostHeader.split(':', 1)[0];
		}
	}

	if (net.isIP(servername)) {
		return '';
	}

	return servername;
};


/***/ }),

/***/ 7087:
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */

const makeError = (Base, key, getMessage) => {
	module.exports[key] = class NodeError extends Base {
		constructor(...args) {
			super(typeof getMessage === 'string' ? getMessage : getMessage(args));
			this.name = `${super.name} [${key}]`;
			this.code = key;
		}
	};
};

makeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {
	const type = args[0].includes('.') ? 'property' : 'argument';

	let valid = args[1];
	const isManyTypes = Array.isArray(valid);

	if (isManyTypes) {
		valid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;
	}

	return `The "${args[0]}" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;
});

makeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {
	return `Protocol "${args[0]}" not supported. Expected "${args[1]}"`;
});

makeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {
	return `Cannot ${args[0]} headers after they are sent to the client`;
});

makeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {
	return `${args[0]} must be a valid HTTP token [${args[1]}]`;
});

makeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {
	return `Invalid value "${args[0]} for header "${args[1]}"`;
});

makeError(TypeError, 'ERR_INVALID_CHAR', args => {
	return `Invalid character in ${args[0]} [${args[1]}]`;
});


/***/ }),

/***/ 1199:
/***/ ((module) => {

"use strict";


module.exports = header => {
	switch (header) {
		case ':method':
		case ':scheme':
		case ':authority':
		case ':path':
			return true;
		default:
			return false;
	}
};


/***/ }),

/***/ 1818:
/***/ ((module) => {

"use strict";


module.exports = (from, to, events) => {
	for (const event of events) {
		from.on(event, (...args) => to.emit(event, ...args));
	}
};


/***/ }),

/***/ 2686:
/***/ ((module) => {

"use strict";

/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */

module.exports = url => {
	const options = {
		protocol: url.protocol,
		hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,
		host: url.host,
		hash: url.hash,
		search: url.search,
		pathname: url.pathname,
		href: url.href,
		path: `${url.pathname || ''}${url.search || ''}`
	};

	if (typeof url.port === 'string' && url.port.length !== 0) {
		options.port = Number(url.port);
	}

	if (url.username || url.password) {
		options.auth = `${url.username || ''}:${url.password || ''}`;
	}

	return options;
};


/***/ }),

/***/ 6435:
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),

/***/ 4466:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __nccwpck_require__(6435);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }
      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);
      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);
      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }
      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

var relaxedCheck = function(str) {
  if (str[0] === '!') {
    return true;
  }
  var index = 0;
  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);
        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }
  return false;
};

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck;

  // optionally relax check
  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};


/***/ }),

/***/ 5680:
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),

/***/ 2820:
/***/ ((__unused_webpack_module, exports) => {

//TODO: handle reviver/dehydrate function like normal
//and handle indentation, like normal.
//if anyone needs this... please send pull request.

exports.stringify = function stringify (o) {
  if('undefined' == typeof o) return o

  if(o && Buffer.isBuffer(o))
    return JSON.stringify(':base64:' + o.toString('base64'))

  if(o && o.toJSON)
    o =  o.toJSON()

  if(o && 'object' === typeof o) {
    var s = ''
    var array = Array.isArray(o)
    s = array ? '[' : '{'
    var first = true

    for(var k in o) {
      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])
      if(Object.hasOwnProperty.call(o, k) && !ignore) {
        if(!first)
          s += ','
        first = false
        if (array) {
          if(o[k] == undefined)
            s += 'null'
          else
            s += stringify(o[k])
        } else if (o[k] !== void(0)) {
          s += stringify(k) + ':' + stringify(o[k])
        }
      }
    }

    s += array ? ']' : '}'

    return s
  } else if ('string' === typeof o) {
    return JSON.stringify(/^:/.test(o) ? ':' + o : o)
  } else if ('undefined' === typeof o) {
    return 'null';
  } else
    return JSON.stringify(o)
}

exports.parse = function (s) {
  return JSON.parse(s, function (key, value) {
    if('string' === typeof value) {
      if(/^:base64:/.test(value))
        return Buffer.from(value.substring(8), 'base64')
      else
        return /^:/.test(value) ? value.substring(1) : value 
    }
    return value
  })
}


/***/ }),

/***/ 3081:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*
 * @license MIT http://www.opensource.org/licenses/mit-license.php
 * @author  Hovhannes Babayan <bhovhannes at gmail dot com>
 */

const { mergeFiles } = __nccwpck_require__(7795);
const { mergeStreams } = __nccwpck_require__(3902);
const { mergeToString } = __nccwpck_require__(4819);

module.exports = {
    mergeFiles,
    mergeStreams,
    mergeToString,
};


/***/ }),

/***/ 8023:
/***/ ((module) => {

function normalizeArgs(options, cb) {
    let normalizedOptions = options || {};
    let callback;
    if (typeof cb === "function") {
        callback = cb;
    } else if (typeof options === "function" && !cb) {
        normalizedOptions = {};
        callback = options;
    }

    let returnValue;
    if (!callback) {
        returnValue = new Promise((resolve, reject) => {
            callback = (err, value) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(value);
                }
            };
        });
    }

    return {
        callback,
        normalizedOptions,
        returnValue,
    };
}

async function readableToString(readable) {
    let result = "";
    for await (const chunk of readable) {
        result += chunk;
    }
    return result;
}

module.exports = {
    normalizeArgs,
    readableToString,
};


/***/ }),

/***/ 7795:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const fs = __nccwpck_require__(7147)
const fastGlob = __nccwpck_require__(3664)
const { normalizeArgs } = __nccwpck_require__(8023)
const { mergeStreams } = __nccwpck_require__(3902)

/**
 * @typedef {Object} MatchInfo  Describes a single file match which will be processed
 * @property {string} filePath   Path to the file
 *
 * @callback MergeFilesCallback
 * @param {MatchInfo} matchInfo
 * @returns {void}
 *
 * @typedef {Object} MergeFilesOptions
 * @property {MergeFilesCallback} [onFileMatched]  A callback function which will be called for the each match
 *
 * @callback TMergeFilesCompletionCallback
 * @param {Error} [err]  Error if any
 * @return {void}
 *
 *
 * @callback MergeFilesCallbackStyle Reads multiple files, merges their contents and write into the given file.
 * @param {String} destFilePath   Where the output should be stored. Denotes a path to file. If file already exists, it will be overwritten.
 * @param {String[]} srcFilePathsOrGlobPatterns   Paths to the files which should be merged or glob patterns to find them.
 * @param {MergeFilesOptions} options   Merge options.
 * @param {TMergeFilesCompletionCallback} cb   Callback function which will be called at completion. Will receive error as first argument if any.
 * @return {void}
 *
 * @callback MergeFilesPromiseStyle Reads multiple files, merges their contents and write into the given file.
 * @param {String} destFilePath   Where the output should be stored. Denotes a path to file. If file already exists, it will be overwritten.
 * @param {String[]} srcFilePathsOrGlobPatterns   Paths to the files which should be merged or glob patterns to find them.
 * @param {MergeFilesOptions} [options]   Merge options. Currently unused.
 * @return {Promise<void>}
 *
 * @typedef {MergeFilesCallbackStyle & MergeFilesPromiseStyle} MergeFilesFn
 *
 * @type {MergeFilesFn}
 */
module.exports.mergeFiles = function (destFilePath, srcFilePathsOrGlobPatterns, options, cb) {
  const { callback, normalizedOptions, returnValue } = normalizeArgs(options, cb)

  fastGlob(srcFilePathsOrGlobPatterns, { dot: true }).then((srcFilePaths) => {
    const srcStreams = srcFilePaths.map(function (srcFilePath) {
      if (normalizedOptions.onFileMatched) {
        normalizedOptions.onFileMatched({
          filePath: srcFilePath
        })
      }
      return fs.createReadStream(srcFilePath, {
        flags: 'r',
        encoding: 'utf8',
        autoClose: true
      })
    })
    const destStream = fs.createWriteStream(destFilePath, {
      flags: 'w',
      defaultEncoding: 'utf8',
      autoClose: true
    })
    mergeStreams(destStream, srcStreams, {}, function () {
      destStream.end()
      callback()
    })
  }, callback)

  return returnValue
}


/***/ }),

/***/ 3902:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { normalizeArgs, readableToString } = __nccwpck_require__(8023)
const { mergeToString } = __nccwpck_require__(4819)

/**
 * @typedef {{}} MergeStreamsOptions
 *
 * @callback TMergeStreamsCallback
 * @param {Error} [err]  Error if any
 * @return {void}
 *
 *
 * @callback MergeStreamsCallbackStyle
 * @param {import('stream').Writable} destStream   A stream which will be used to write the merge result.
 * @param {import('stream').Readable[]} srcStreams   Streams which will be used to read data from.
 * @param {MergeStreamsOptions} options   Merge options. Currently unused.
 * @param {TMergeStreamsCallback} cb   Callback function which will be called at completion. Will receive error as first argument if any.
 * @return {void}
 *
 * @callback MergeStreamsPromiseStyle
 * @param {import('stream').Writable} destStream   A stream which will be used to write the merge result.
 * @param {import('stream').Readable[]} srcStreams   Streams which will be used to read data from.
 * @param {MergeStreamsOptions} [options]   Merge options. Currently unused.
 * @return {Promise<void>}
 *
 * @typedef {MergeStreamsCallbackStyle & MergeStreamsPromiseStyle} MergeStreamsFn
 *
 * @type {MergeStreamsFn}
 */
module.exports.mergeStreams = function (destStream, srcStreams, options, cb) {
  const { callback, normalizedOptions, returnValue } = normalizeArgs(options, cb)

  Promise.all(srcStreams.map(readableToString)).then((srcStrings) => {
    let destString = mergeToString(srcStrings, options)
    destStream.on('error', callback)
    destStream.write(destString, 'utf8', callback)
  }, callback)

  return returnValue
}


/***/ }),

/***/ 4819:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

const { create } = __nccwpck_require__(151)

/**
 * @typedef {{}} MergeStringsOptions
 */

/**
 * Merges contents of given XML strings and returns resulting XML string.
 * @param {String[]} srcStrings   Array of strings to merge together.
 * @param {MergeStringsOptions} [options]   Merge options. Currently unused.
 * @return {String}
 */
module.exports.mergeToString = function (srcStrings, options) {
  const targetDoc = create({
    testsuites: {}
  })

  const attrs = {
    failures: 0,
    errors: 0,
    tests: 0
  }

  srcStrings.forEach((srcString) => {
    const doc = create(srcString, {})

    doc.root().each(
      (xmlBuilder) => {
        if (xmlBuilder.node.nodeName.toLowerCase() === 'testsuite') {
          for (const attrNode of xmlBuilder.node.attributes) {
            const name = attrNode.name
            if (name in attrs) {
              attrs[name] += Number(attrNode.value)
            }
          }
          targetDoc.root().import(xmlBuilder)
        }
      },
      true,
      true
    )

    for (const attr in attrs) {
      targetDoc.root().att(attr, attrs[attr])
    }
  })

  return targetDoc.toString({
    prettyPrint: true,
    noDoubleEncoding: true
  })
}


/***/ }),

/***/ 1531:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const EventEmitter = __nccwpck_require__(2361);
const JSONB = __nccwpck_require__(2820);
const compressBrotli = __nccwpck_require__(5728);

const loadStore = options => {
	const adapters = {
		redis: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
		mysql: '@keyv/mysql',
		etcd: '@keyv/etcd',
	};
	if (options.adapter || options.uri) {
		const adapter = options.adapter || /^[^:]*/.exec(options.uri)[0];
		return new (require(adapters[adapter]))(options);
	}

	return new Map();
};

const iterableAdapters = [
	'sqlite',
	'postgres',
	'mysql',
	'mongo',
	'redis',
];

class Keyv extends EventEmitter {
	constructor(uri, options) {
		super();
		this.opts = {
			namespace: 'keyv',
			serialize: JSONB.stringify,
			deserialize: JSONB.parse,
			...((typeof uri === 'string') ? {uri} : uri),
			...options,
		};

		if (!this.opts.store) {
			const adapterOptions = {...this.opts};
			this.opts.store = loadStore(adapterOptions);
		}

		if (this.opts.compress) {
			const brotli = compressBrotli(this.opts.compress.opts);
			this.opts.serialize = async ({value, expires}) => brotli.serialize({value: await brotli.compress(value), expires});
			this.opts.deserialize = async data => {
				const {value, expires} = brotli.deserialize(data);
				return {value: await brotli.decompress(value), expires};
			};
		}

		if (typeof this.opts.store.on === 'function') {
			this.opts.store.on('error', error => this.emit('error', error));
		}

		this.opts.store.namespace = this.opts.namespace;

		const generateIterator = iterator =>
			async function * () {
				for await (const [key, raw] of typeof iterator === 'function'
					? iterator(this.opts.store.namespace)
					: iterator) {
					const data = typeof raw === 'string' ? this.opts.deserialize(raw) : raw;
					if (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {
						continue;
					}

					if (typeof data.expires === 'number' && Date.now() > data.expires) {
						this.delete(key);
						continue;
					}

					yield [this._getKeyUnprefix(key), data.value];
				}
			};

		// Attach iterators
		if (typeof this.opts.store[Symbol.iterator] === 'function' && this.opts.store instanceof Map) {
			this.iterator = generateIterator(this.opts.store);
		} else if (typeof this.opts.store.iterator === 'function' && this.opts.store.opts
			&& this._checkIterableAdaptar()) {
			this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));
		}
	}

	_checkIterableAdaptar() {
		return iterableAdapters.includes(this.opts.store.opts.dialect)
			|| iterableAdapters.findIndex(element => this.opts.store.opts.url.includes(element)) >= 0;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

	_getKeyPrefixArray(keys) {
		return keys.map(key => `${this.opts.namespace}:${key}`);
	}

	_getKeyUnprefix(key) {
		return this.opts.store.namespace
			? key
				.split(':')
				.splice(1)
				.join(':')
			: key;
	}

	get(key, options) {
		const {store} = this.opts;
		const isArray = Array.isArray(key);
		const keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
		if (isArray && store.getMany === undefined) {
			const promises = [];
			for (const key of keyPrefixed) {
				promises.push(Promise.resolve()
					.then(() => store.get(key))
					.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : data)
					.then(data => {
						if (data === undefined || data === null) {
							return undefined;
						}

						if (typeof data.expires === 'number' && Date.now() > data.expires) {
							return this.delete(key).then(() => undefined);
						}

						return (options && options.raw) ? data : data.value;
					}),
				);
			}

			return Promise.allSettled(promises)
				.then(values => {
					const data = [];
					for (const value of values) {
						data.push(value.value);
					}

					return data.every(x => x === undefined) ? [] : data;
				});
		}

		return Promise.resolve()
			.then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed))
			.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : data)
			.then(data => {
				// Console.log('get', data);
				if (data === undefined || data === null) {
					return undefined;
				}

				if (isArray) {
					const result = [];
					if (data.length === 0) {
						return [];
					}

					for (let row of data) {
						if ((typeof row === 'string')) {
							row = this.opts.deserialize(row);
						}

						if (row === undefined || row === null) {
							result.push(undefined);
							continue;
						}

						if (typeof row.expires === 'number' && Date.now() > row.expires) {
							this.delete(key).then(() => undefined);
							result.push(undefined);
						} else {
							result.push((options && options.raw) ? row : row.value);
						}
					}

					return result.every(x => x === undefined) ? [] : result;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					return this.delete(key).then(() => undefined);
				}

				return (options && options.raw) ? data : data.value;
			});
	}

	set(key, value, ttl) {
		const keyPrefixed = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const {store} = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				if (typeof value === 'symbol') {
					this.emit('error', 'symbol cannot be serialized');
				}

				value = {value, expires};
				return this.opts.serialize(value);
			})
			.then(value => store.set(keyPrefixed, value, ttl))
			.then(() => true);
	}

	delete(key) {
		const {store} = this.opts;
		if (Array.isArray(key)) {
			const keyPrefixed = this._getKeyPrefixArray(key);
			if (store.deleteMany === undefined) {
				const promises = [];
				for (const key of keyPrefixed) {
					promises.push(store.delete(key));
				}

				return Promise.allSettled(promises)
					.then(values => values.every(x => x.value === true));
			}

			return Promise.resolve()
				.then(() => store.deleteMany(keyPrefixed));
		}

		const keyPrefixed = this._getKeyPrefix(key);
		return Promise.resolve()
			.then(() => store.delete(keyPrefixed));
	}

	clear() {
		const {store} = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}

	has(key) {
		const keyPrefixed = this._getKeyPrefix(key);
		const {store} = this.opts;
		return Promise.resolve()
			.then(async () => {
				if (typeof store.has === 'function') {
					return store.has(keyPrefixed);
				}

				const value = await store.get(keyPrefixed);
				return value !== undefined;
			});
	}
}

module.exports = Keyv;


/***/ }),

/***/ 9662:
/***/ ((module) => {

"use strict";

module.exports = object => {
	const result = {};

	for (const [key, value] of Object.entries(object)) {
		result[key.toLowerCase()] = value;
	}

	return result;
};


/***/ }),

/***/ 2578:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2020 Teambition
 * Licensed under the MIT license.
 */
const Stream = __nccwpck_require__(2781)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  const args = slice.call(arguments)
  let merging = false
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop()
  } else {
    options = {}
  }

  const doEnd = options.end !== false
  const doPipeError = options.pipeError === true
  if (options.objectMode == null) {
    options.objectMode = true
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024
  }
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) {
      return
    }
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) {
      streams = [streams]
    }

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) {
        return
      }
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        if (doPipeError) {
          stream.removeListener('error', onerror)
        }
        next()
      }
      function onerror (err) {
        mergedStream.emit('error', err)
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)

      if (doPipeError) {
        stream.on('error', onerror)
      }

      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    if (doEnd) {
      mergedStream.end()
    }
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) {
    addStream.apply(null, args)
  }
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
  }
  return streams
}


/***/ }),

/***/ 6228:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const util = __nccwpck_require__(3837);
const braces = __nccwpck_require__(610);
const picomatch = __nccwpck_require__(8569);
const utils = __nccwpck_require__(479);
const isEmptyString = val => val === '' || val === './';

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} `list` List of strings to match.
 * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `[options]` See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = new Set(micromatch(list, patterns, { ...options, onResult }));

  for (let item of items) {
    if (!matches.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.parse(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),

/***/ 7426:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __nccwpck_require__(3765)


/***/ }),

/***/ 3583:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __nccwpck_require__(7426)
var extname = (__nccwpck_require__(1017).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 2610:
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProps = [
	'destroy',
	'setTimeout',
	'socket',
	'headers',
	'trailers',
	'rawHeaders',
	'statusCode',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'rawTrailers',
	'statusMessage'
];

module.exports = (fromStream, toStream) => {
	const fromProps = new Set(Object.keys(fromStream).concat(knownProps));

	for (const prop of fromProps) {
		// Don't overwrite existing properties
		if (prop in toStream) {
			continue;
		}

		toStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];
	}
};


/***/ }),

/***/ 3973:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __nccwpck_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __nccwpck_require__(3717)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 7952:
/***/ ((module) => {

"use strict";


// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
const DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';
const DATA_URL_DEFAULT_CHARSET = 'us-ascii';

const testParameter = (name, filters) => {
	return filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);
};

const normalizeDataURL = (urlString, {stripHash}) => {
	const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);

	if (!match) {
		throw new Error(`Invalid URL: ${urlString}`);
	}

	let {type, data, hash} = match.groups;
	const mediaType = type.split(';');
	hash = stripHash ? '' : hash;

	let isBase64 = false;
	if (mediaType[mediaType.length - 1] === 'base64') {
		mediaType.pop();
		isBase64 = true;
	}

	// Lowercase MIME type
	const mimeType = (mediaType.shift() || '').toLowerCase();
	const attributes = mediaType
		.map(attribute => {
			let [key, value = ''] = attribute.split('=').map(string => string.trim());

			// Lowercase `charset`
			if (key === 'charset') {
				value = value.toLowerCase();

				if (value === DATA_URL_DEFAULT_CHARSET) {
					return '';
				}
			}

			return `${key}${value ? `=${value}` : ''}`;
		})
		.filter(Boolean);

	const normalizedMediaType = [
		...attributes
	];

	if (isBase64) {
		normalizedMediaType.push('base64');
	}

	if (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {
		normalizedMediaType.unshift(mimeType);
	}

	return `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;
};

const normalizeUrl = (urlString, options) => {
	options = {
		defaultProtocol: 'http:',
		normalizeProtocol: true,
		forceHttp: false,
		forceHttps: false,
		stripAuthentication: true,
		stripHash: false,
		stripTextFragment: true,
		stripWWW: true,
		removeQueryParameters: [/^utm_\w+/i],
		removeTrailingSlash: true,
		removeSingleSlash: true,
		removeDirectoryIndex: false,
		sortQueryParameters: true,
		...options
	};

	urlString = urlString.trim();

	// Data URL
	if (/^data:/i.test(urlString)) {
		return normalizeDataURL(urlString, options);
	}

	if (/^view-source:/i.test(urlString)) {
		throw new Error('`view-source:` is not supported as it is a non-standard protocol');
	}

	const hasRelativeProtocol = urlString.startsWith('//');
	const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);

	// Prepend protocol
	if (!isRelativeUrl) {
		urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
	}

	const urlObj = new URL(urlString);

	if (options.forceHttp && options.forceHttps) {
		throw new Error('The `forceHttp` and `forceHttps` options cannot be used together');
	}

	if (options.forceHttp && urlObj.protocol === 'https:') {
		urlObj.protocol = 'http:';
	}

	if (options.forceHttps && urlObj.protocol === 'http:') {
		urlObj.protocol = 'https:';
	}

	// Remove auth
	if (options.stripAuthentication) {
		urlObj.username = '';
		urlObj.password = '';
	}

	// Remove hash
	if (options.stripHash) {
		urlObj.hash = '';
	} else if (options.stripTextFragment) {
		urlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');
	}

	// Remove duplicate slashes if not preceded by a protocol
	if (urlObj.pathname) {
		urlObj.pathname = urlObj.pathname.replace(/(?<!\b(?:[a-z][a-z\d+\-.]{1,50}:))\/{2,}/g, '/');
	}

	// Decode URI octets
	if (urlObj.pathname) {
		try {
			urlObj.pathname = decodeURI(urlObj.pathname);
		} catch (_) {}
	}

	// Remove directory index
	if (options.removeDirectoryIndex === true) {
		options.removeDirectoryIndex = [/^index\.[a-z]+$/];
	}

	if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
		let pathComponents = urlObj.pathname.split('/');
		const lastComponent = pathComponents[pathComponents.length - 1];

		if (testParameter(lastComponent, options.removeDirectoryIndex)) {
			pathComponents = pathComponents.slice(0, pathComponents.length - 1);
			urlObj.pathname = pathComponents.slice(1).join('/') + '/';
		}
	}

	if (urlObj.hostname) {
		// Remove trailing dot
		urlObj.hostname = urlObj.hostname.replace(/\.$/, '');

		// Remove `www.`
		if (options.stripWWW && /^www\.(?!www\.)(?:[a-z\-\d]{1,63})\.(?:[a-z.\-\d]{2,63})$/.test(urlObj.hostname)) {
			// Each label should be max 63 at length (min: 1).
			// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names
			// Each TLD should be up to 63 characters long (min: 2).
			// It is technically possible to have a single character TLD, but none currently exist.
			urlObj.hostname = urlObj.hostname.replace(/^www\./, '');
		}
	}

	// Remove query unwanted parameters
	if (Array.isArray(options.removeQueryParameters)) {
		for (const key of [...urlObj.searchParams.keys()]) {
			if (testParameter(key, options.removeQueryParameters)) {
				urlObj.searchParams.delete(key);
			}
		}
	}

	if (options.removeQueryParameters === true) {
		urlObj.search = '';
	}

	// Sort query parameters
	if (options.sortQueryParameters) {
		urlObj.searchParams.sort();
	}

	if (options.removeTrailingSlash) {
		urlObj.pathname = urlObj.pathname.replace(/\/$/, '');
	}

	const oldUrlString = urlString;

	// Take advantage of many of the Node `url` normalizations
	urlString = urlObj.toString();

	if (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {
		urlString = urlString.replace(/\/$/, '');
	}

	// Remove ending `/` unless removeSingleSlash is false
	if ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {
		urlString = urlString.replace(/\/$/, '');
	}

	// Restore relative protocol, if applicable
	if (hasRelativeProtocol && !options.normalizeProtocol) {
		urlString = urlString.replace(/^http:\/\//, '//');
	}

	// Remove http/https
	if (options.stripProtocol) {
		urlString = urlString.replace(/^(?:https?:)?\/\//, '');
	}

	return urlString;
};

module.exports = normalizeUrl;


/***/ }),

/***/ 1223:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var wrappy = __nccwpck_require__(2940)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 9072:
/***/ ((module) => {

"use strict";


class CancelError extends Error {
	constructor(reason) {
		super(reason || 'Promise was canceled');
		this.name = 'CancelError';
	}

	get isCanceled() {
		return true;
	}
}

class PCancelable {
	static fn(userFn) {
		return (...arguments_) => {
			return new PCancelable((resolve, reject, onCancel) => {
				arguments_.push(onCancel);
				// eslint-disable-next-line promise/prefer-await-to-then
				userFn(...arguments_).then(resolve, reject);
			});
		};
	}

	constructor(executor) {
		this._cancelHandlers = [];
		this._isPending = true;
		this._isCanceled = false;
		this._rejectOnCancel = true;

		this._promise = new Promise((resolve, reject) => {
			this._reject = reject;

			const onResolve = value => {
				if (!this._isCanceled || !onCancel.shouldReject) {
					this._isPending = false;
					resolve(value);
				}
			};

			const onReject = error => {
				this._isPending = false;
				reject(error);
			};

			const onCancel = handler => {
				if (!this._isPending) {
					throw new Error('The `onCancel` handler was attached after the promise settled.');
				}

				this._cancelHandlers.push(handler);
			};

			Object.defineProperties(onCancel, {
				shouldReject: {
					get: () => this._rejectOnCancel,
					set: boolean => {
						this._rejectOnCancel = boolean;
					}
				}
			});

			return executor(onResolve, onReject, onCancel);
		});
	}

	then(onFulfilled, onRejected) {
		// eslint-disable-next-line promise/prefer-await-to-then
		return this._promise.then(onFulfilled, onRejected);
	}

	catch(onRejected) {
		return this._promise.catch(onRejected);
	}

	finally(onFinally) {
		return this._promise.finally(onFinally);
	}

	cancel(reason) {
		if (!this._isPending || this._isCanceled) {
			return;
		}

		this._isCanceled = true;

		if (this._cancelHandlers.length > 0) {
			try {
				for (const handler of this._cancelHandlers) {
					handler();
				}
			} catch (error) {
				this._reject(error);
				return;
			}
		}

		if (this._rejectOnCancel) {
			this._reject(new CancelError(reason));
		}
	}

	get isCanceled() {
		return this._isCanceled;
	}
}

Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

module.exports = PCancelable;
module.exports.CancelError = CancelError;


/***/ }),

/***/ 8569:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


module.exports = __nccwpck_require__(3322);


/***/ }),

/***/ 6099:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(1017);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ 2139:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const constants = __nccwpck_require__(6099);
const utils = __nccwpck_require__(479);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ 3322:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(1017);
const scan = __nccwpck_require__(2429);
const parse = __nccwpck_require__(2139);
const utils = __nccwpck_require__(479);
const constants = __nccwpck_require__(6099);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ 2429:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const utils = __nccwpck_require__(479);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __nccwpck_require__(6099);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ 479:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const path = __nccwpck_require__(1017);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __nccwpck_require__(6099);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),

/***/ 8341:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

var once = __nccwpck_require__(1223)
var eos = __nccwpck_require__(1205)
var fs = __nccwpck_require__(7147) // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ 9795:
/***/ ((module) => {

/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise

module.exports = typeof queueMicrotask === 'function'
  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
  // reuse resolved promise, and allocate it lazily
  : cb => (promise || (promise = Promise.resolve()))
    .then(cb)
    .catch(err => setTimeout(() => { throw err }, 0))


/***/ }),

/***/ 9273:
/***/ ((module) => {

"use strict";


class QuickLRU {
	constructor(options = {}) {
		if (!(options.maxSize && options.maxSize > 0)) {
			throw new TypeError('`maxSize` must be a number greater than 0');
		}

		this.maxSize = options.maxSize;
		this.onEviction = options.onEviction;
		this.cache = new Map();
		this.oldCache = new Map();
		this._size = 0;
	}

	_set(key, value) {
		this.cache.set(key, value);
		this._size++;

		if (this._size >= this.maxSize) {
			this._size = 0;

			if (typeof this.onEviction === 'function') {
				for (const [key, value] of this.oldCache.entries()) {
					this.onEviction(key, value);
				}
			}

			this.oldCache = this.cache;
			this.cache = new Map();
		}
	}

	get(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			const value = this.oldCache.get(key);
			this.oldCache.delete(key);
			this._set(key, value);
			return value;
		}
	}

	set(key, value) {
		if (this.cache.has(key)) {
			this.cache.set(key, value);
		} else {
			this._set(key, value);
		}

		return this;
	}

	has(key) {
		return this.cache.has(key) || this.oldCache.has(key);
	}

	peek(key) {
		if (this.cache.has(key)) {
			return this.cache.get(key);
		}

		if (this.oldCache.has(key)) {
			return this.oldCache.get(key);
		}
	}

	delete(key) {
		const deleted = this.cache.delete(key);
		if (deleted) {
			this._size--;
		}

		return this.oldCache.delete(key) || deleted;
	}

	clear() {
		this.cache.clear();
		this.oldCache.clear();
		this._size = 0;
	}

	* keys() {
		for (const [key] of this) {
			yield key;
		}
	}

	* values() {
		for (const [, value] of this) {
			yield value;
		}
	}

	* [Symbol.iterator]() {
		for (const item of this.cache) {
			yield item;
		}

		for (const item of this.oldCache) {
			const [key] = item;
			if (!this.cache.has(key)) {
				yield item;
			}
		}
	}

	get size() {
		let oldCacheSize = 0;
		for (const key of this.oldCache.keys()) {
			if (!this.cache.has(key)) {
				oldCacheSize++;
			}
		}

		return Math.min(this._size + oldCacheSize, this.maxSize);
	}
}

module.exports = QuickLRU;


/***/ }),

/***/ 6624:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";

const tls = __nccwpck_require__(4404);

module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
	let timeout = false;

	let socket;

	const callback = async () => {
		await socketPromise;

		socket.off('timeout', onTimeout);
		socket.off('error', reject);

		if (options.resolveSocket) {
			resolve({alpnProtocol: socket.alpnProtocol, socket, timeout});

			if (timeout) {
				await Promise.resolve();
				socket.emit('timeout');
			}
		} else {
			socket.destroy();
			resolve({alpnProtocol: socket.alpnProtocol, timeout});
		}
	};

	const onTimeout = async () => {
		timeout = true;
		callback();
	};

	const socketPromise = (async () => {
		try {
			socket = await connect(options, callback);

			socket.on('error', reject);
			socket.once('timeout', onTimeout);
		} catch (error) {
			reject(error);
		}
	})();
});


/***/ }),

/***/ 9004:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


const Readable = (__nccwpck_require__(2781).Readable);
const lowercaseKeys = __nccwpck_require__(9662);

class Response extends Readable {
	constructor(statusCode, headers, body, url) {
		if (typeof statusCode !== 'number') {
			throw new TypeError('Argument `statusCode` should be a number');
		}
		if (typeof headers !== 'object') {
			throw new TypeError('Argument `headers` should be an object');
		}
		if (!(body instanceof Buffer)) {
			throw new TypeError('Argument `body` should be a buffer');
		}
		if (typeof url !== 'string') {
			throw new TypeError('Argument `url` should be a string');
		}

		super();
		this.statusCode = statusCode;
		this.headers = lowercaseKeys(headers);
		this.body = body;
		this.url = url;
	}

	_read() {
		this.push(this.body);
		this.push(null);
	}
}

module.exports = Response;


/***/ }),

/***/ 2113:
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),

/***/ 5288:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = runParallel

const queueMicrotask = __nccwpck_require__(9795)

function runParallel (tasks, cb) {
  let results, pending, keys
  let isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) queueMicrotask(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),

/***/ 1861:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __nccwpck_require__(5680);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 2940:
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 5696:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(6417);
var util_1 = __nccwpck_require__(6195);
var util_2 = __nccwpck_require__(5282);
var _1 = __nccwpck_require__(4260);
var dom_1 = __nccwpck_require__(770);
/** @inheritdoc */
function builder(p1, p2) {
    var options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    var nodes = util_2.Guard.isNode(p1) || util_1.isArray(p1) ? p1 : p2;
    if (nodes === undefined) {
        throw new Error("Invalid arguments.");
    }
    if (util_1.isArray(nodes)) {
        var builders = [];
        for (var i = 0; i < nodes.length; i++) {
            var builder_1 = new _1.XMLBuilderImpl(nodes[i]);
            builder_1.set(options);
            builders.push(builder_1);
        }
        return builders;
    }
    else {
        var builder_2 = new _1.XMLBuilderImpl(nodes);
        builder_2.set(options);
        return builder_2;
    }
}
exports.builder = builder;
/** @inheritdoc */
function create(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options);
    var builder = new _1.XMLBuilderImpl(doc);
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.create = create;
/** @inheritdoc */
function fragment(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ?
        p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options, true);
    var builder = new _1.XMLBuilderImpl(doc.createDocumentFragment());
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.fragment = fragment;
/** @inheritdoc */
function convert(p1, p2, p3) {
    var builderOptions;
    var contents;
    var convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
        builderOptions = p1;
        contents = p2;
        convertOptions = p3;
    }
    else {
        builderOptions = interfaces_1.DefaultBuilderOptions;
        contents = p1;
        convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
}
exports.convert = convert;
function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj))
        return false;
    for (var key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(key)) {
            if (!interfaces_1.XMLBuilderOptionKeys.has(key))
                return false;
        }
    }
    return true;
}
function formatBuilderOptions(createOptions) {
    if (createOptions === void 0) { createOptions = {}; }
    var options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 ||
        options.convert.ins.length === 0 ||
        options.convert.text.length === 0 ||
        options.convert.cdata.length === 0 ||
        options.convert.comment.length === 0) {
        throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
}
function setOptions(doc, options, isFragment) {
    var docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
}
//# sourceMappingURL=BuilderFunctions.js.map

/***/ }),

/***/ 268:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var _1 = __nccwpck_require__(4260);
/**
 * Creates an XML builder which serializes the document in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function createCB(options) {
    return new _1.XMLBuilderCBImpl(options);
}
exports.createCB = createCB;
/**
 * Creates an XML builder which serializes the fragment in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */
function fragmentCB(options) {
    return new _1.XMLBuilderCBImpl(options, true);
}
exports.fragmentCB = fragmentCB;
//# sourceMappingURL=BuilderFunctionsCB.js.map

/***/ }),

/***/ 1438:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(6417);
var util_1 = __nccwpck_require__(6195);
var BuilderFunctions_1 = __nccwpck_require__(5696);
var algorithm_1 = __nccwpck_require__(61);
var infra_1 = __nccwpck_require__(4251);
var NamespacePrefixMap_1 = __nccwpck_require__(283);
var LocalNameSet_1 = __nccwpck_require__(9049);
var util_2 = __nccwpck_require__(5282);
var XMLCBWriter_1 = __nccwpck_require__(7572);
var JSONCBWriter_1 = __nccwpck_require__(7525);
var YAMLCBWriter_1 = __nccwpck_require__(2444);
var events_1 = __nccwpck_require__(2361);
/**
 * Represents a readable XML document stream.
 */
var XMLBuilderCBImpl = /** @class */ (function (_super) {
    __extends(XMLBuilderCBImpl, _super);
    /**
     * Initializes a new instance of `XMLStream`.
     *
     * @param options - stream writer options
     * @param fragment - whether to create fragment stream or a document stream
     *
     * @returns XML stream
     */
    function XMLBuilderCBImpl(options, fragment) {
        if (fragment === void 0) { fragment = false; }
        var _this = _super.call(this) || this;
        _this._hasDeclaration = false;
        _this._docTypeName = "";
        _this._hasDocumentElement = false;
        _this._currentElementSerialized = false;
        _this._openTags = [];
        _this._ended = false;
        _this._fragment = fragment;
        // provide default options
        _this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
        _this._builderOptions = {
            defaultNamespace: _this._options.defaultNamespace,
            namespaceAlias: _this._options.namespaceAlias
        };
        if (_this._options.format === "json") {
            _this._writer = new JSONCBWriter_1.JSONCBWriter(_this._options);
        }
        else if (_this._options.format === "yaml") {
            _this._writer = new YAMLCBWriter_1.YAMLCBWriter(_this._options);
        }
        else {
            _this._writer = new XMLCBWriter_1.XMLCBWriter(_this._options);
        }
        // automatically create listeners for callbacks passed via options
        if (_this._options.data !== undefined) {
            _this.on("data", _this._options.data);
        }
        if (_this._options.end !== undefined) {
            _this.on("end", _this._options.end);
        }
        if (_this._options.error !== undefined) {
            _this.on("error", _this._options.error);
        }
        _this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
        _this._prefixMap.set("xml", infra_1.namespace.XML);
        _this._prefixIndex = { value: 1 };
        _this._push(_this._writer.frontMatter());
        return _this;
    }
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.ele = function (p1, p2, p3) {
        var e_1, _a;
        // parse if JS object or XML or JSON string
        if (util_1.isObject(p1) || (util_1.isString(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1) || /^(\s*|(#.*)|(%.*))*---/.test(p1)))) {
            var frag = BuilderFunctions_1.fragment().set(this._options);
            try {
                frag.ele(p1);
            }
            catch (err) {
                this.emit("error", err);
                return this;
            }
            try {
                for (var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    this._fromNode(node);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return this;
        }
        this._serializeOpenTag(true);
        if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
            this.emit("error", new Error("Document cannot have multiple document element nodes."));
            return this;
        }
        try {
            this._currentElement = BuilderFunctions_1.fragment(this._builderOptions).ele(p1, p2, p3);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== ""
            && this._currentElement.node._qualifiedName !== this._docTypeName) {
            this.emit("error", new Error("Document element name does not match DocType declaration name."));
            return this;
        }
        this._currentElementSerialized = false;
        if (!this._fragment) {
            this._hasDocumentElement = true;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.att = function (p1, p2, p3) {
        if (this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
            return this;
        }
        try {
            this._currentElement.att(p1, p2, p3);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.com = function (content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).com(content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.comment(node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.txt = function (content) {
        if (!this._fragment && this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert a text node as child of a document node."));
            return this;
        }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).txt(content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
            return this;
        }
        var markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        this._push(this._writer.text(markup));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.ins = function (target, content) {
        if (content === void 0) { content = ''; }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).ins(target, content).first().node;
        }
        catch (err) {
            /* istanbul ignore next */
            this.emit("error", err);
            /* istanbul ignore next */
            return this;
        }
        if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.instruction(node.target, node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dat = function (content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).dat(content).first().node;
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        this._push(this._writer.cdata(node.data));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dec = function (options) {
        if (options === void 0) { options = { version: "1.0" }; }
        if (this._fragment) {
            this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
            return this;
        }
        if (this._hasDeclaration) {
            this.emit("error", Error("XML declaration is already inserted."));
            return this;
        }
        this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
        this._hasDeclaration = true;
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.dtd = function (options) {
        if (this._fragment) {
            this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
            return this;
        }
        if (this._docTypeName !== "") {
            this.emit("error", new Error("DocType declaration is already inserted."));
            return this;
        }
        if (this._hasDocumentElement) {
            this.emit("error", new Error("Cannot insert DocType declaration after document element."));
            return this;
        }
        var node;
        try {
            node = BuilderFunctions_1.create().dtd(options).first().node;
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
            return this;
        }
        this._docTypeName = options.name;
        this._push(this._writer.docType(options.name, node.publicId, node.systemId));
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.import = function (node) {
        var e_2, _a;
        var frag = BuilderFunctions_1.fragment().set(this._options);
        try {
            frag.import(node);
        }
        catch (err) {
            this.emit("error", err);
            return this;
        }
        try {
            for (var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node_1 = _c.value;
                this._fromNode(node_1);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.up = function () {
        this._serializeOpenTag(false);
        this._serializeCloseTag();
        return this;
    };
    /** @inheritdoc */
    XMLBuilderCBImpl.prototype.end = function () {
        this._serializeOpenTag(false);
        while (this._openTags.length > 0) {
            this._serializeCloseTag();
        }
        this._push(null);
        return this;
    };
    /**
     * Serializes the opening tag of an element node.
     *
     * @param hasChildren - whether the element node has child nodes
     */
    XMLBuilderCBImpl.prototype._serializeOpenTag = function (hasChildren) {
        if (this._currentElementSerialized)
            return;
        if (this._currentElement === undefined)
            return;
        var node = this._currentElement.node;
        if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            return;
        }
        var qualifiedName = "";
        var ignoreNamespaceDefinitionAttribute = false;
        var map = this._prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
        var ns = node.namespaceURI;
        if (ns === null)
            ns = inheritedNS;
        if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
                qualifiedName = "xml:" + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            this._writer.beginElement(qualifiedName);
            this._push(this._writer.openTagBegin(qualifiedName));
        }
        else {
            var prefix = node.prefix;
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
                if (this._options.wellFormed) {
                    this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                    return;
                }
                candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            }
            else if (prefix !== null) {
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, this._prefixIndex);
                }
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            }
        }
        this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && !hasChildren &&
            XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
            this._push(this._writer.openTagEnd(qualifiedName, true, true));
            this._writer.endElement(qualifiedName);
        }
        else if (!isHTML && !hasChildren) {
            this._push(this._writer.openTagEnd(qualifiedName, true, false));
            this._writer.endElement(qualifiedName);
        }
        else {
            this._push(this._writer.openTagEnd(qualifiedName, false, false));
        }
        this._currentElementSerialized = true;
        /**
         * Save qualified name, original inherited ns, original prefix map, and
         * hasChildren flag.
         */
        this._openTags.push([qualifiedName, inheritedNS, this._prefixMap, hasChildren]);
        /**
         * New values of inherited namespace and prefix map will be used while
         * serializing child nodes. They will be returned to their original values
         * when this node is closed using the _openTags array item we saved above.
         */
        if (this._isPrefixMapModified(this._prefixMap, map)) {
            this._prefixMap = map;
        }
        /**
         * Calls following this will either serialize child nodes or close this tag.
         */
        this._writer.level++;
    };
    /**
     * Serializes the closing tag of an element node.
     */
    XMLBuilderCBImpl.prototype._serializeCloseTag = function () {
        this._writer.level--;
        var lastEle = this._openTags.pop();
        /* istanbul ignore next */
        if (lastEle === undefined) {
            this.emit("error", new Error("Last element is undefined."));
            return;
        }
        var _a = __read(lastEle, 4), qualifiedName = _a[0], ns = _a[1], map = _a[2], hasChildren = _a[3];
        /**
         * Restore original values of inherited namespace and prefix map.
         */
        this._prefixMap = map;
        if (!hasChildren)
            return;
        this._push(this._writer.closeTag(qualifiedName));
        this._writer.endElement(qualifiedName);
    };
    /**
     * Pushes data to internal buffer.
     *
     * @param data - data
     */
    XMLBuilderCBImpl.prototype._push = function (data) {
        if (data === null) {
            this._ended = true;
            this.emit("end");
        }
        else if (this._ended) {
            this.emit("error", new Error("Cannot push to ended stream."));
        }
        else if (data.length !== 0) {
            this._writer.hasData = true;
            this.emit("data", data, this._writer.level);
        }
    };
    /**
     * Reads and serializes an XML tree.
     *
     * @param node - root node
     */
    XMLBuilderCBImpl.prototype._fromNode = function (node) {
        var e_3, _a, e_4, _b;
        if (util_2.Guard.isElementNode(node)) {
            var name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
            if (node.namespaceURI !== null) {
                this.ele(node.namespaceURI, name);
            }
            else {
                this.ele(name);
            }
            try {
                for (var _c = __values(node.attributes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var attr = _d.value;
                    var name_1 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
                    if (attr.namespaceURI !== null) {
                        this.att(attr.namespaceURI, name_1, attr.value);
                    }
                    else {
                        this.att(name_1, attr.value);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            try {
                for (var _e = __values(node.childNodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var child = _f.value;
                    this._fromNode(child);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.up();
        }
        else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
            this.txt(node.data);
        }
        else if (util_2.Guard.isCommentNode(node)) {
            this.com(node.data);
        }
        else if (util_2.Guard.isCDATASectionNode(node)) {
            this.dat(node.data);
        }
        else if (util_2.Guard.isProcessingInstructionNode(node)) {
            this.ins(node.target, node.data);
        }
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
     */
    XMLBuilderCBImpl.prototype._serializeAttributes = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_5, _a;
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
                    continue;
                }
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
                    return;
                }
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                if (attributeNamespace !== null) {
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                            return;
                        }
                        if (requireWellFormed && attr.value === '') {
                            this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                            return;
                        }
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
                    }
                }
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
                    return;
                }
                this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    XMLBuilderCBImpl.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            this.emit("error", new Error("Invalid characters in attribute value."));
            return "";
        }
        if (value === null)
            return "";
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    };
    /**
     * Records namespace information for the given element and returns the
     * default namespace attribute value.
     *
     * @param node - element node to process
     * @param map - namespace prefix map
     * @param localPrefixesMap - local prefixes map
     */
    XMLBuilderCBImpl.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_6, _a;
        var defaultNamespaceAttrValue = null;
        try {
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                var attributeNamespace = attr.namespaceURI;
                var attributePrefix = attr.prefix;
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                    }
                    else {
                        var prefixDefinition = attr.localName;
                        var namespaceDefinition = attr.value;
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        map.set(prefixDefinition, namespaceDefinition);
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return defaultNamespaceAttrValue;
    };
    /**
     * Generates a new prefix for the given namespace.
     *
     * @param newNamespace - a namespace to generate prefix for
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     */
    XMLBuilderCBImpl.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Determines if the namespace prefix map was modified from its original.
     *
     * @param originalMap - original namespace prefix map
     * @param newMap - new namespace prefix map
     */
    XMLBuilderCBImpl.prototype._isPrefixMapModified = function (originalMap, newMap) {
        var items1 = originalMap._items;
        var items2 = newMap._items;
        var nullItems1 = originalMap._nullItems;
        var nullItems2 = newMap._nullItems;
        for (var key in items2) {
            var arr1 = items1[key];
            if (arr1 === undefined)
                return true;
            var arr2 = items2[key];
            if (arr1.length !== arr2.length)
                return true;
            for (var i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i])
                    return true;
            }
        }
        if (nullItems1.length !== nullItems2.length)
            return true;
        for (var i = 0; i < nullItems1.length; i++) {
            if (nullItems1[i] !== nullItems2[i])
                return true;
        }
        return false;
    };
    XMLBuilderCBImpl._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return XMLBuilderCBImpl;
}(events_1.EventEmitter));
exports.XMLBuilderCBImpl = XMLBuilderCBImpl;
//# sourceMappingURL=XMLBuilderCBImpl.js.map

/***/ }),

/***/ 8248:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(6417);
var util_1 = __nccwpck_require__(6195);
var writers_1 = __nccwpck_require__(7476);
var interfaces_2 = __nccwpck_require__(7305);
var util_2 = __nccwpck_require__(5282);
var algorithm_1 = __nccwpck_require__(61);
var dom_1 = __nccwpck_require__(770);
var infra_1 = __nccwpck_require__(4251);
var readers_1 = __nccwpck_require__(560);
/**
 * Represents a wrapper that extends XML nodes to implement easy to use and
 * chainable document builder methods.
 */
var XMLBuilderImpl = /** @class */ (function () {
    /**
     * Initializes a new instance of `XMLBuilderNodeImpl`.
     *
     * @param domNode - the DOM node to wrap
     */
    function XMLBuilderImpl(domNode) {
        this._domNode = domNode;
    }
    Object.defineProperty(XMLBuilderImpl.prototype, "node", {
        /** @inheritdoc */
        get: function () { return this._domNode; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLBuilderImpl.prototype, "options", {
        /** @inheritdoc */
        get: function () { return this._options; },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */
    XMLBuilderImpl.prototype.set = function (options) {
        this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), // apply user settings
        interfaces_1.DefaultBuilderOptions); // provide defaults
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.ele = function (p1, p2, p3) {
        var _a, _b, _c;
        var namespace;
        var name;
        var attributes;
        if (util_1.isObject(p1)) {
            // ele(obj: ExpandObject)
            return new readers_1.ObjectReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^\s*</.test(p1)) {
            // parse XML document string
            return new readers_1.XMLReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^\s*[\{\[]/.test(p1)) {
            // parse JSON string
            return new readers_1.JSONReader(this._options).parse(this, p1);
        }
        else if (p1 !== null && /^(\s*|(#.*)|(%.*))*---/.test(p1)) {
            // parse YAML string
            return new readers_1.YAMLReader(this._options).parse(this, p1);
        }
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
            // ele(namespace: string, name: string, attributes?: AttributesObject)
            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], attributes = _a[2];
        }
        else if (p1 !== null) {
            // ele(name: string, attributes?: AttributesObject)
            _b = __read([undefined, p1, util_1.isObject(p2) ? p2 : undefined], 3), namespace = _b[0], name = _b[1], attributes = _b[2];
        }
        else {
            throw new Error("Element name cannot be null. " + this._debugInfo());
        }
        if (attributes) {
            attributes = util_1.getValue(attributes);
        }
        _c = __read(this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true), 2), namespace = _c[0], name = _c[1];
        // inherit namespace from parent
        if (namespace === undefined) {
            var _d = __read(algorithm_1.namespace_extractQName(name), 1), prefix = _d[0];
            namespace = this.node.lookupNamespaceURI(prefix);
        }
        // create a child element node
        var childNode = (namespace !== undefined && namespace !== null ?
            this._doc.createElementNS(namespace, name) :
            this._doc.createElement(name));
        this.node.appendChild(childNode);
        var builder = new XMLBuilderImpl(childNode);
        // update doctype node if the new node is the document element node
        var oldDocType = this._doc.doctype;
        if (childNode === this._doc.documentElement && oldDocType !== null) {
            var docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
            this._doc.replaceChild(docType, oldDocType);
        }
        // create attributes
        if (attributes && !util_1.isEmpty(attributes)) {
            builder.att(attributes);
        }
        return builder;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.remove = function () {
        var parent = this.up();
        parent.node.removeChild(this.node);
        return parent;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.att = function (p1, p2, p3) {
        var _a, _b, _c;
        var _this = this;
        if (util_1.isMap(p1) || util_1.isObject(p1)) {
            // att(obj: AttributesObject)
            // expand if object
            util_1.forEachObject(p1, function (attName, attValue) { return _this.att(attName, attValue); }, this);
            return this;
        }
        // get primitive values
        if (p1 !== undefined && p1 !== null)
            p1 = util_1.getValue(p1 + "");
        if (p2 !== undefined && p2 !== null)
            p2 = util_1.getValue(p2 + "");
        if (p3 !== undefined && p3 !== null)
            p3 = util_1.getValue(p3 + "");
        var namespace;
        var name;
        var value;
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
            // att(namespace: string, name: string, value: string)
            _a = __read([p1, p2, p3], 3), namespace = _a[0], name = _a[1], value = _a[2];
        }
        else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
            // ele(name: string, value: string)
            _b = __read([undefined, p1, p2], 3), namespace = _b[0], name = _b[1], value = _b[2];
        }
        else {
            throw new Error("Attribute name and value not specified. " + this._debugInfo());
        }
        if (this._options.keepNullAttributes && (value == null)) {
            // keep null attributes
            value = "";
        }
        else if (value == null) {
            // skip null|undefined attributes
            return this;
        }
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be assigned to an element node.");
        }
        var ele = this.node;
        _c = __read(this._extractNamespace(namespace, name, false), 2), namespace = _c[0], name = _c[1];
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
        var _d = __read(algorithm_1.namespace_extractQName(name), 2), prefix = _d[0], localName = _d[1];
        var _e = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 1), elePrefix = _e[0];
        // check if this is a namespace declaration attribute
        // assign a new element namespace if it wasn't previously assigned
        var eleNamespace = null;
        if (prefix === "xmlns") {
            namespace = infra_1.namespace.XMLNS;
            if (ele.namespaceURI === null && elePrefix === localName) {
                eleNamespace = value;
            }
        }
        else if (prefix === null && localName === "xmlns" && elePrefix === null) {
            namespace = infra_1.namespace.XMLNS;
            eleNamespace = value;
        }
        // re-create the element node if its namespace changed
        // we can't simply change the namespaceURI since its read-only
        if (eleNamespace !== null) {
            this._updateNamespace(eleNamespace);
            ele = this.node;
        }
        if (namespace !== undefined) {
            ele.setAttributeNS(namespace, name, value);
        }
        else {
            ele.setAttribute(name, value);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.removeAtt = function (p1, p2) {
        var _this = this;
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be removed from an element node.");
        }
        // get primitive values
        p1 = util_1.getValue(p1);
        if (p2 !== undefined) {
            p2 = util_1.getValue(p2);
        }
        var namespace;
        var name;
        if (p1 !== null && p2 === undefined) {
            name = p1;
        }
        else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {
            namespace = p1;
            name = p2;
        }
        else {
            throw new Error("Attribute namespace must be a string. " + this._debugInfo());
        }
        if (util_1.isArray(name) || util_1.isSet(name)) {
            // removeAtt(names: string[])
            // removeAtt(namespace: string, names: string[])
            util_1.forEachArray(name, function (attName) {
                return namespace === undefined ? _this.removeAtt(attName) : _this.removeAtt(namespace, attName);
            }, this);
        }
        else if (namespace !== undefined) {
            // removeAtt(namespace: string, name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
            this.node.removeAttributeNS(namespace, name);
        }
        else {
            // removeAtt(name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            this.node.removeAttribute(name);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.txt = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.com = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dat = function (content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.ins = function (target, content) {
        var _this = this;
        if (content === void 0) { content = ''; }
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            }
            else {
                // skip null|undefined nodes
                return this;
            }
        }
        if (util_1.isArray(target) || util_1.isSet(target)) {
            util_1.forEachArray(target, function (item) {
                item += "";
                var insIndex = item.indexOf(' ');
                var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));
                var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));
                _this.ins(insTarget, insValue);
            }, this);
        }
        else if (util_1.isMap(target) || util_1.isObject(target)) {
            util_1.forEachObject(target, function (insTarget, insValue) { return _this.ins(insTarget, insValue); }, this);
        }
        else {
            var child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
            this.node.appendChild(child);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dec = function (options) {
        this._options.version = options.version || "1.0";
        this._options.encoding = options.encoding;
        this._options.standalone = options.standalone;
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.dtd = function (options) {
        var name = dom_1.sanitizeInput((options && options.name) || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
        var pubID = dom_1.sanitizeInput((options && options.pubID) || "", this._options.invalidCharReplacement);
        var sysID = dom_1.sanitizeInput((options && options.sysID) || "", this._options.invalidCharReplacement);
        // name must match document element
        if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
            throw new Error("DocType name does not match document element name.");
        }
        // create doctype node
        var docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
        if (this._doc.doctype !== null) {
            // replace existing doctype
            this._doc.replaceChild(docType, this._doc.doctype);
        }
        else {
            // insert before document element node or append to end
            this._doc.insertBefore(docType, this._doc.documentElement);
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.import = function (node) {
        var e_1, _a;
        var hostNode = this._domNode;
        var hostDoc = this._doc;
        var importedNode = node.node;
        if (util_2.Guard.isDocumentNode(importedNode)) {
            // import document node
            var elementNode = importedNode.documentElement;
            if (elementNode === null) {
                throw new Error("Imported document has no document element node. " + this._debugInfo());
            }
            var clone = hostDoc.importNode(elementNode, true);
            hostNode.appendChild(clone);
            var _b = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _b[0];
            var namespace = hostNode.lookupNamespaceURI(prefix);
            new XMLBuilderImpl(clone)._updateNamespace(namespace);
        }
        else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
            try {
                // import child nodes
                for (var _c = __values(importedNode.childNodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var childNode = _d.value;
                    var clone = hostDoc.importNode(childNode, true);
                    hostNode.appendChild(clone);
                    if (util_2.Guard.isElementNode(clone)) {
                        var _e = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _e[0];
                        var namespace = hostNode.lookupNamespaceURI(prefix);
                        new XMLBuilderImpl(clone)._updateNamespace(namespace);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            // import node
            var clone = hostDoc.importNode(importedNode, true);
            hostNode.appendChild(clone);
            if (util_2.Guard.isElementNode(clone)) {
                var _f = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ':' + clone.localName : clone.localName), 1), prefix = _f[0];
                var namespace = hostNode.lookupNamespaceURI(prefix);
                new XMLBuilderImpl(clone)._updateNamespace(namespace);
            }
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.doc = function () {
        if (this._doc._isFragment) {
            var node = this.node;
            while (node && node.nodeType !== interfaces_2.NodeType.DocumentFragment) {
                node = node.parentNode;
            }
            /* istanbul ignore next */
            if (node === null) {
                throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
            }
            return new XMLBuilderImpl(node);
        }
        else {
            return new XMLBuilderImpl(this._doc);
        }
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.root = function () {
        var ele = this._doc.documentElement;
        if (!ele) {
            throw new Error("Document root element is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(ele);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.up = function () {
        var parent = this._domNode.parentNode;
        if (!parent) {
            throw new Error("Parent node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(parent);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.prev = function () {
        var node = this._domNode.previousSibling;
        if (!node) {
            throw new Error("Previous sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.next = function () {
        var node = this._domNode.nextSibling;
        if (!node) {
            throw new Error("Next sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.first = function () {
        var node = this._domNode.firstChild;
        if (!node) {
            throw new Error("First child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.last = function () {
        var node = this._domNode.lastChild;
        if (!node) {
            throw new Error("Last child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.each = function (callback, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
            callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
            result = nextResult;
        }
        return this;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.map = function (callback, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node, index, level) {
            return result.push(callback.call(thisArg, node, index, level));
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.reduce = function (callback, initialValue, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var value = initialValue;
        this.each(function (node, index, level) {
            return value = callback.call(thisArg, value, node, index, level);
        }, self, recursive);
        return value;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.find = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return builder;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return undefined;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.filter = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node, index, level) {
            if (predicate.call(thisArg, node, index, level)) {
                result.push(node);
            }
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.every = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (!predicate.call(thisArg, builder, result[1], result[2])) {
                return false;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return true;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.some = function (predicate, self, recursive, thisArg) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while (result[0]) {
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return true;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return false;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toArray = function (self, recursive) {
        if (self === void 0) { self = false; }
        if (recursive === void 0) { recursive = false; }
        var result = [];
        this.each(function (node) { return result.push(node); }, self, recursive);
        return result;
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toString = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.toObject = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "object";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */
    XMLBuilderImpl.prototype.end = function (writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this.doc()._serialize(writerOptions);
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param self - whether to visit the current node along with child nodes
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     */
    XMLBuilderImpl.prototype._getFirstDescendantNode = function (root, self, recursive) {
        if (self)
            return [this._domNode, 0, 0];
        else if (recursive)
            return this._getNextDescendantNode(root, root, recursive, 0, 0);
        else
            return [this._domNode.firstChild, 0, 1];
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param node - current node
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     * @param index - child node index
     * @param level - current depth of the XML tree
     */
    XMLBuilderImpl.prototype._getNextDescendantNode = function (root, node, recursive, index, level) {
        if (recursive) {
            // traverse child nodes
            if (node.firstChild)
                return [node.firstChild, 0, level + 1];
            if (node === root)
                return [null, -1, -1];
            // traverse siblings
            if (node.nextSibling)
                return [node.nextSibling, index + 1, level];
            // traverse parent's next sibling
            var parent = node.parentNode;
            while (parent && parent !== root) {
                if (parent.nextSibling)
                    return [parent.nextSibling, algorithm_1.tree_index(parent.nextSibling), level - 1];
                parent = parent.parentNode;
                level--;
            }
        }
        else {
            if (root === node)
                return [node.firstChild, 0, level + 1];
            else
                return [node.nextSibling, index + 1, level];
        }
        return [null, -1, -1];
    };
    /**
     * Converts the node into its string or object representation.
     *
     * @param options - serialization options
     */
    XMLBuilderImpl.prototype._serialize = function (writerOptions) {
        if (writerOptions.format === "xml") {
            var writer = new writers_1.XMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "map") {
            var writer = new writers_1.MapWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "object") {
            var writer = new writers_1.ObjectWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "json") {
            var writer = new writers_1.JSONWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else if (writerOptions.format === "yaml") {
            var writer = new writers_1.YAMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        }
        else {
            throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
        }
    };
    /**
     * Extracts a namespace and name from the given string.
     *
     * @param namespace - namespace
     * @param name - a string containing both a name and namespace separated by an
     * `'@'` character
     * @param ele - `true` if this is an element namespace; otherwise `false`
     */
    XMLBuilderImpl.prototype._extractNamespace = function (namespace, name, ele) {
        // extract from name
        var atIndex = name.indexOf("@");
        if (atIndex > 0) {
            if (namespace === undefined)
                namespace = name.slice(atIndex + 1);
            name = name.slice(0, atIndex);
        }
        if (namespace === undefined) {
            // look-up default namespace
            namespace = (ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att);
        }
        else if (namespace !== null && namespace[0] === "@") {
            // look-up namespace aliases
            var alias = namespace.slice(1);
            namespace = this._options.namespaceAlias[alias];
            if (namespace === undefined) {
                throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
            }
        }
        return [namespace, name];
    };
    /**
     * Updates the element's namespace.
     *
     * @param ns - new namespace
     */
    XMLBuilderImpl.prototype._updateNamespace = function (ns) {
        var e_2, _a, e_3, _b;
        var ele = this._domNode;
        if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {
            var _c = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ':' + ele.localName : ele.localName), 2), elePrefix = _c[0], eleLocalName = _c[1];
            // re-create the element node if its namespace changed
            // we can't simply change the namespaceURI since its read-only
            var newEle = algorithm_1.create_element(this._doc, eleLocalName, ns, elePrefix);
            try {
                for (var _d = __values(ele.attributes), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var attr = _e.value;
                    var attrQName = attr.prefix ? attr.prefix + ':' + attr.localName : attr.localName;
                    var _f = __read(algorithm_1.namespace_extractQName(attrQName), 1), attrPrefix = _f[0];
                    var newAttrNS = attr.namespaceURI;
                    if (newAttrNS === null && attrPrefix !== null) {
                        newAttrNS = ele.lookupNamespaceURI(attrPrefix);
                    }
                    if (newAttrNS === null) {
                        newEle.setAttribute(attrQName, attr.value);
                    }
                    else {
                        newEle.setAttributeNS(newAttrNS, attrQName, attr.value);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // replace the new node in parent node
            var parent = ele.parentNode;
            /* istanbul ignore next */
            if (parent === null) {
                throw new Error("Parent node is null." + this._debugInfo());
            }
            parent.replaceChild(newEle, ele);
            this._domNode = newEle;
            try {
                // check child nodes
                for (var _g = __values(ele.childNodes), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var childNode = _h.value;
                    var newChildNode = childNode.cloneNode(true);
                    newEle.appendChild(newChildNode);
                    if (util_2.Guard.isElementNode(newChildNode)) {
                        var _j = __read(algorithm_1.namespace_extractQName(newChildNode.prefix ? newChildNode.prefix + ':' + newChildNode.localName : newChildNode.localName), 1), newChildNodePrefix = _j[0];
                        var newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);
                        new XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_doc", {
        /**
         * Returns the document owning this node.
         */
        get: function () {
            var node = this.node;
            if (util_2.Guard.isDocumentNode(node)) {
                return node;
            }
            else {
                var docNode = node.ownerDocument;
                /* istanbul ignore next */
                if (!docNode)
                    throw new Error("Owner document is null. " + this._debugInfo());
                return docNode;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns debug information for this node.
     *
     * @param name - node name
     */
    XMLBuilderImpl.prototype._debugInfo = function (name) {
        var node = this.node;
        var parentNode = node.parentNode;
        name = name || node.nodeName;
        var parentName = parentNode ? parentNode.nodeName : '';
        if (!parentName) {
            return "node: <" + name + ">";
        }
        else {
            return "node: <" + name + ">, parent: <" + parentName + ">";
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_options", {
        /**
         * Gets or sets builder options.
         */
        get: function () {
            var doc = this._doc;
            /* istanbul ignore next */
            if (doc._xmlBuilderOptions === undefined) {
                throw new Error("Builder options is not set.");
            }
            return doc._xmlBuilderOptions;
        },
        set: function (value) {
            var doc = this._doc;
            doc._xmlBuilderOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    return XMLBuilderImpl;
}());
exports.XMLBuilderImpl = XMLBuilderImpl;
//# sourceMappingURL=XMLBuilderImpl.js.map

/***/ }),

/***/ 770:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(4646);
var dom_2 = __nccwpck_require__(633);
var util_1 = __nccwpck_require__(6195);
dom_2.dom.setFeatures(false);
/**
 * Creates an XML document without any child nodes.
 */
function createDocument() {
    var impl = new dom_1.DOMImplementation();
    var doc = impl.createDocument(null, 'root', null);
    /* istanbul ignore else */
    if (doc.documentElement) {
        doc.removeChild(doc.documentElement);
    }
    return doc;
}
exports.createDocument = createDocument;
/**
 * Sanitizes input strings with user supplied replacement characters.
 *
 * @param str - input string
 * @param replacement - replacement character or function
 */
function sanitizeInput(str, replacement) {
    if (str == null) {
        return str;
    }
    else if (replacement === undefined) {
        return str + "";
    }
    else {
        var result = "";
        str = str + "";
        for (var i = 0; i < str.length; i++) {
            var n = str.charCodeAt(i);
            // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
            if (n === 0x9 || n === 0xA || n === 0xD ||
                (n >= 0x20 && n <= 0xD7FF) ||
                (n >= 0xE000 && n <= 0xFFFD)) {
                // valid character - not surrogate pair
                result += str.charAt(i);
            }
            else if (n >= 0xD800 && n <= 0xDBFF && i < str.length - 1) {
                var n2 = str.charCodeAt(i + 1);
                if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                    // valid surrogate pair
                    n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                    result += String.fromCodePoint(n);
                    i++;
                }
                else {
                    // invalid lone surrogate
                    result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
                }
            }
            else {
                // invalid character
                result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
            }
        }
        return result;
    }
}
exports.sanitizeInput = sanitizeInput;
//# sourceMappingURL=dom.js.map

/***/ }),

/***/ 4260:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLBuilderImpl_1 = __nccwpck_require__(8248);
exports.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;
var XMLBuilderCBImpl_1 = __nccwpck_require__(1438);
exports.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;
var BuilderFunctions_1 = __nccwpck_require__(5696);
exports.builder = BuilderFunctions_1.builder;
exports.create = BuilderFunctions_1.create;
exports.fragment = BuilderFunctions_1.fragment;
exports.convert = BuilderFunctions_1.convert;
var BuilderFunctionsCB_1 = __nccwpck_require__(268);
exports.createCB = BuilderFunctionsCB_1.createCB;
exports.fragmentCB = BuilderFunctionsCB_1.fragmentCB;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 151:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var builder_1 = __nccwpck_require__(4260);
exports.builder = builder_1.builder;
exports.create = builder_1.create;
exports.fragment = builder_1.fragment;
exports.convert = builder_1.convert;
exports.createCB = builder_1.createCB;
exports.fragmentCB = builder_1.fragmentCB;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6417:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Defines default values for builder options.
 */
exports.DefaultBuilderOptions = {
    version: "1.0",
    encoding: undefined,
    standalone: undefined,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    },
    invalidCharReplacement: undefined,
    parser: undefined
};
/**
 * Contains keys of `XMLBuilderOptions`.
 */
exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
/**
 * Defines default values for builder options.
 */
exports.DefaultXMLBuilderCBOptions = {
    format: "xml",
    wellFormed: false,
    prettyPrint: false,
    indent: "  ",
    newline: "\n",
    offset: 0,
    width: 0,
    allowEmptyTags: false,
    spaceBeforeSlash: false,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    }
};
//# sourceMappingURL=interfaces.js.map

/***/ }),

/***/ 3396:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var dom_1 = __nccwpck_require__(770);
/**
 * Parses XML nodes.
 */
var BaseReader = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseReader`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseReader(builderOptions) {
        this._builderOptions = builderOptions;
        if (builderOptions.parser) {
            Object.assign(this, builderOptions.parser);
        }
    }
    BaseReader.prototype._docType = function (parent, name, publicId, systemId) {
        return parent.dtd({ name: name, pubID: publicId, sysID: systemId });
    };
    BaseReader.prototype._comment = function (parent, data) {
        return parent.com(data);
    };
    BaseReader.prototype._text = function (parent, data) {
        return parent.txt(data);
    };
    BaseReader.prototype._instruction = function (parent, target, data) {
        return parent.ins(target, data);
    };
    BaseReader.prototype._cdata = function (parent, data) {
        return parent.dat(data);
    };
    BaseReader.prototype._element = function (parent, namespace, name) {
        return (namespace === undefined ? parent.ele(name) : parent.ele(namespace, name));
    };
    BaseReader.prototype._attribute = function (parent, namespace, name, value) {
        return (namespace === undefined ? parent.att(name, value) : parent.att(namespace, name, value));
    };
    BaseReader.prototype._sanitize = function (str) {
        return dom_1.sanitizeInput(str, this._builderOptions.invalidCharReplacement);
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */
    BaseReader.prototype._decodeText = function (text) {
        if (text == null)
            return text;
        return text.replace(/&(quot|amp|apos|lt|gt);/g, function (_match, tag) {
            return BaseReader._entityTable[tag];
        }).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, function (_match, hexStr, numStr) {
            return String.fromCodePoint(parseInt(hexStr || numStr, hexStr ? 16 : 10));
        });
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */
    BaseReader.prototype._decodeAttributeValue = function (text) {
        return this._decodeText(text);
    };
    /**
     * Main parser function which parses the given object and returns an XMLBuilder.
     *
     * @param node - node to recieve parsed content
     * @param obj - object to parse
     */
    BaseReader.prototype.parse = function (node, obj) {
        return this._parse(node, obj);
    };
    /**
     * Creates a DocType node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */
    BaseReader.prototype.docType = function (parent, name, publicId, systemId) {
        return this._docType(parent, name, publicId, systemId);
    };
    /**
     * Creates a comment node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.comment = function (parent, data) {
        return this._comment(parent, data);
    };
    /**
     * Creates a text node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.text = function (parent, data) {
        return this._text(parent, data);
    };
    /**
     * Creates a processing instruction node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param target - instruction target
     * @param data - node data
     */
    BaseReader.prototype.instruction = function (parent, target, data) {
        return this._instruction(parent, target, data);
    };
    /**
     * Creates a CData section node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */
    BaseReader.prototype.cdata = function (parent, data) {
        return this._cdata(parent, data);
    };
    /**
     * Creates an element node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     */
    BaseReader.prototype.element = function (parent, namespace, name) {
        return this._element(parent, namespace, name);
    };
    /**
     * Creates an attribute or namespace declaration.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     * @param value - node value
     */
    BaseReader.prototype.attribute = function (parent, namespace, name, value) {
        return this._attribute(parent, namespace, name, value);
    };
    /**
     * Sanitizes input strings.
     *
     * @param str - input string
     */
    BaseReader.prototype.sanitize = function (str) {
        return this._sanitize(str);
    };
    BaseReader._entityTable = {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'",
    };
    return BaseReader;
}());
exports.BaseReader = BaseReader;
//# sourceMappingURL=BaseReader.js.map

/***/ }),

/***/ 3518:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectReader_1 = __nccwpck_require__(768);
var BaseReader_1 = __nccwpck_require__(3396);
/**
 * Parses XML nodes from a JSON string.
 */
var JSONReader = /** @class */ (function (_super) {
    __extends(JSONReader, _super);
    function JSONReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - JSON string to parse
     */
    JSONReader.prototype._parse = function (node, str) {
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));
    };
    return JSONReader;
}(BaseReader_1.BaseReader));
exports.JSONReader = JSONReader;
//# sourceMappingURL=JSONReader.js.map

/***/ }),

/***/ 768:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var BaseReader_1 = __nccwpck_require__(3396);
/**
 * Parses XML nodes from objects and arrays.
 * ES6 maps and sets are also supoorted.
 */
var ObjectReader = /** @class */ (function (_super) {
    __extends(ObjectReader, _super);
    function ObjectReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param obj - object to parse
     */
    ObjectReader.prototype._parse = function (node, obj) {
        var _this = this;
        var options = this._builderOptions;
        var lastChild = null;
        if (util_1.isFunction(obj)) {
            // evaluate if function
            lastChild = this.parse(node, obj.apply(this));
        }
        else if (util_1.isArray(obj) || util_1.isSet(obj)) {
            util_1.forEachArray(obj, function (item) { return lastChild = _this.parse(node, item); }, this);
        }
        else if (util_1.isMap(obj) || util_1.isObject(obj)) {
            // expand if object
            util_1.forEachObject(obj, function (key, val) {
                if (util_1.isFunction(val)) {
                    // evaluate if function
                    val = val.apply(_this);
                }
                if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {
                    // assign attributes
                    if (key === options.convert.att) {
                        if (util_1.isArray(val) || util_1.isSet(val)) {
                            throw new Error("Invalid attribute: " + val.toString() + ". " + node._debugInfo());
                        }
                        else /* if (isMap(val) || isObject(val)) */ {
                            util_1.forEachObject(val, function (attrKey, attrVal) {
                                lastChild = _this.attribute(node, undefined, _this.sanitize(attrKey), _this._decodeAttributeValue(_this.sanitize(attrVal))) || lastChild;
                            });
                        }
                    }
                    else {
                        lastChild = _this.attribute(node, undefined, _this.sanitize(key.substr(options.convert.att.length)), _this._decodeAttributeValue(_this.sanitize(val))) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {
                    // text node
                    if (util_1.isMap(val) || util_1.isObject(val)) {
                        // if the key is #text expand child nodes under this node to support mixed content
                        lastChild = _this.parse(node, val);
                    }
                    else {
                        lastChild = _this.text(node, _this._decodeText(_this.sanitize(val))) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {
                    // cdata node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) { return lastChild = _this.cdata(node, _this.sanitize(item)) || lastChild; }, _this);
                    }
                    else {
                        lastChild = _this.cdata(node, _this.sanitize(val)) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {
                    // comment node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) { return lastChild = _this.comment(node, _this.sanitize(item)) || lastChild; }, _this);
                    }
                    else {
                        lastChild = _this.comment(node, _this.sanitize(val)) || lastChild;
                    }
                }
                else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {
                    // processing instruction
                    if (util_1.isString(val)) {
                        var insIndex = val.indexOf(' ');
                        var insTarget = (insIndex === -1 ? val : val.substr(0, insIndex));
                        var insValue = (insIndex === -1 ? '' : val.substr(insIndex + 1));
                        lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                    }
                    else if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function (item) {
                            var insIndex = item.indexOf(' ');
                            var insTarget = (insIndex === -1 ? item : item.substr(0, insIndex));
                            var insValue = (insIndex === -1 ? '' : item.substr(insIndex + 1));
                            lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                        }, _this);
                    }
                    else /* if (isMap(target) || isObject(target)) */ {
                        util_1.forEachObject(val, function (insTarget, insValue) { return lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild; }, _this);
                    }
                }
                else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
                    // skip empty arrays
                }
                else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
                    // empty objects produce one node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                }
                else if (!options.keepNullNodes && (val == null)) {
                    // skip null and undefined nodes
                }
                else if (util_1.isArray(val) || util_1.isSet(val)) {
                    // expand list by creating child nodes
                    util_1.forEachArray(val, function (item) {
                        var childNode = {};
                        childNode[key] = item;
                        lastChild = _this.parse(node, childNode);
                    }, _this);
                }
                else if (util_1.isMap(val) || util_1.isObject(val)) {
                    // create a parent node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        // expand child nodes under parent
                        _this.parse(parent, val);
                    }
                }
                else if (val != null && val !== '') {
                    // leaf element node with a single text node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        _this.text(parent, _this._decodeText(_this.sanitize(val)));
                    }
                }
                else {
                    // leaf element node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                }
            }, this);
        }
        else if (!options.keepNullNodes && (obj == null)) {
            // skip null and undefined nodes
        }
        else {
            // text node
            lastChild = this.text(node, this._decodeText(this.sanitize(obj))) || lastChild;
        }
        return lastChild || node;
    };
    return ObjectReader;
}(BaseReader_1.BaseReader));
exports.ObjectReader = ObjectReader;
//# sourceMappingURL=ObjectReader.js.map

/***/ }),

/***/ 5044:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLStringLexer_1 = __nccwpck_require__(7061);
var interfaces_1 = __nccwpck_require__(7707);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
var BaseReader_1 = __nccwpck_require__(3396);
/**
 * Parses XML nodes from an XML document string.
 */
var XMLReader = /** @class */ (function (_super) {
    __extends(XMLReader, _super);
    function XMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - XML document string to parse
     */
    XMLReader.prototype._parse = function (node, str) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(str, { skipWhitespaceOnlyText: true });
        var lastChild = node;
        var context = node;
        var token = lexer.nextToken();
        while (token.type !== interfaces_1.TokenType.EOF) {
            switch (token.type) {
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    var version = this.sanitize(declaration.version);
                    if (version !== "1.0") {
                        throw new Error("Invalid xml version: " + version);
                    }
                    var builderOptions = {
                        version: version
                    };
                    if (declaration.encoding) {
                        builderOptions.encoding = this.sanitize(declaration.encoding);
                    }
                    if (declaration.standalone) {
                        builderOptions.standalone = (this.sanitize(declaration.standalone) === "yes");
                    }
                    context.set(builderOptions);
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    context = this.cdata(context, this.sanitize(cdata.data)) || context;
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    context = this.comment(context, this.sanitize(comment.data)) || context;
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;
                    break;
                case interfaces_1.TokenType.Text:
                    var text = token;
                    context = this.text(context, this._decodeText(this.sanitize(text.data))) || context;
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    var elementName = this.sanitize(element.name);
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(elementName), 1), prefix = _c[0];
                    var namespace = context.node.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for (var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            if (attName === "xmlns") {
                                namespace = attValue;
                            }
                            else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    // create the DOM element node
                    var elementNode = (namespace !== null ?
                        this.element(context, namespace, elementName) :
                        this.element(context, undefined, elementName));
                    if (elementNode === undefined)
                        break;
                    if (context.node === node.node)
                        lastChild = elementNode;
                    try {
                        // assign attributes
                        for (var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()) {
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || (attPrefix === null && attLocalName === "xmlns")) {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            }
                            else {
                                attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                }
                                else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (attNamespace !== null)
                                this.attribute(elementNode, attNamespace, attName, this._decodeAttributeValue(attValue));
                            else
                                this.attribute(elementNode, undefined, attName, this._decodeAttributeValue(attValue));
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    /* istanbul ignore else */
                    if (context.node.parentNode) {
                        context = context.up();
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return lastChild;
    };
    return XMLReader;
}(BaseReader_1.BaseReader));
exports.XMLReader = XMLReader;
//# sourceMappingURL=XMLReader.js.map

/***/ }),

/***/ 2475:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectReader_1 = __nccwpck_require__(768);
var BaseReader_1 = __nccwpck_require__(3396);
var js_yaml_1 = __nccwpck_require__(829);
/**
 * Parses XML nodes from a YAML string.
 */
var YAMLReader = /** @class */ (function (_super) {
    __extends(YAMLReader, _super);
    function YAMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - YAML string to parse
     */
    YAMLReader.prototype._parse = function (node, str) {
        var result = js_yaml_1.safeLoad(str);
        /* istanbul ignore next */
        if (result === undefined) {
            throw new Error("Unable to parse YAML document.");
        }
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);
    };
    return YAMLReader;
}(BaseReader_1.BaseReader));
exports.YAMLReader = YAMLReader;
//# sourceMappingURL=YAMLReader.js.map

/***/ }),

/***/ 560:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var XMLReader_1 = __nccwpck_require__(5044);
exports.XMLReader = XMLReader_1.XMLReader;
var ObjectReader_1 = __nccwpck_require__(768);
exports.ObjectReader = ObjectReader_1.ObjectReader;
var JSONReader_1 = __nccwpck_require__(3518);
exports.JSONReader = JSONReader_1.JSONReader;
var YAMLReader_1 = __nccwpck_require__(2475);
exports.YAMLReader = YAMLReader_1.YAMLReader;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Pre-serializes XML nodes.
 */
var BaseCBWriter = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseCBWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */
        this.level = 0;
        this._builderOptions = builderOptions;
        this._writerOptions = builderOptions;
    }
    return BaseCBWriter;
}());
exports.BaseCBWriter = BaseCBWriter;
//# sourceMappingURL=BaseCBWriter.js.map

/***/ }),

/***/ 7644:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interfaces_1 = __nccwpck_require__(7305);
var LocalNameSet_1 = __nccwpck_require__(9049);
var NamespacePrefixMap_1 = __nccwpck_require__(283);
var infra_1 = __nccwpck_require__(4251);
var algorithm_1 = __nccwpck_require__(61);
/**
 * Pre-serializes XML nodes.
 */
var BaseWriter = /** @class */ (function () {
    /**
     * Initializes a new instance of `BaseWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function BaseWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */
        this.level = 0;
        this._builderOptions = builderOptions;
    }
    /**
     * Used by derived classes to serialize the XML declaration.
     *
     * @param version - a version number string
     * @param encoding - encoding declaration
     * @param standalone - standalone document declaration
     */
    BaseWriter.prototype.declaration = function (version, encoding, standalone) { };
    /**
     * Used by derived classes to serialize a DocType node.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */
    BaseWriter.prototype.docType = function (name, publicId, systemId) { };
    /**
     * Used by derived classes to serialize a comment node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.comment = function (data) { };
    /**
     * Used by derived classes to serialize a text node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.text = function (data) { };
    /**
     * Used by derived classes to serialize a processing instruction node.
     *
     * @param target - instruction target
     * @param data - node data
     */
    BaseWriter.prototype.instruction = function (target, data) { };
    /**
     * Used by derived classes to serialize a CData section node.
     *
     * @param data - node data
     */
    BaseWriter.prototype.cdata = function (data) { };
    /**
     * Used by derived classes to serialize the beginning of the opening tag of an
     * element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.openTagBegin = function (name) { };
    /**
     * Used by derived classes to serialize the ending of the opening tag of an
     * element node.
     *
     * @param name - node name
     * @param selfClosing - whether the element node is self closing
     * @param voidElement - whether the element node is a HTML void element
     */
    BaseWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) { };
    /**
     * Used by derived classes to serialize the closing tag of an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.closeTag = function (name) { };
    /**
     * Used by derived classes to serialize attributes or namespace declarations.
     *
     * @param attributes - attribute array
     */
    BaseWriter.prototype.attributes = function (attributes) {
        var e_1, _a;
        try {
            for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
                var attr = attributes_1_1.value;
                this.attribute(attr[1] === null ? attr[2] : attr[1] + ':' + attr[2], attr[3]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Used by derived classes to serialize an attribute or namespace declaration.
     *
     * @param name - node name
     * @param value - node value
     */
    BaseWriter.prototype.attribute = function (name, value) { };
    /**
     * Used by derived classes to perform any pre-processing steps before starting
     * serializing an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.beginElement = function (name) { };
    /**
     * Used by derived classes to perform any post-processing steps after
     * completing serializing an element node.
     *
     * @param name - node name
     */
    BaseWriter.prototype.endElement = function (name) { };
    /**
     * Produces an XML serialization of the given node. The pre-serializer inserts
     * namespace declarations where necessary and produces qualified names for
     * nodes and attributes.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype.serializeNode = function (node, requireWellFormed) {
        var hasNamespaces = (node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces);
        this.level = 0;
        this.currentNode = node;
        if (hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */
            var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = { value: 1 };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */
            this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        }
        else {
            this._serializeNode(node, requireWellFormed);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeNodeNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        this.currentNode = node;
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeNode = function (node, requireWellFormed) {
        this.currentNode = node;
        switch (node.nodeType) {
            case interfaces_1.NodeType.Element:
                this._serializeElement(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocument(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeElementNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        var attributes = [];
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var qualifiedName = '';
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */
        if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */
            if (ns === infra_1.namespace.XML) {
                qualifiedName = 'xml:' + node.localName;
            }
            else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */
            this.beginElement(qualifiedName);
            this.openTagBegin(qualifiedName);
        }
        else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */
            var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */
            if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */
                if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */
                candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */
            if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */
                qualifiedName = candidatePrefix + ':' + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /** 12.5. Otherwise, if prefix is not null, then: */
            }
            else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */
                map.set(prefix, ns);
                qualifiedName += prefix + ':' + node.localName;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */
                attributes.push([null, 'xmlns', prefix,
                    this._serializeAttributeValue(ns, requireWellFormed)]);
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */
            }
            else if (localDefaultNamespace === null ||
                (localDefaultNamespace !== null && localDefaultNamespace !== ns)) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */
                attributes.push([null, null, 'xmlns',
                    this._serializeAttributeValue(ns, requireWellFormed)]);
                /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */
            }
            else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        attributes.push.apply(attributes, __spread(this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed)));
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        var isHTML = (ns === infra_1.namespace.HTML);
        if (isHTML && node.childNodes.length === 0 &&
            BaseWriter._VoidElementNames.has(node.localName)) {
            this.openTagEnd(qualifiedName, true, true);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else if (!isHTML && node.childNodes.length === 0) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */
        if (isHTML && node.localName === "template") {
            // TODO: serialize template contents
        }
        else {
            try {
                for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var childNode = _c.value;
                    this.level++;
                    this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                    this.level--;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */
        this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeElement = function (node, requireWellFormed) {
        var e_3, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */
        if (requireWellFormed && (node.localName.indexOf(":") !== -1 ||
            !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */
        var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */
        /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         */
        /**
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */
        var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */
        this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */
        var attributes = this._serializeAttributes(node, requireWellFormed);
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */
        if (!node.hasChildNodes()) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        }
        else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */
        if (skipEndTag)
            return;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this.level++;
                this._serializeNode(childNode, requireWellFormed);
                this.level--;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */
        this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_4, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocument = function (node, requireWellFormed) {
        var e_5, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */
        if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeComment = function (node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */
        this.comment(node.data);
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */
    BaseWriter.prototype._serializeText = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */
        if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */
        var markup = node.data.replace(/(?!&([^&;]*);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
        this.text(markup);
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentFragmentNS = function (node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_6, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentFragment = function (node, requireWellFormed) {
        var e_7, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */
            for (var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeDocumentType = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */
        if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */
        if (requireWellFormed &&
            (!algorithm_1.xml_isLegalChar(node.systemId) ||
                (node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1))) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */
        this.docType(node.name, node.publicId, node.systemId);
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeProcessingInstruction = function (node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */
        if (requireWellFormed && (node.target.indexOf(":") !== -1 || (/^xml$/i).test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */
        if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) ||
            node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */
        this.instruction(node.target, node.data);
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeCData = function (node, requireWellFormed) {
        if (requireWellFormed && (node.data.indexOf("]]>") !== -1)) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        this.cdata(node.data);
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */
    BaseWriter.prototype._serializeAttributesNS = function (node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = [];
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    result.push([null, null, attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                if (requireWellFormed && localNameSet)
                    localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */
                        if (attr.value === infra_1.namespace.XML ||
                            (attr.prefix === null && ignoreNamespaceDefinitionAttribute) ||
                            (attr.prefix !== null && (!(attr.localName in localPrefixesMap) ||
                                localPrefixesMap[attr.localName] !== attr.value) &&
                                map.has(attr.localName, attr.value)))
                            continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */
                        if (requireWellFormed && attr.value === '') {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */
                        if (attr.prefix === 'xmlns')
                            candidatePrefix = 'xmlns';
                        /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */
                    }
                    else if (candidatePrefix === null) {
                        if (attr.prefix !== null &&
                            (!map.hasPrefix(attr.prefix) ||
                                map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */
                            candidatePrefix = attr.prefix;
                        }
                        else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */
                        result.push([null, "xmlns", candidatePrefix,
                            this._serializeAttributeValue(attributeNamespace, requireWellFormed)]);
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                var attrName = '';
                if (candidatePrefix !== null) {
                    attrName = candidatePrefix;
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName) ||
                    (attr.localName === "xmlns" && attributeNamespace === null))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result.push([attributeNamespace, candidatePrefix, attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)]);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_8) throw e_8.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
    */
    BaseWriter.prototype._serializeAttributes = function (node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */
        var result = [];
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed) {
                    result.push([null, null, attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */
                if (requireWellFormed && localNameSet && (attr.localName in localNameSet)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */
                /* istanbul ignore else */
                if (requireWellFormed && localNameSet)
                    localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 ||
                    !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */
                result.push([null, null, attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)]);
            }
        }
        catch (e_9_1) { e_9 = { error: e_9_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_9) throw e_9.error; }
        }
        /**
         * 4. Return the value of result.
         */
        return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */
    BaseWriter.prototype._recordNamespaceInformation = function (node, map, localPrefixesMap) {
        var e_10, _a;
        /**
         * 1. Let default namespace attr value be null.
         */
        var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */
            for (var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */
                /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */
                var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */
                var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                        /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */
                    }
                    else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */
                        var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */
                        var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */
                        if (namespaceDefinition === '') {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */
                        map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || '';
                    }
                }
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */
        return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */
    BaseWriter.prototype._generatePrefix = function (newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */
        var generatedPrefix = "ns" + prefixIndex.value.toString();
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */
    BaseWriter.prototype._serializeAttributeValue = function (value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */
        if (value === null)
            return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */
        return value.replace(/(?!&([^&;]*);)&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    };
    BaseWriter._VoidElementNames = new Set(['area', 'base', 'basefont',
        'bgsound', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen',
        'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr']);
    return BaseWriter;
}());
exports.BaseWriter = BaseWriter;
//# sourceMappingURL=BaseWriter.js.map

/***/ }),

/***/ 7525:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(708);
/**
 * Serializes XML nodes.
 */
var JSONCBWriter = /** @class */ (function (_super) {
    __extends(JSONCBWriter, _super);
    /**
     * Initializes a new instance of `JSONCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function JSONCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._hasChildren = [];
        _this._additionalLevel = 0;
        return _this;
    }
    /** @inheritdoc */
    JSONCBWriter.prototype.frontMatter = function () {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.declaration = function (version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.docType = function (name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.comment = function (data) {
        // { "!": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.comment) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.text = function (data) {
        // { "#": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.text) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.instruction = function (target, data) {
        // { "?": "target hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.ins) + this._sep() +
            this._val(data ? target + " " + data : target) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.cdata = function (data) {
        // { "$": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() +
            this._key(this._builderOptions.convert.cdata) + this._sep() +
            this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.attribute = function (name, value) {
        // { "@name": "val" }
        return this._comma() + this._beginLine(1) + "{" + this._sep() +
            this._key(this._builderOptions.convert.att + name) + this._sep() +
            this._val(value) + this._sep() + "}";
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.openTagBegin = function (name) {
        // { "node": { "#": [
        var str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
        this._additionalLevel++;
        this.hasData = true;
        str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
        this._hasChildren.push(false);
        return str;
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (selfClosing) {
            var str = this._sep() + "]";
            this._additionalLevel--;
            str += this._beginLine() + "}" + this._sep() + "}";
            return str;
        }
        else {
            return "";
        }
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.closeTag = function (name) {
        // ] } }
        var str = this._beginLine() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
    };
    /** @inheritdoc */
    JSONCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    JSONCBWriter.prototype.endElement = function (name) { this._hasChildren.pop(); };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    JSONCBWriter.prototype._beginLine = function (additionalOffset) {
        if (additionalOffset === void 0) { additionalOffset = 0; }
        if (this._writerOptions.prettyPrint) {
            return (this.hasData ? this._writerOptions.newline : "") +
                this._indent(this._writerOptions.offset + this.level + additionalOffset);
        }
        else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    JSONCBWriter.prototype._indent = function (level) {
        if (level + this._additionalLevel <= 0) {
            return "";
        }
        else {
            return this._writerOptions.indent.repeat(level + this._additionalLevel);
        }
    };
    /**
     * Produces a comma before a child node if it has previous siblings.
     */
    JSONCBWriter.prototype._comma = function () {
        var str = (this._hasChildren[this._hasChildren.length - 1] ? "," : "");
        if (this._hasChildren.length > 0) {
            this._hasChildren[this._hasChildren.length - 1] = true;
        }
        return str;
    };
    /**
     * Produces a separator string.
     */
    JSONCBWriter.prototype._sep = function () {
        return (this._writerOptions.prettyPrint ? " " : "");
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */
    JSONCBWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */
    JSONCBWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return JSONCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.JSONCBWriter = JSONCBWriter;
//# sourceMappingURL=JSONCBWriter.js.map

/***/ }),

/***/ 7510:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectWriter_1 = __nccwpck_require__(243);
var util_1 = __nccwpck_require__(6195);
var BaseWriter_1 = __nccwpck_require__(7644);
/**
 * Serializes XML nodes into a JSON string.
 */
var JSONWriter = /** @class */ (function (_super) {
    __extends(JSONWriter, _super);
    /**
     * Initializes a new instance of `JSONWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function JSONWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            prettyPrint: false,
            indent: '  ',
            newline: '\n',
            offset: 0,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    JSONWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into JSON string
        return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     */
    JSONWriter.prototype._convertObject = function (obj, options, level) {
        var e_1, _a;
        var _this = this;
        if (level === void 0) { level = 0; }
        var markup = '';
        var isLeaf = this._isLeafNode(obj);
        if (util_1.isArray(obj)) {
            markup += '[';
            var len = obj.length;
            var i = 0;
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var val = obj_1_1.value;
                    markup += this._endLine(options, level + 1) +
                        this._beginLine(options, level + 1) +
                        this._convertObject(val, options, level + 1);
                    if (i < len - 1) {
                        markup += ',';
                    }
                    i++;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            markup += this._endLine(options, level) + this._beginLine(options, level);
            markup += ']';
        }
        else if (util_1.isObject(obj)) {
            markup += '{';
            var len_1 = util_1.objectLength(obj);
            var i_1 = 0;
            util_1.forEachObject(obj, function (key, val) {
                if (isLeaf && options.prettyPrint) {
                    markup += ' ';
                }
                else {
                    markup += _this._endLine(options, level + 1) + _this._beginLine(options, level + 1);
                }
                markup += _this._key(key);
                if (options.prettyPrint) {
                    markup += ' ';
                }
                markup += _this._convertObject(val, options, level + 1);
                if (i_1 < len_1 - 1) {
                    markup += ',';
                }
                i_1++;
            }, this);
            if (isLeaf && options.prettyPrint) {
                markup += ' ';
            }
            else {
                markup += this._endLine(options, level) + this._beginLine(options, level);
            }
            markup += '}';
        }
        else {
            markup += this._val(obj);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    JSONWriter.prototype._beginLine = function (options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            var indentLevel = options.offset + level + 1;
            if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
            }
        }
        return '';
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */
    JSONWriter.prototype._endLine = function (options, level) {
        if (!options.prettyPrint) {
            return '';
        }
        else {
            return options.newline;
        }
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */
    JSONWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */
    JSONWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    /**
     * Determines if an object is a leaf node.
     *
     * @param obj
     */
    JSONWriter.prototype._isLeafNode = function (obj) {
        return this._descendantCount(obj) <= 1;
    };
    /**
     * Counts the number of descendants of the given object.
     *
     * @param obj
     * @param count
     */
    JSONWriter.prototype._descendantCount = function (obj, count) {
        var _this = this;
        if (count === void 0) { count = 0; }
        if (util_1.isArray(obj)) {
            util_1.forEachArray(obj, function (val) { return count += _this._descendantCount(val, count); }, this);
        }
        else if (util_1.isObject(obj)) {
            util_1.forEachObject(obj, function (key, val) { return count += _this._descendantCount(val, count); }, this);
        }
        else {
            count++;
        }
        return count;
    };
    return JSONWriter;
}(BaseWriter_1.BaseWriter));
exports.JSONWriter = JSONWriter;
//# sourceMappingURL=JSONWriter.js.map

/***/ }),

/***/ 1397:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var ObjectWriter_1 = __nccwpck_require__(243);
var BaseWriter_1 = __nccwpck_require__(7644);
/**
 * Serializes XML nodes into ES6 maps and arrays.
 */
var MapWriter = /** @class */ (function (_super) {
    __extends(MapWriter, _super);
    /**
     * Initializes a new instance of `MapWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function MapWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "map",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    MapWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false,
            verbose: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into Map
        return this._convertObject(val);
    };
    /**
     * Recursively converts a JS object into an ES5 map.
     *
     * @param obj - a JS object
     */
    MapWriter.prototype._convertObject = function (obj) {
        if (util_1.isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
                obj[i] = this._convertObject(obj[i]);
            }
            return obj;
        }
        else if (util_1.isObject(obj)) {
            var map = new Map();
            for (var key in obj) {
                map.set(key, this._convertObject(obj[key]));
            }
            return map;
        }
        else {
            return obj;
        }
    };
    return MapWriter;
}(BaseWriter_1.BaseWriter));
exports.MapWriter = MapWriter;
//# sourceMappingURL=MapWriter.js.map

/***/ }),

/***/ 243:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var interfaces_1 = __nccwpck_require__(7305);
var BaseWriter_1 = __nccwpck_require__(7644);
/**
 * Serializes XML nodes into objects and arrays.
 */
var ObjectWriter = /** @class */ (function (_super) {
    __extends(ObjectWriter, _super);
    /**
     * Initializes a new instance of `ObjectWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function ObjectWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "object",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    ObjectWriter.prototype.serialize = function (node) {
        this._currentList = [];
        this._currentIndex = 0;
        this._listRegister = [this._currentList];
        /**
         * First pass, serialize nodes
         * This creates a list of nodes grouped under node types while preserving
         * insertion order. For example:
         * [
         *   root: [
         *     node: [
         *       { "@" : { "att1": "val1", "att2": "val2" }
         *       { "#": "node text" }
         *       { childNode: [] }
         *       { "#": "more text" }
         *     ],
         *     node: [
         *       { "@" : { "att": "val" }
         *       { "#": [ "text line1", "text line2" ] }
         *     ]
         *   ]
         * ]
         */
        this.serializeNode(node, this._writerOptions.wellFormed);
        /**
         * Second pass, process node lists. Above example becomes:
         * {
         *   root: {
         *     node: [
         *       {
         *         "@att1": "val1",
         *         "@att2": "val2",
         *         "#1": "node text",
         *         childNode: {},
         *         "#2": "more text"
         *       },
         *       {
         *         "@att": "val",
         *         "#": [ "text line1", "text line2" ]
         *       }
         *     ]
         *   }
         * }
         */
        return this._process(this._currentList, this._writerOptions);
    };
    ObjectWriter.prototype._process = function (items, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (items.length === 0)
            return {};
        // determine if there are non-unique element names
        var namesSeen = {};
        var hasNonUniqueNames = false;
        var textCount = 0;
        var commentCount = 0;
        var instructionCount = 0;
        var cdataCount = 0;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var key = Object.keys(item)[0];
            switch (key) {
                case "@":
                    continue;
                case "#":
                    textCount++;
                    break;
                case "!":
                    commentCount++;
                    break;
                case "?":
                    instructionCount++;
                    break;
                case "$":
                    cdataCount++;
                    break;
                default:
                    if (namesSeen[key]) {
                        hasNonUniqueNames = true;
                    }
                    else {
                        namesSeen[key] = true;
                    }
                    break;
            }
        }
        var defAttrKey = this._getAttrKey();
        var defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
        var defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
        var defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
        var defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
        if (textCount === 1 && items.length === 1 && util_1.isString(items[0]["#"])) {
            // special case of an element node with a single text node
            return items[0]["#"];
        }
        else if (hasNonUniqueNames) {
            var obj = {};
            // process attributes first
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                if (key === "@") {
                    var attrs = item["@"];
                    var attrKeys = Object.keys(attrs);
                    if (attrKeys.length === 1) {
                        obj[defAttrKey + attrKeys[0]] = attrs[attrKeys[0]];
                    }
                    else {
                        obj[defAttrKey] = item["@"];
                    }
                }
            }
            // list contains element nodes with non-unique names
            // return an array with mixed content notation
            var result = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                switch (key) {
                    case "@":
                        // attributes were processed above
                        break;
                    case "#":
                        result.push((_a = {}, _a[defTextKey] = item["#"], _a));
                        break;
                    case "!":
                        result.push((_b = {}, _b[defCommentKey] = item["!"], _b));
                        break;
                    case "?":
                        result.push((_c = {}, _c[defInstructionKey] = item["?"], _c));
                        break;
                    case "$":
                        result.push((_d = {}, _d[defCdataKey] = item["$"], _d));
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for (var i_1 = 0; i_1 < listOfLists.length; i_1++) {
                                eleGroup.push(this._process(listOfLists[i_1], options));
                            }
                            result.push((_e = {}, _e[key] = eleGroup, _e));
                        }
                        else {
                            // single element node
                            if (options.verbose) {
                                result.push((_f = {}, _f[key] = [this._process(ele[key], options)], _f));
                            }
                            else {
                                result.push((_g = {}, _g[key] = this._process(ele[key], options), _g));
                            }
                        }
                        break;
                }
            }
            obj[defTextKey] = result;
            return obj;
        }
        else {
            // all element nodes have unique names
            // return an object while prefixing data node keys
            var textId = 1;
            var commentId = 1;
            var instructionId = 1;
            var cdataId = 1;
            var obj = {};
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var key = Object.keys(item)[0];
                switch (key) {
                    case "@":
                        var attrs = item["@"];
                        var attrKeys = Object.keys(attrs);
                        if (!options.group || attrKeys.length === 1) {
                            for (var attrName in attrs) {
                                obj[defAttrKey + attrName] = attrs[attrName];
                            }
                        }
                        else {
                            obj[defAttrKey] = attrs;
                        }
                        break;
                    case "#":
                        textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
                        break;
                    case "!":
                        commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
                        break;
                    case "?":
                        instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
                        break;
                    case "$":
                        cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for (var i_2 = 0; i_2 < listOfLists.length; i_2++) {
                                eleGroup.push(this._process(listOfLists[i_2], options));
                            }
                            obj[key] = eleGroup;
                        }
                        else {
                            // single element node
                            if (options.verbose) {
                                obj[key] = [this._process(ele[key], options)];
                            }
                            else {
                                obj[key] = this._process(ele[key], options);
                            }
                        }
                        break;
                }
            }
            return obj;
        }
    };
    ObjectWriter.prototype._processSpecItem = function (item, obj, group, defKey, count, id) {
        var e_1, _a;
        if (!group && util_1.isArray(item) && count + item.length > 2) {
            try {
                for (var item_1 = __values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()) {
                    var subItem = item_1_1.value;
                    var key = defKey + (id++).toString();
                    obj[key] = subItem;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else {
            var key = count > 1 ? defKey + (id++).toString() : defKey;
            obj[key] = item;
        }
        return id;
    };
    /** @inheritdoc */
    ObjectWriter.prototype.beginElement = function (name) {
        var _a, _b;
        var childItems = [];
        if (this._currentList.length === 0) {
            this._currentList.push((_a = {}, _a[name] = childItems, _a));
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isElementNode(lastItem, name)) {
                if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {
                    var listOfLists = lastItem[name];
                    listOfLists.push(childItems);
                }
                else {
                    lastItem[name] = [lastItem[name], childItems];
                }
            }
            else {
                this._currentList.push((_b = {}, _b[name] = childItems, _b));
            }
        }
        this._currentIndex++;
        if (this._listRegister.length > this._currentIndex) {
            this._listRegister[this._currentIndex] = childItems;
        }
        else {
            this._listRegister.push(childItems);
        }
        this._currentList = childItems;
    };
    /** @inheritdoc */
    ObjectWriter.prototype.endElement = function () {
        this._currentList = this._listRegister[--this._currentIndex];
    };
    /** @inheritdoc */
    ObjectWriter.prototype.attribute = function (name, value) {
        var _a, _b;
        if (this._currentList.length === 0) {
            this._currentList.push({ "@": (_a = {}, _a[name] = value, _a) });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            /* istanbul ignore else */
            if (this._isAttrNode(lastItem)) {
                lastItem["@"][name] = value;
            }
            else {
                this._currentList.push({ "@": (_b = {}, _b[name] = value, _b) });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.comment = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "!": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCommentNode(lastItem)) {
                if (util_1.isArray(lastItem["!"])) {
                    lastItem["!"].push(data);
                }
                else {
                    lastItem["!"] = [lastItem["!"], data];
                }
            }
            else {
                this._currentList.push({ "!": data });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.text = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "#": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isTextNode(lastItem)) {
                if (util_1.isArray(lastItem["#"])) {
                    lastItem["#"].push(data);
                }
                else {
                    lastItem["#"] = [lastItem["#"], data];
                }
            }
            else {
                this._currentList.push({ "#": data });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.instruction = function (target, data) {
        var value = (data === "" ? target : target + " " + data);
        if (this._currentList.length === 0) {
            this._currentList.push({ "?": value });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isInstructionNode(lastItem)) {
                if (util_1.isArray(lastItem["?"])) {
                    lastItem["?"].push(value);
                }
                else {
                    lastItem["?"] = [lastItem["?"], value];
                }
            }
            else {
                this._currentList.push({ "?": value });
            }
        }
    };
    /** @inheritdoc */
    ObjectWriter.prototype.cdata = function (data) {
        if (this._currentList.length === 0) {
            this._currentList.push({ "$": data });
        }
        else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCDATANode(lastItem)) {
                if (util_1.isArray(lastItem["$"])) {
                    lastItem["$"].push(data);
                }
                else {
                    lastItem["$"] = [lastItem["$"], data];
                }
            }
            else {
                this._currentList.push({ "$": data });
            }
        }
    };
    ObjectWriter.prototype._isAttrNode = function (x) {
        return "@" in x;
    };
    ObjectWriter.prototype._isTextNode = function (x) {
        return "#" in x;
    };
    ObjectWriter.prototype._isCommentNode = function (x) {
        return "!" in x;
    };
    ObjectWriter.prototype._isInstructionNode = function (x) {
        return "?" in x;
    };
    ObjectWriter.prototype._isCDATANode = function (x) {
        return "$" in x;
    };
    ObjectWriter.prototype._isElementNode = function (x, name) {
        return name in x;
    };
    /**
     * Returns an object key for an attribute or namespace declaration.
     */
    ObjectWriter.prototype._getAttrKey = function () {
        return this._builderOptions.convert.att;
    };
    /**
     * Returns an object key for the given node type.
     *
     * @param nodeType - node type to get a key for
     */
    ObjectWriter.prototype._getNodeKey = function (nodeType) {
        switch (nodeType) {
            case interfaces_1.NodeType.Comment:
                return this._builderOptions.convert.comment;
            case interfaces_1.NodeType.Text:
                return this._builderOptions.convert.text;
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._builderOptions.convert.ins;
            case interfaces_1.NodeType.CData:
                return this._builderOptions.convert.cdata;
            /* istanbul ignore next */
            default:
                throw new Error("Invalid node type.");
        }
    };
    return ObjectWriter;
}(BaseWriter_1.BaseWriter));
exports.ObjectWriter = ObjectWriter;
//# sourceMappingURL=ObjectWriter.js.map

/***/ }),

/***/ 7572:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(708);
/**
 * Serializes XML nodes.
 */
var XMLCBWriter = /** @class */ (function (_super) {
    __extends(XMLCBWriter, _super);
    /**
     * Initializes a new instance of `XMLCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function XMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._lineLength = 0;
        return _this;
    }
    /** @inheritdoc */
    XMLCBWriter.prototype.frontMatter = function () {
        return "";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.declaration = function (version, encoding, standalone) {
        var markup = this._beginLine() + "<?xml";
        markup += " version=\"" + version + "\"";
        if (encoding !== undefined) {
            markup += " encoding=\"" + encoding + "\"";
        }
        if (standalone !== undefined) {
            markup += " standalone=\"" + (standalone ? "yes" : "no") + "\"";
        }
        markup += "?>";
        return markup;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.docType = function (name, publicId, systemId) {
        var markup = this._beginLine();
        if (publicId && systemId) {
            markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\" \"" + systemId + "\">";
        }
        else if (publicId) {
            markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\">";
        }
        else if (systemId) {
            markup += "<!DOCTYPE " + name + " SYSTEM \"" + systemId + "\">";
        }
        else {
            markup += "<!DOCTYPE " + name + ">";
        }
        return markup;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.comment = function (data) {
        return this._beginLine() + "<!--" + data + "-->";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.text = function (data) {
        return this._beginLine() + data;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.instruction = function (target, data) {
        if (data) {
            return this._beginLine() + "<?" + target + " " + data + "?>";
        }
        else {
            return this._beginLine() + "<?" + target + "?>";
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.cdata = function (data) {
        return this._beginLine() + "<![CDATA[" + data + "]]>";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.openTagBegin = function (name) {
        this._lineLength += 1 + name.length;
        return this._beginLine() + "<" + name;
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (voidElement) {
            return " />";
        }
        else if (selfClosing) {
            if (this._writerOptions.allowEmptyTags) {
                return "></" + name + ">";
            }
            else if (this._writerOptions.spaceBeforeSlash) {
                return " />";
            }
            else {
                return "/>";
            }
        }
        else {
            return ">";
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.closeTag = function (name) {
        return this._beginLine() + "</" + name + ">";
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.attribute = function (name, value) {
        var str = name + "=\"" + value + "\"";
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&
            this._lineLength + 1 + str.length > this._writerOptions.width) {
            str = this._beginLine() + this._indent(1) + str;
            this._lineLength = str.length;
            return str;
        }
        else {
            this._lineLength += 1 + str.length;
            return " " + str;
        }
    };
    /** @inheritdoc */
    XMLCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    XMLCBWriter.prototype.endElement = function (name) { };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    XMLCBWriter.prototype._beginLine = function () {
        if (this._writerOptions.prettyPrint) {
            var str = (this.hasData ? this._writerOptions.newline : "") +
                this._indent(this._writerOptions.offset + this.level);
            this._lineLength = str.length;
            return str;
        }
        else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    XMLCBWriter.prototype._indent = function (level) {
        if (level <= 0) {
            return "";
        }
        else {
            return this._writerOptions.indent.repeat(level);
        }
    };
    return XMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.XMLCBWriter = XMLCBWriter;
//# sourceMappingURL=XMLCBWriter.js.map

/***/ }),

/***/ 9606:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var util_1 = __nccwpck_require__(6195);
var interfaces_1 = __nccwpck_require__(7305);
var BaseWriter_1 = __nccwpck_require__(7644);
var util_2 = __nccwpck_require__(5282);
/**
 * Serializes XML nodes into strings.
 */
var XMLWriter = /** @class */ (function (_super) {
    __extends(XMLWriter, _super);
    /**
     * Initializes a new instance of `XMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function XMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._indentation = {};
        _this._lengthToLastNewline = 0;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            headless: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            width: 0,
            allowEmptyTags: false,
            indentTextOnlyNodes: false,
            spaceBeforeSlash: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */
    XMLWriter.prototype.serialize = function (node) {
        this._refs = { suppressPretty: false, emptyNode: false, markup: "" };
        // Serialize XML declaration
        if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {
            this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);
        }
        // recursively serialize node
        this.serializeNode(node, this._writerOptions.wellFormed);
        // remove trailing newline
        if (this._writerOptions.prettyPrint &&
            this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);
        }
        return this._refs.markup;
    };
    /** @inheritdoc */
    XMLWriter.prototype.declaration = function (version, encoding, standalone) {
        this._beginLine();
        this._refs.markup += "<?xml version=\"" + version + "\"";
        if (encoding !== undefined) {
            this._refs.markup += " encoding=\"" + encoding + "\"";
        }
        if (standalone !== undefined) {
            this._refs.markup += " standalone=\"" + (standalone ? "yes" : "no") + "\"";
        }
        this._refs.markup += "?>";
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.docType = function (name, publicId, systemId) {
        this._beginLine();
        if (publicId && systemId) {
            this._refs.markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\" \"" + systemId + "\">";
        }
        else if (publicId) {
            this._refs.markup += "<!DOCTYPE " + name + " PUBLIC \"" + publicId + "\">";
        }
        else if (systemId) {
            this._refs.markup += "<!DOCTYPE " + name + " SYSTEM \"" + systemId + "\">";
        }
        else {
            this._refs.markup += "<!DOCTYPE " + name + ">";
        }
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.openTagBegin = function (name) {
        this._beginLine();
        this._refs.markup += "<" + name;
    };
    /** @inheritdoc */
    XMLWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        // do not indent text only elements or elements with empty text nodes
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {
            var textOnlyNode = true;
            var emptyNode = true;
            var childNode = this.currentNode.firstChild;
            var cdataCount = 0;
            var textCount = 0;
            while (childNode) {
                if (util_2.Guard.isExclusiveTextNode(childNode)) {
                    textCount++;
                }
                else if (util_2.Guard.isCDATASectionNode(childNode)) {
                    cdataCount++;
                }
                else {
                    textOnlyNode = false;
                    emptyNode = false;
                    break;
                }
                if (childNode.data !== '') {
                    emptyNode = false;
                }
                childNode = childNode.nextSibling;
            }
            this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && ((cdataCount <= 1 && textCount === 0) || cdataCount === 0);
            this._refs.emptyNode = emptyNode;
        }
        if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {
            this._refs.markup += "></" + name + ">";
        }
        else {
            this._refs.markup += voidElement ? " />" :
                (selfClosing || this._refs.emptyNode) ? (this._writerOptions.spaceBeforeSlash ? " />" : "/>") : ">";
        }
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.closeTag = function (name) {
        if (!this._refs.emptyNode) {
            this._beginLine();
            this._refs.markup += "</" + name + ">";
        }
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.attribute = function (name, value) {
        var str = name + "=\"" + value + "\"";
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 &&
            this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {
            this._endLine();
            this._beginLine();
            this._refs.markup += this._indent(1) + str;
        }
        else {
            this._refs.markup += " " + str;
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.text = function (data) {
        if (data !== '') {
            this._beginLine();
            this._refs.markup += data;
            this._endLine();
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.cdata = function (data) {
        if (data !== '') {
            this._beginLine();
            this._refs.markup += "<![CDATA[" + data + "]]>";
            this._endLine();
        }
    };
    /** @inheritdoc */
    XMLWriter.prototype.comment = function (data) {
        this._beginLine();
        this._refs.markup += "<!--" + data + "-->";
        this._endLine();
    };
    /** @inheritdoc */
    XMLWriter.prototype.instruction = function (target, data) {
        this._beginLine();
        this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
        this._endLine();
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    XMLWriter.prototype._beginLine = function () {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._indent(this._writerOptions.offset + this.level);
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     */
    XMLWriter.prototype._endLine = function () {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._writerOptions.newline;
            this._lengthToLastNewline = this._refs.markup.length;
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */
    XMLWriter.prototype._indent = function (level) {
        if (level <= 0) {
            return "";
        }
        else if (this._indentation[level] !== undefined) {
            return this._indentation[level];
        }
        else {
            var str = this._writerOptions.indent.repeat(level);
            this._indentation[level] = str;
            return str;
        }
    };
    return XMLWriter;
}(BaseWriter_1.BaseWriter));
exports.XMLWriter = XMLWriter;
//# sourceMappingURL=XMLWriter.js.map

/***/ }),

/***/ 2444:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var BaseCBWriter_1 = __nccwpck_require__(708);
/**
 * Serializes XML nodes.
 */
var YAMLCBWriter = /** @class */ (function (_super) {
    __extends(YAMLCBWriter, _super);
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */
    function YAMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._rootWritten = false;
        _this._additionalLevel = 0;
        if (builderOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (builderOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /** @inheritdoc */
    YAMLCBWriter.prototype.frontMatter = function () {
        return this._beginLine() + "---";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.declaration = function (version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.docType = function (name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.comment = function (data) {
        // "!": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.comment) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.text = function (data) {
        // "#": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.text) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.instruction = function (target, data) {
        // "?": "target hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.ins) + " " +
            this._val(data ? target + " " + data : target);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.cdata = function (data) {
        // "$": "hello"
        return this._beginLine() +
            this._key(this._builderOptions.convert.cdata) + " " +
            this._val(data);
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.attribute = function (name, value) {
        // "@name": "val"
        this._additionalLevel++;
        var str = this._beginLine() +
            this._key(this._builderOptions.convert.att + name) + " " +
            this._val(value);
        this._additionalLevel--;
        return str;
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.openTagBegin = function (name) {
        // "node":
        //   "#":
        //   -
        var str = this._beginLine() + this._key(name);
        if (!this._rootWritten) {
            this._rootWritten = true;
        }
        this.hasData = true;
        this._additionalLevel++;
        str += this._beginLine(true) + this._key(this._builderOptions.convert.text);
        return str;
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.openTagEnd = function (name, selfClosing, voidElement) {
        if (selfClosing) {
            return " " + this._val("");
        }
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.closeTag = function (name) {
        this._additionalLevel--;
        return "";
    };
    /** @inheritdoc */
    YAMLCBWriter.prototype.beginElement = function (name) { };
    /** @inheritdoc */
    YAMLCBWriter.prototype.endElement = function (name) { };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */
    YAMLCBWriter.prototype._beginLine = function (suppressArray) {
        if (suppressArray === void 0) { suppressArray = false; }
        return (this.hasData ? this._writerOptions.newline : "") +
            this._indent(this._writerOptions.offset + this.level, suppressArray);
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     * @param suppressArray - whether the suppress array marker
     */
    YAMLCBWriter.prototype._indent = function (level, suppressArray) {
        if (level + this._additionalLevel <= 0) {
            return "";
        }
        else {
            var chars = this._writerOptions.indent.repeat(level + this._additionalLevel);
            if (!suppressArray && this._rootWritten) {
                return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);
            }
            return chars;
        }
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */
    YAMLCBWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */
    YAMLCBWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return YAMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter));
exports.YAMLCBWriter = YAMLCBWriter;
//# sourceMappingURL=YAMLCBWriter.js.map

/***/ }),

/***/ 6517:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ObjectWriter_1 = __nccwpck_require__(243);
var util_1 = __nccwpck_require__(6195);
var BaseWriter_1 = __nccwpck_require__(7644);
/**
 * Serializes XML nodes into a YAML string.
 */
var YAMLWriter = /** @class */ (function (_super) {
    __extends(YAMLWriter, _super);
    /**
     * Initializes a new instance of `YAMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */
    function YAMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            indent: '  ',
            newline: '\n',
            offset: 0,
            group: false,
            verbose: false
        });
        if (_this._writerOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (_this._writerOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */
    YAMLWriter.prototype.serialize = function (node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        var markup = this._beginLine(this._writerOptions, 0) + '---' + this._endLine(this._writerOptions) +
            this._convertObject(val, this._writerOptions, 0);
        // remove trailing newline
        /* istanbul ignore else */
        if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            markup = markup.slice(0, -this._writerOptions.newline.length);
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     * @param indentLeaf - indents leaf nodes
     */
    YAMLWriter.prototype._convertObject = function (obj, options, level, suppressIndent) {
        var e_1, _a;
        var _this = this;
        if (suppressIndent === void 0) { suppressIndent = false; }
        var markup = '';
        if (util_1.isArray(obj)) {
            try {
                for (var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()) {
                    var val = obj_1_1.value;
                    markup += this._beginLine(options, level, true);
                    if (!util_1.isObject(val)) {
                        markup += this._val(val) + this._endLine(options);
                    }
                    else if (util_1.isEmpty(val)) {
                        markup += '""' + this._endLine(options);
                    }
                    else {
                        markup += this._convertObject(val, options, level, true);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        else /* if (isObject(obj)) */ {
            util_1.forEachObject(obj, function (key, val) {
                if (suppressIndent) {
                    markup += _this._key(key);
                    suppressIndent = false;
                }
                else {
                    markup += _this._beginLine(options, level) + _this._key(key);
                }
                if (!util_1.isObject(val)) {
                    markup += ' ' + _this._val(val) + _this._endLine(options);
                }
                else if (util_1.isEmpty(val)) {
                    markup += ' ""' + _this._endLine(options);
                }
                else {
                    markup += _this._endLine(options) +
                        _this._convertObject(val, options, level + 1);
                }
            }, this);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     * @param isArray - whether this line is an array item
     */
    YAMLWriter.prototype._beginLine = function (options, level, isArray) {
        if (isArray === void 0) { isArray = false; }
        var indentLevel = options.offset + level + 1;
        var chars = new Array(indentLevel).join(options.indent);
        if (isArray) {
            return chars.substr(0, chars.length - 2) + '-' + chars.substr(-1, 1);
        }
        else {
            return chars;
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     */
    YAMLWriter.prototype._endLine = function (options) {
        return options.newline;
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */
    YAMLWriter.prototype._key = function (key) {
        return "\"" + key + "\":";
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */
    YAMLWriter.prototype._val = function (val) {
        return JSON.stringify(val);
    };
    return YAMLWriter;
}(BaseWriter_1.BaseWriter));
exports.YAMLWriter = YAMLWriter;
//# sourceMappingURL=YAMLWriter.js.map

/***/ }),

/***/ 7476:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MapWriter_1 = __nccwpck_require__(1397);
exports.MapWriter = MapWriter_1.MapWriter;
var XMLWriter_1 = __nccwpck_require__(9606);
exports.XMLWriter = XMLWriter_1.XMLWriter;
var ObjectWriter_1 = __nccwpck_require__(243);
exports.ObjectWriter = ObjectWriter_1.ObjectWriter;
var JSONWriter_1 = __nccwpck_require__(7510);
exports.JSONWriter = JSONWriter_1.JSONWriter;
var YAMLWriter_1 = __nccwpck_require__(6517);
exports.YAMLWriter = YAMLWriter_1.YAMLWriter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 829:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";



var yaml = __nccwpck_require__(9625);


module.exports = yaml;


/***/ }),

/***/ 9625:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";



var loader = __nccwpck_require__(342);
var dumper = __nccwpck_require__(8069);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type = __nccwpck_require__(256);
module.exports.Schema = __nccwpck_require__(6280);
module.exports.FAILSAFE_SCHEMA = __nccwpck_require__(26);
module.exports.JSON_SCHEMA = __nccwpck_require__(2168);
module.exports.CORE_SCHEMA = __nccwpck_require__(1950);
module.exports.DEFAULT_SAFE_SCHEMA = __nccwpck_require__(2881);
module.exports.DEFAULT_FULL_SCHEMA = __nccwpck_require__(145);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException = __nccwpck_require__(9291);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __nccwpck_require__(26);
module.exports.SAFE_SCHEMA = __nccwpck_require__(2881);
module.exports.DEFAULT_SCHEMA = __nccwpck_require__(145);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),

/***/ 9941:
/***/ ((module) => {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),

/***/ 8069:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __nccwpck_require__(9941);
var YAMLException       = __nccwpck_require__(9291);
var DEFAULT_FULL_SCHEMA = __nccwpck_require__(145);
var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(2881);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnâ€™t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
    // byte-order-mark
    && c !== 0xFEFF
    // b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON
    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ"â€
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | â€œ%â€ | â€œ@â€ | â€œ`â€)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    â€¢ No ending newline => unaffected; already using strip "-" chomping.
//    â€¢ Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),

/***/ 9291:
/***/ ((module) => {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),

/***/ 342:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __nccwpck_require__(9941);
var YAMLException       = __nccwpck_require__(9291);
var Mark                = __nccwpck_require__(7262);
var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(2881);
var DEFAULT_FULL_SCHEMA = __nccwpck_require__(145);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),

/***/ 7262:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";



var common = __nccwpck_require__(9941);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),

/***/ 6280:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*eslint-disable max-len*/

var common        = __nccwpck_require__(9941);
var YAMLException = __nccwpck_require__(9291);
var Type          = __nccwpck_require__(256);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),

/***/ 1950:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __nccwpck_require__(6280);


module.exports = new Schema({
  include: [
    __nccwpck_require__(2168)
  ]
});


/***/ }),

/***/ 145:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __nccwpck_require__(6280);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __nccwpck_require__(2881)
  ],
  explicit: [
    __nccwpck_require__(4801),
    __nccwpck_require__(7234),
    __nccwpck_require__(5361)
  ]
});


/***/ }),

/***/ 2881:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __nccwpck_require__(6280);


module.exports = new Schema({
  include: [
    __nccwpck_require__(1950)
  ],
  implicit: [
    __nccwpck_require__(2018),
    __nccwpck_require__(194)
  ],
  explicit: [
    __nccwpck_require__(1716),
    __nccwpck_require__(6439),
    __nccwpck_require__(3730),
    __nccwpck_require__(9047)
  ]
});


/***/ }),

/***/ 26:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __nccwpck_require__(6280);


module.exports = new Schema({
  explicit: [
    __nccwpck_require__(4649),
    __nccwpck_require__(5629),
    __nccwpck_require__(5938)
  ]
});


/***/ }),

/***/ 2168:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __nccwpck_require__(6280);


module.exports = new Schema({
  include: [
    __nccwpck_require__(26)
  ],
  implicit: [
    __nccwpck_require__(6058),
    __nccwpck_require__(3195),
    __nccwpck_require__(6865),
    __nccwpck_require__(6480)
  ]
});


/***/ }),

/***/ 256:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var YAMLException = __nccwpck_require__(9291);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),

/***/ 1716:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = _require('buffer').Buffer;
} catch (__) {}

var Type       = __nccwpck_require__(256);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),

/***/ 3195:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 6480:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var common = __nccwpck_require__(9941);
var Type   = __nccwpck_require__(256);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 6865:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var common = __nccwpck_require__(9941);
var Type   = __nccwpck_require__(256);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),

/***/ 5361:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = _require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __nccwpck_require__(256);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),

/***/ 7234:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),

/***/ 4801:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),

/***/ 5938:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),

/***/ 194:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),

/***/ 6058:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),

/***/ 6439:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),

/***/ 3730:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),

/***/ 5629:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),

/***/ 9047:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),

/***/ 4649:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),

/***/ 2018:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var Type = __nccwpck_require__(256);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 9523:
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5158:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 3765:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(3109);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map